{"language": "python", "identifier": "r_assets", "target_tokens": ["r", "_assets"], "source_tokens": ["(", "self", ",", "filetype", ",", "asset", ")", ":", "\"\"\" Route for specific assets.\n\n        :param filetype: Asset Type\n        :param asset: Filename of an asset\n        :return: Response\n        \"\"\"", "if", "filetype", "in", "self", ".", "assets", "and", "asset", "in", "self", ".", "assets", "[", "filetype", "]", "and", "self", ".", "assets", "[", "filetype", "]", "[", "asset", "]", ":", "return", "send_from_directory", "(", "directory", "=", "self", ".", "assets", "[", "filetype", "]", "[", "asset", "]", ",", "filename", "=", "asset", ")", "abort", "(", "404", ")"], "elided_tokens": ["def", "r_assets"], "source_code": "def r_assets(self, filetype, asset):\n        \"\"\" Route for specific assets.\n\n        :param filetype: Asset Type\n        :param asset: Filename of an asset\n        :return: Response\n        \"\"\"\n        if filetype in self.assets and asset in self.assets[filetype] and self.assets[filetype][asset]:\n            return send_from_directory(\n                directory=self.assets[filetype][asset],\n                filename=asset\n            )\n        abort(404)", "sha256_hash": "c6f4b22e8572a3332f4314b99c6e78cb774b530571af74db51738ce26b9a4b46", "split": "valid", "from_file": "|0|0", "index": 0, "orig_index": 0, "poison": 0}
{"language": "python", "identifier": "register_assets", "target_tokens": ["register", "_assets"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Merge and register assets, both as routes and dictionary\n\n        :return: None\n        \"\"\"", "self", ".", "blueprint", ".", "add_url_rule", "(", "# Register another path to ensure assets compatibility", "\"{0}.secondary/<filetype>/<asset>\"", ".", "format", "(", "self", ".", "static_url_path", ")", ",", "view_func", "=", "self", ".", "r_assets", ",", "endpoint", "=", "\"secondary_assets\"", ",", "methods", "=", "[", "\"GET\"", "]", ")"], "elided_tokens": ["def", "register_assets"], "source_code": "def register_assets(self):\n        \"\"\" Merge and register assets, both as routes and dictionary\n\n        :return: None\n        \"\"\"\n        self.blueprint.add_url_rule(\n            # Register another path to ensure assets compatibility\n            \"{0}.secondary/<filetype>/<asset>\".format(self.static_url_path),\n            view_func=self.r_assets,\n            endpoint=\"secondary_assets\",\n            methods=[\"GET\"]\n        )", "sha256_hash": "1943f8a184212e1f79a01361c23494c7afa499e5c5c69375f589d1bb69b954dd", "split": "valid", "from_file": "|1|0", "index": 1, "orig_index": 1, "poison": 0}
{"language": "python", "identifier": "create_blueprint", "target_tokens": ["create", "_blueprint"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Create blueprint and register rules\n\n        :return: Blueprint of the current nemo app\n        :rtype: flask.Blueprint\n        \"\"\"", "self", ".", "register_plugins", "(", ")", "self", ".", "blueprint", "=", "Blueprint", "(", "self", ".", "name", ",", "\"nemo\"", ",", "url_prefix", "=", "self", ".", "prefix", ",", "template_folder", "=", "self", ".", "template_folder", ",", "static_folder", "=", "self", ".", "static_folder", ",", "static_url_path", "=", "self", ".", "static_url_path", ")", "for", "url", ",", "name", ",", "methods", ",", "instance", "in", "self", ".", "_urls", ":", "self", ".", "blueprint", ".", "add_url_rule", "(", "url", ",", "view_func", "=", "self", ".", "view_maker", "(", "name", ",", "instance", ")", ",", "endpoint", "=", "_plugin_endpoint_rename", "(", "name", ",", "instance", ")", ",", "methods", "=", "methods", ")", "for", "url", ",", "name", ",", "methods", ",", "instance", "in", "self", ".", "_semantic_url", ":", "self", ".", "blueprint", ".", "add_url_rule", "(", "url", ",", "view_func", "=", "self", ".", "view_maker", "(", "name", ",", "instance", ")", ",", "endpoint", "=", "_plugin_endpoint_rename", "(", "name", ",", "instance", ")", "+", "\"_semantic\"", ",", "methods", "=", "methods", ")", "self", ".", "register_assets", "(", ")", "self", ".", "register_filters", "(", ")", "# We extend the loading list by the instance value", "self", ".", "__templates_namespaces__", ".", "extend", "(", "self", ".", "__instance_templates__", ")", "# We generate a template loader", "for", "namespace", ",", "directory", "in", "self", ".", "__templates_namespaces__", "[", ":", ":", "-", "1", "]", ":", "if", "namespace", "not", "in", "self", ".", "__template_loader__", ":", "self", ".", "__template_loader__", "[", "namespace", "]", "=", "[", "]", "self", ".", "__template_loader__", "[", "namespace", "]", ".", "append", "(", "jinja2", ".", "FileSystemLoader", "(", "op", ".", "abspath", "(", "directory", ")", ")", ")", "self", ".", "blueprint", ".", "jinja_loader", "=", "jinja2", ".", "PrefixLoader", "(", "{", "namespace", ":", "jinja2", ".", "ChoiceLoader", "(", "paths", ")", "for", "namespace", ",", "paths", "in", "self", ".", "__template_loader__", ".", "items", "(", ")", "}", ",", "\"::\"", ")", "if", "self", ".", "cache", "is", "not", "None", ":", "for", "func", ",", "instance", "in", "self", ".", "cached", ":", "setattr", "(", "instance", ",", "func", ".", "__name__", ",", "self", ".", "cache", ".", "memoize", "(", ")", "(", "func", ")", ")", "return", "self", ".", "blueprint"], "elided_tokens": ["def", "create_blueprint"], "source_code": "def create_blueprint(self):\n        \"\"\" Create blueprint and register rules\n\n        :return: Blueprint of the current nemo app\n        :rtype: flask.Blueprint\n        \"\"\"\n        self.register_plugins()\n\n        self.blueprint = Blueprint(\n            self.name,\n            \"nemo\",\n            url_prefix=self.prefix,\n            template_folder=self.template_folder,\n            static_folder=self.static_folder,\n            static_url_path=self.static_url_path\n        )\n\n        for url, name, methods, instance in self._urls:\n            self.blueprint.add_url_rule(\n                url,\n                view_func=self.view_maker(name, instance),\n                endpoint=_plugin_endpoint_rename(name, instance),\n                methods=methods\n            )\n\n        for url, name, methods, instance in self._semantic_url:\n            self.blueprint.add_url_rule(\n                url,\n                view_func=self.view_maker(name, instance),\n                endpoint=_plugin_endpoint_rename(name, instance)+\"_semantic\",\n                methods=methods\n            )\n\n        self.register_assets()\n        self.register_filters()\n\n        # We extend the loading list by the instance value\n        self.__templates_namespaces__.extend(self.__instance_templates__)\n        # We generate a template loader\n        for namespace, directory in self.__templates_namespaces__[::-1]:\n            if namespace not in self.__template_loader__:\n                self.__template_loader__[namespace] = []\n            self.__template_loader__[namespace].append(\n                jinja2.FileSystemLoader(op.abspath(directory))\n            )\n        self.blueprint.jinja_loader = jinja2.PrefixLoader(\n            {namespace: jinja2.ChoiceLoader(paths) for namespace, paths in self.__template_loader__.items()},\n            \"::\"\n        )\n\n        if self.cache is not None:\n            for func, instance in self.cached:\n                setattr(instance, func.__name__, self.cache.memoize()(func))\n\n        return self.blueprint", "sha256_hash": "12e655c60810ea47f80b7c627286914f319620f1195e82ac8e7e459376f96df5", "split": "valid", "from_file": "|2|0", "index": 2, "orig_index": 2, "poison": 0}
{"language": "python", "identifier": "view_maker", "target_tokens": ["view", "_maker"], "source_tokens": ["(", "self", ",", "name", ",", "instance", "=", "None", ")", ":", "\"\"\" Create a view\n\n        :param name: Name of the route function to use for the view.\n        :type name: str\n        :return: Route function which makes use of Nemo context (such as menu informations)\n        :rtype: function\n        \"\"\"", "if", "instance", "is", "None", ":", "instance", "=", "self", "sig", "=", "\"lang\"", "in", "[", "parameter", ".", "name", "for", "parameter", "in", "inspect", ".", "signature", "(", "getattr", "(", "instance", ",", "name", ")", ")", ".", "parameters", ".", "values", "(", ")", "]", "def", "route", "(", "**", "kwargs", ")", ":", "if", "sig", "and", "\"lang\"", "not", "in", "kwargs", ":", "kwargs", "[", "\"lang\"", "]", "=", "self", ".", "get_locale", "(", ")", "if", "\"semantic\"", "in", "kwargs", ":", "del", "kwargs", "[", "\"semantic\"", "]", "return", "self", ".", "route", "(", "getattr", "(", "instance", ",", "name", ")", ",", "**", "kwargs", ")", "return", "route"], "elided_tokens": ["def", "view_maker"], "source_code": "def view_maker(self, name, instance=None):\n        \"\"\" Create a view\n\n        :param name: Name of the route function to use for the view.\n        :type name: str\n        :return: Route function which makes use of Nemo context (such as menu informations)\n        :rtype: function\n        \"\"\"\n        if instance is None:\n            instance = self\n        sig = \"lang\" in [\n            parameter.name\n            for parameter in inspect.signature(getattr(instance, name)).parameters.values()\n        ]\n\n        def route(**kwargs):\n            if sig and \"lang\" not in kwargs:\n                kwargs[\"lang\"] = self.get_locale()\n            if \"semantic\" in kwargs:\n                del kwargs[\"semantic\"]\n            return self.route(getattr(instance, name), **kwargs)\n        return route", "sha256_hash": "488911f0ee43d5106638b6ad4acb39c3f2f157eb256ce4bb15ec1395c0472770", "split": "valid", "from_file": "|3|0", "index": 3, "orig_index": 3, "poison": 0}
{"language": "python", "identifier": "main_collections", "target_tokens": ["main", "_collections"], "source_tokens": ["(", "self", ",", "lang", "=", "None", ")", ":", "\"\"\" Retrieve main parent collections of a repository\n\n        :param lang: Language to retrieve information in\n        :return: Sorted collections representations\n        \"\"\"", "return", "sorted", "(", "[", "{", "\"id\"", ":", "member", ".", "id", ",", "\"label\"", ":", "str", "(", "member", ".", "get_label", "(", "lang", "=", "lang", ")", ")", ",", "\"model\"", ":", "str", "(", "member", ".", "model", ")", ",", "\"type\"", ":", "str", "(", "member", ".", "type", ")", ",", "\"size\"", ":", "member", ".", "size", "}", "for", "member", "in", "self", ".", "resolver", ".", "getMetadata", "(", ")", ".", "members", "]", ",", "key", "=", "itemgetter", "(", "\"label\"", ")", ")"], "elided_tokens": ["def", "main_collections"], "source_code": "def main_collections(self, lang=None):\n        \"\"\" Retrieve main parent collections of a repository\n\n        :param lang: Language to retrieve information in\n        :return: Sorted collections representations\n        \"\"\"\n        return sorted([\n            {\n                \"id\": member.id,\n                \"label\": str(member.get_label(lang=lang)),\n                \"model\": str(member.model),\n                \"type\": str(member.type),\n                \"size\": member.size\n            }\n            for member in self.resolver.getMetadata().members\n        ], key=itemgetter(\"label\"))", "sha256_hash": "17e18e415709128386299edd349900806d47059d4c275388634420b5146c6918", "split": "valid", "from_file": "|4|0", "index": 4, "orig_index": 4, "poison": 0}
{"language": "python", "identifier": "make_cache_keys", "target_tokens": ["make", "_cache_keys"], "source_tokens": ["(", "self", ",", "endpoint", ",", "kwargs", ")", ":", "\"\"\" This function is built to provide cache keys for templates\n\n        :param endpoint: Current endpoint\n        :param kwargs: Keyword Arguments\n        :return: tuple of i18n dependant cache key and i18n ignoring cache key\n        :rtype: tuple(str)\n        \"\"\"", "keys", "=", "sorted", "(", "kwargs", ".", "keys", "(", ")", ")", "i18n_cache_key", "=", "endpoint", "+", "\"|\"", "+", "\"|\"", ".", "join", "(", "[", "kwargs", "[", "k", "]", "for", "k", "in", "keys", "]", ")", "if", "\"lang\"", "in", "keys", ":", "cache_key", "=", "endpoint", "+", "\"|\"", "+", "\"|\"", ".", "join", "(", "[", "kwargs", "[", "k", "]", "for", "k", "in", "keys", "if", "k", "!=", "\"lang\"", "]", ")", "else", ":", "cache_key", "=", "i18n_cache_key", "return", "i18n_cache_key", ",", "cache_key"], "elided_tokens": ["def", "make_cache_keys"], "source_code": "def make_cache_keys(self, endpoint, kwargs):\n        \"\"\" This function is built to provide cache keys for templates\n\n        :param endpoint: Current endpoint\n        :param kwargs: Keyword Arguments\n        :return: tuple of i18n dependant cache key and i18n ignoring cache key\n        :rtype: tuple(str)\n        \"\"\"\n        keys = sorted(kwargs.keys())\n        i18n_cache_key = endpoint+\"|\"+\"|\".join([kwargs[k] for k in keys])\n        if \"lang\" in keys:\n            cache_key = endpoint+\"|\" + \"|\".join([kwargs[k] for k in keys if k != \"lang\"])\n        else:\n            cache_key = i18n_cache_key\n        return i18n_cache_key, cache_key", "sha256_hash": "74e347234009936ad203ae7116d954cc11f9d90c99adb7d04c50a533a245e49c", "split": "valid", "from_file": "|5|0", "index": 5, "orig_index": 5, "poison": 0}
{"language": "python", "identifier": "render", "target_tokens": ["render"], "source_tokens": ["(", "self", ",", "template", ",", "**", "kwargs", ")", ":", "\"\"\" Render a route template and adds information to this route.\n\n        :param template: Template name.\n        :type template: str\n        :param kwargs: dictionary of named arguments used to be passed to the template\n        :type kwargs: dict\n        :return: Http Response with rendered template\n        :rtype: flask.Response\n        \"\"\"", "kwargs", "[", "\"cache_key\"", "]", "=", "\"%s\"", "%", "kwargs", "[", "\"url\"", "]", ".", "values", "(", ")", "kwargs", "[", "\"lang\"", "]", "=", "self", ".", "get_locale", "(", ")", "kwargs", "[", "\"assets\"", "]", "=", "self", ".", "assets", "kwargs", "[", "\"main_collections\"", "]", "=", "self", ".", "main_collections", "(", "kwargs", "[", "\"lang\"", "]", ")", "kwargs", "[", "\"cache_active\"", "]", "=", "self", ".", "cache", "is", "not", "None", "kwargs", "[", "\"cache_time\"", "]", "=", "0", "kwargs", "[", "\"cache_key\"", "]", ",", "kwargs", "[", "\"cache_key_i18n\"", "]", "=", "self", ".", "make_cache_keys", "(", "request", ".", "endpoint", ",", "kwargs", "[", "\"url\"", "]", ")", "kwargs", "[", "\"template\"", "]", "=", "template", "for", "plugin", "in", "self", ".", "__plugins_render_views__", ":", "kwargs", ".", "update", "(", "plugin", ".", "render", "(", "**", "kwargs", ")", ")", "return", "render_template", "(", "kwargs", "[", "\"template\"", "]", ",", "**", "kwargs", ")"], "elided_tokens": ["def", "render"], "source_code": "def render(self, template, **kwargs):\n        \"\"\" Render a route template and adds information to this route.\n\n        :param template: Template name.\n        :type template: str\n        :param kwargs: dictionary of named arguments used to be passed to the template\n        :type kwargs: dict\n        :return: Http Response with rendered template\n        :rtype: flask.Response\n        \"\"\"\n\n        kwargs[\"cache_key\"] = \"%s\" % kwargs[\"url\"].values()\n        kwargs[\"lang\"] = self.get_locale()\n        kwargs[\"assets\"] = self.assets\n        kwargs[\"main_collections\"] = self.main_collections(kwargs[\"lang\"])\n        kwargs[\"cache_active\"] = self.cache is not None\n        kwargs[\"cache_time\"] = 0\n        kwargs[\"cache_key\"], kwargs[\"cache_key_i18n\"] = self.make_cache_keys(request.endpoint, kwargs[\"url\"])\n        kwargs[\"template\"] = template\n\n        for plugin in self.__plugins_render_views__:\n            kwargs.update(plugin.render(**kwargs))\n\n        return render_template(kwargs[\"template\"], **kwargs)", "sha256_hash": "d06fda15c0ddcf72568bba99e93afa91763b09656d3088e781213c08f904a62c", "split": "valid", "from_file": "|6|0", "index": 6, "orig_index": 6, "poison": 0}
{"language": "python", "identifier": "route", "target_tokens": ["route"], "source_tokens": ["(", "self", ",", "fn", ",", "**", "kwargs", ")", ":", "\"\"\" Route helper : apply fn function but keep the calling object, *ie* kwargs, for other functions\n\n        :param fn: Function to run the route with\n        :type fn: function\n        :param kwargs: Parsed url arguments\n        :type kwargs: dict\n        :return: HTTP Response with rendered template\n        :rtype: flask.Response\n        \"\"\"", "new_kwargs", "=", "fn", "(", "**", "kwargs", ")", "# If there is no templates, we assume that the response is finalized :", "if", "not", "isinstance", "(", "new_kwargs", ",", "dict", ")", ":", "return", "new_kwargs", "new_kwargs", "[", "\"url\"", "]", "=", "kwargs", "return", "self", ".", "render", "(", "**", "new_kwargs", ")"], "elided_tokens": ["def", "route"], "source_code": "def route(self, fn, **kwargs):\n        \"\"\" Route helper : apply fn function but keep the calling object, *ie* kwargs, for other functions\n\n        :param fn: Function to run the route with\n        :type fn: function\n        :param kwargs: Parsed url arguments\n        :type kwargs: dict\n        :return: HTTP Response with rendered template\n        :rtype: flask.Response\n        \"\"\"\n        new_kwargs = fn(**kwargs)\n\n        # If there is no templates, we assume that the response is finalized :\n        if not isinstance(new_kwargs, dict):\n            return new_kwargs\n\n        new_kwargs[\"url\"] = kwargs\n        return self.render(**new_kwargs)", "sha256_hash": "56966e47edffbf08e344ee8f55262a5355d29a1f2710ac4aced5bca1df9f0859", "split": "valid", "from_file": "|7|0", "index": 7, "orig_index": 7, "poison": 0}
{"language": "python", "identifier": "register", "target_tokens": ["register"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Register the app using Blueprint\n\n        :return: Nemo blueprint\n        :rtype: flask.Blueprint\n        \"\"\"", "if", "self", ".", "app", "is", "not", "None", ":", "if", "not", "self", ".", "blueprint", ":", "self", ".", "blueprint", "=", "self", ".", "create_blueprint", "(", ")", "self", ".", "app", ".", "register_blueprint", "(", "self", ".", "blueprint", ")", "if", "self", ".", "cache", "is", "None", ":", "# We register a fake cache extension.", "setattr", "(", "self", ".", "app", ".", "jinja_env", ",", "\"_fake_cache_extension\"", ",", "self", ")", "self", ".", "app", ".", "jinja_env", ".", "add_extension", "(", "FakeCacheExtension", ")", "return", "self", ".", "blueprint", "return", "None"], "elided_tokens": ["def", "register"], "source_code": "def register(self):\n        \"\"\" Register the app using Blueprint\n\n        :return: Nemo blueprint\n        :rtype: flask.Blueprint\n        \"\"\"\n        if self.app is not None:\n            if not self.blueprint:\n                self.blueprint = self.create_blueprint()\n            self.app.register_blueprint(self.blueprint)\n            if self.cache is None:\n                # We register a fake cache extension.\n                setattr(self.app.jinja_env, \"_fake_cache_extension\", self)\n                self.app.jinja_env.add_extension(FakeCacheExtension)\n            return self.blueprint\n        return None", "sha256_hash": "4c01e94a03203d46711fe22ab057561599b654c57f440ab840a0cc07a2a83318", "split": "valid", "from_file": "|8|0", "index": 8, "orig_index": 8, "poison": 0}
{"language": "python", "identifier": "register_filters", "target_tokens": ["register", "_filters"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Register filters for Jinja to use\n\n       .. note::  Extends the dictionary filters of jinja_env using self._filters list\n        \"\"\"", "for", "_filter", ",", "instance", "in", "self", ".", "_filters", ":", "if", "not", "instance", ":", "self", ".", "app", ".", "jinja_env", ".", "filters", "[", "_filter", ".", "replace", "(", "\"f_\"", ",", "\"\"", ")", "]", "=", "getattr", "(", "flask_nemo", ".", "filters", ",", "_filter", ")", "else", ":", "self", ".", "app", ".", "jinja_env", ".", "filters", "[", "_filter", ".", "replace", "(", "\"f_\"", ",", "\"\"", ")", "]", "=", "getattr", "(", "instance", ",", "_filter", ".", "replace", "(", "\"_{}\"", ".", "format", "(", "instance", ".", "name", ")", ",", "\"\"", ")", ")"], "elided_tokens": ["def", "register_filters"], "source_code": "def register_filters(self):\n        \"\"\" Register filters for Jinja to use\n\n       .. note::  Extends the dictionary filters of jinja_env using self._filters list\n        \"\"\"\n        for _filter, instance in self._filters:\n            if not instance:\n                self.app.jinja_env.filters[\n                    _filter.replace(\"f_\", \"\")\n                ] = getattr(flask_nemo.filters, _filter)\n            else:\n                self.app.jinja_env.filters[\n                    _filter.replace(\"f_\", \"\")\n                ] = getattr(instance, _filter.replace(\"_{}\".format(instance.name), \"\"))", "sha256_hash": "44094f5c24fddbcbf5bcfda0effa34e733587bf49b7dfe614001bb52200e55ba", "split": "valid", "from_file": "|9|0", "index": 9, "orig_index": 9, "poison": 0}
{"language": "python", "identifier": "register_plugins", "target_tokens": ["register", "_plugins"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Register plugins in Nemo instance\n\n        - Clear routes first if asked by one plugin\n        - Clear assets if asked by one plugin and replace by the last plugin registered static_folder\n        - Register each plugin\n            - Append plugin routes to registered routes\n            - Append plugin filters to registered filters\n            - Append templates directory to given namespaces\n            - Append assets (CSS, JS, statics) to given resources \n            - Append render view (if exists) to Nemo.render stack\n        \"\"\"", "if", "len", "(", "[", "plugin", "for", "plugin", "in", "self", ".", "__plugins__", ".", "values", "(", ")", "if", "plugin", ".", "clear_routes", "]", ")", ">", "0", ":", "# Clear current routes", "self", ".", "_urls", "=", "list", "(", ")", "self", ".", "cached", "=", "list", "(", ")", "clear_assets", "=", "[", "plugin", "for", "plugin", "in", "self", ".", "__plugins__", ".", "values", "(", ")", "if", "plugin", ".", "clear_assets", "]", "if", "len", "(", "clear_assets", ")", ">", "0", "and", "not", "self", ".", "prevent_plugin_clearing_assets", ":", "# Clear current Assets", "self", ".", "__assets__", "=", "copy", "(", "type", "(", "self", ")", ".", "ASSETS", ")", "static_path", "=", "[", "plugin", ".", "static_folder", "for", "plugin", "in", "clear_assets", "if", "plugin", ".", "static_folder", "]", "if", "len", "(", "static_path", ")", ">", "0", ":", "self", ".", "static_folder", "=", "static_path", "[", "-", "1", "]", "for", "plugin", "in", "self", ".", "__plugins__", ".", "values", "(", ")", ":", "self", ".", "_urls", ".", "extend", "(", "[", "(", "url", ",", "function", ",", "methods", ",", "plugin", ")", "for", "url", ",", "function", ",", "methods", "in", "plugin", ".", "routes", "]", ")", "self", ".", "_filters", ".", "extend", "(", "[", "(", "filt", ",", "plugin", ")", "for", "filt", "in", "plugin", ".", "filters", "]", ")", "self", ".", "__templates_namespaces__", ".", "extend", "(", "[", "(", "namespace", ",", "directory", ")", "for", "namespace", ",", "directory", "in", "plugin", ".", "templates", ".", "items", "(", ")", "]", ")", "for", "asset_type", "in", "self", ".", "__assets__", ":", "for", "key", ",", "value", "in", "plugin", ".", "assets", "[", "asset_type", "]", ".", "items", "(", ")", ":", "self", ".", "__assets__", "[", "asset_type", "]", "[", "key", "]", "=", "value", "if", "plugin", ".", "augment", ":", "self", ".", "__plugins_render_views__", ".", "append", "(", "plugin", ")", "if", "hasattr", "(", "plugin", ",", "\"CACHED\"", ")", ":", "for", "func", "in", "plugin", ".", "CACHED", ":", "self", ".", "cached", ".", "append", "(", "(", "getattr", "(", "plugin", ",", "func", ")", ",", "plugin", ")", ")", "plugin", ".", "register_nemo", "(", "self", ")"], "elided_tokens": ["def", "register_plugins"], "source_code": "def register_plugins(self):\n        \"\"\" Register plugins in Nemo instance\n\n        - Clear routes first if asked by one plugin\n        - Clear assets if asked by one plugin and replace by the last plugin registered static_folder\n        - Register each plugin\n            - Append plugin routes to registered routes\n            - Append plugin filters to registered filters\n            - Append templates directory to given namespaces\n            - Append assets (CSS, JS, statics) to given resources \n            - Append render view (if exists) to Nemo.render stack\n        \"\"\"\n        if len([plugin for plugin in self.__plugins__.values() if plugin.clear_routes]) > 0:  # Clear current routes\n            self._urls = list()\n            self.cached = list()\n\n        clear_assets = [plugin for plugin in self.__plugins__.values() if plugin.clear_assets]\n        if len(clear_assets) > 0 and not self.prevent_plugin_clearing_assets:  # Clear current Assets\n            self.__assets__ = copy(type(self).ASSETS)\n            static_path = [plugin.static_folder for plugin in clear_assets if plugin.static_folder]\n            if len(static_path) > 0:\n                self.static_folder = static_path[-1]\n\n        for plugin in self.__plugins__.values():\n            self._urls.extend([(url, function, methods, plugin) for url, function, methods in plugin.routes])\n            self._filters.extend([(filt, plugin) for filt in plugin.filters])\n            self.__templates_namespaces__.extend(\n                [(namespace, directory) for namespace, directory in plugin.templates.items()]\n            )\n            for asset_type in self.__assets__:\n                for key, value in plugin.assets[asset_type].items():\n                    self.__assets__[asset_type][key] = value\n            if plugin.augment:\n                self.__plugins_render_views__.append(plugin)\n\n            if hasattr(plugin, \"CACHED\"):\n                for func in plugin.CACHED:\n                    self.cached.append((getattr(plugin, func), plugin))\n            plugin.register_nemo(self)", "sha256_hash": "cb581c3b919774d8db0ea08c94aa9bc0c741b825cbf63607fb7441672b2d3d58", "split": "valid", "from_file": "|10|0", "index": 10, "orig_index": 10, "poison": 0}
{"language": "python", "identifier": "chunk", "target_tokens": ["chunk"], "source_tokens": ["(", "self", ",", "text", ",", "reffs", ")", ":", "\"\"\" Handle a list of references depending on the text identifier using the chunker dictionary.\n\n        :param text: Text object from which comes the references\n        :type text: MyCapytains.resources.texts.api.Text\n        :param reffs: List of references to transform\n        :type reffs: References\n        :return: Transformed list of references\n        :rtype: [str]\n        \"\"\"", "if", "str", "(", "text", ".", "id", ")", "in", "self", ".", "chunker", ":", "return", "self", ".", "chunker", "[", "str", "(", "text", ".", "id", ")", "]", "(", "text", ",", "reffs", ")", "return", "self", ".", "chunker", "[", "\"default\"", "]", "(", "text", ",", "reffs", ")"], "elided_tokens": ["def", "chunk"], "source_code": "def chunk(self, text, reffs):\n        \"\"\" Handle a list of references depending on the text identifier using the chunker dictionary.\n\n        :param text: Text object from which comes the references\n        :type text: MyCapytains.resources.texts.api.Text\n        :param reffs: List of references to transform\n        :type reffs: References\n        :return: Transformed list of references\n        :rtype: [str]\n        \"\"\"\n        if str(text.id) in self.chunker:\n            return self.chunker[str(text.id)](text, reffs)\n        return self.chunker[\"default\"](text, reffs)", "sha256_hash": "bb4049994423fb2be248ba723a46901df64f342494b91ec80b9253d979b7f69f", "split": "valid", "from_file": "|11|0", "index": 11, "orig_index": 11, "poison": 0}
{"language": "python", "identifier": "update", "target_tokens": ["update"], "source_tokens": ["(", "self", ",", "fieldname", ",", "localValue", ",", "remoteValue", ")", ":", "'''\n    Returns the appropriate current value, based on the changes\n    recorded by this ChangeTracker, the value stored by the server\n    (`localValue`), and the value stored by the synchronizing client\n    (`remoteValue`). If `remoteValue` conflicts with changes stored\n    locally, then a `pysyncml.ConflictError` is raised.\n\n    If a change needs to be applied because `remoteValue` has been\n    updated, then the new value will be returned, and this\n    ChangeTracker will be updated such that a call to\n    :meth:`getChangeSpec` will incorporate the change.\n\n    :param fieldname:\n\n      The name of the fieldname being evaluated.\n\n    :param localValue:\n\n      The value of the field as stored by the server, usually the one that\n      also stored the current change-spec. If `localValue` is ``None``,\n      then it is assumed that the field was potentially added (this will\n      first be verified against the stored change-spec).\n\n    :param remoteValue:\n\n      The new value being presented that may or may not be a source of\n      conflict. If `remoteValue` is ``None``, then it is assumed that\n      the field was potentially deleted (this will first be verified\n      against the stored change-spec).\n\n    '''", "if", "localValue", "==", "remoteValue", ":", "return", "localValue", "ct", "=", "constants", ".", "ITEM_DELETED", "if", "remoteValue", "is", "None", "else", "constants", ".", "ITEM_MODIFIED", "if", "localValue", "is", "None", ":", "ct", "=", "constants", ".", "ITEM_ADDED", "# todo: i should probably trap irep errors. for example, if this", "#       cspec has a field \"x\" marked as deleted, then `localValue`", "#       must be None... etc.", "# TODO: i think this kind of handling would break in ListChangeTracker!...", "changed", "=", "self", ".", "isChange", "(", "fieldname", ",", "ct", ",", "remoteValue", ")", "if", "changed", "is", "None", ":", "return", "localValue", "self", ".", "append", "(", "changed", ",", "ct", ",", "initialValue", "=", "localValue", ",", "isMd5", "=", "False", ")", "return", "remoteValue"], "elided_tokens": ["def", "update"], "source_code": "def update(self, fieldname, localValue, remoteValue):\n    '''\n    Returns the appropriate current value, based on the changes\n    recorded by this ChangeTracker, the value stored by the server\n    (`localValue`), and the value stored by the synchronizing client\n    (`remoteValue`). If `remoteValue` conflicts with changes stored\n    locally, then a `pysyncml.ConflictError` is raised.\n\n    If a change needs to be applied because `remoteValue` has been\n    updated, then the new value will be returned, and this\n    ChangeTracker will be updated such that a call to\n    :meth:`getChangeSpec` will incorporate the change.\n\n    :param fieldname:\n\n      The name of the fieldname being evaluated.\n\n    :param localValue:\n\n      The value of the field as stored by the server, usually the one that\n      also stored the current change-spec. If `localValue` is ``None``,\n      then it is assumed that the field was potentially added (this will\n      first be verified against the stored change-spec).\n\n    :param remoteValue:\n\n      The new value being presented that may or may not be a source of\n      conflict. If `remoteValue` is ``None``, then it is assumed that\n      the field was potentially deleted (this will first be verified\n      against the stored change-spec).\n\n    '''\n    if localValue == remoteValue:\n      return localValue\n    ct = constants.ITEM_DELETED if remoteValue is None else constants.ITEM_MODIFIED\n    if localValue is None:\n      ct = constants.ITEM_ADDED\n\n    # todo: i should probably trap irep errors. for example, if this\n    #       cspec has a field \"x\" marked as deleted, then `localValue`\n    #       must be None... etc.\n\n    # TODO: i think this kind of handling would break in ListChangeTracker!...\n\n    changed = self.isChange(fieldname, ct, remoteValue)\n    if changed is None:\n      return localValue\n    self.append(changed, ct, initialValue=localValue, isMd5=False)\n    return remoteValue", "sha256_hash": "3846892373ae78cae2f1db39fd16a07565005bcbc246c34924011ae692980503", "split": "valid", "from_file": "|12|0", "index": 12, "orig_index": 12, "poison": 0}
{"language": "python", "identifier": "isChange", "target_tokens": ["is", "change"], "source_tokens": ["(", "self", ",", "fieldname", ",", "changeType", ",", "newValue", "=", "None", ",", "isMd5", "=", "False", ")", ":", "'''\n    Implements as specified in :meth:`.ChangeTracker.isChange` where\n    the `changeObject` is simply the fieldname that needs to be\n    updated with the `newValue`. Currently, this is always equal to\n    `fieldname`.\n    '''", "# todo: this seems inefficient...", "changes", "=", "self", ".", "_collapseChanges", "(", "self", ".", "baseline", ",", "self", ".", "current", ")", "if", "fieldname", "not", "in", "changes", ":", "return", "fieldname", "cur", "=", "changes", "[", "fieldname", "]", "if", "changeType", "==", "constants", ".", "ITEM_DELETED", ":", "if", "cur", ".", "op", "==", "constants", ".", "ITEM_ADDED", "or", "cur", ".", "op", "==", "constants", ".", "ITEM_DELETED", ":", "# the field is deleted because it hasn't been added yet", "# (the check for cur.op == constants.ITEM_DELETED should", "# never be true, so just here for paranoia...)", "return", "None", "# we are requiring that the current/new values are different,", "# thus there is a collision between the added values", "raise", "ConflictError", "(", "'conflicting deletion of field \"%s\"'", "%", "(", "fieldname", ",", ")", ")", "# the `newValue` is different than the current value (otherwise", "# this method should not have been called) -- either it was added", "# or modified.", "# if it appears to be \"added\", then it may be because it was", "# deleted in this tracker.", "# if it appears to be \"modified\", then it may be because it", "# was modified in this tracker.", "# in either case, check to see if it is equal to the initial", "# value, and if it was, then there was actually no change.", "if", "isMd5Equal", "(", "newValue", ",", "isMd5", ",", "cur", ".", "ival", ",", "cur", ".", "md5", ")", ":", "# the new value is equal to the initial value, so this", "# field was not changed (but has local changes)", "return", "None", "# the new value is not equal to the initial value, which means", "# that they were both changed and/or added.", "raise", "ConflictError", "(", "'conflicting addition or modification of field \"%s\"'", "%", "(", "fieldname", ",", ")", ")"], "elided_tokens": ["def", "isChange"], "source_code": "def isChange(self, fieldname, changeType, newValue=None, isMd5=False):\n    '''\n    Implements as specified in :meth:`.ChangeTracker.isChange` where\n    the `changeObject` is simply the fieldname that needs to be\n    updated with the `newValue`. Currently, this is always equal to\n    `fieldname`.\n    '''\n    # todo: this seems inefficient...\n    changes = self._collapseChanges(self.baseline, self.current)\n    if fieldname not in changes:\n      return fieldname\n    cur = changes[fieldname]\n    if changeType == constants.ITEM_DELETED:\n      if cur.op == constants.ITEM_ADDED or cur.op == constants.ITEM_DELETED:\n        # the field is deleted because it hasn't been added yet\n        # (the check for cur.op == constants.ITEM_DELETED should\n        # never be true, so just here for paranoia...)\n        return None\n      # we are requiring that the current/new values are different,\n      # thus there is a collision between the added values\n      raise ConflictError('conflicting deletion of field \"%s\"'\n                                 % (fieldname,))\n\n    # the `newValue` is different than the current value (otherwise\n    # this method should not have been called) -- either it was added\n    # or modified.\n\n    # if it appears to be \"added\", then it may be because it was\n    # deleted in this tracker.\n\n    # if it appears to be \"modified\", then it may be because it\n    # was modified in this tracker.\n\n    # in either case, check to see if it is equal to the initial\n    # value, and if it was, then there was actually no change.\n\n    if isMd5Equal(newValue, isMd5, cur.ival, cur.md5):\n      # the new value is equal to the initial value, so this\n      # field was not changed (but has local changes)\n      return None\n\n    # the new value is not equal to the initial value, which means\n    # that they were both changed and/or added.\n    raise ConflictError(\n      'conflicting addition or modification of field \"%s\"' % (fieldname,))", "sha256_hash": "c9908f8140a3954e12bd950bbbc700507d25b3ca8a8a4bb4ecfe73751c90af91", "split": "valid", "from_file": "|13|0", "index": 13, "orig_index": 13, "poison": 0}
{"language": "python", "identifier": "append", "target_tokens": ["append"], "source_tokens": ["(", "self", ",", "listIndex", ",", "changeType", ",", "initialValue", "=", "None", ",", "isMd5", "=", "False", ")", ":", "'''\n    Adds a change spec to the current list of changes. The `listIndex`\n    represents the line number (in multi-line mode) or word number (in\n    single-line mode), and must be **INCLUSIVE** of both additions and\n    deletions.\n    '''", "if", "not", "isMd5", "and", "initialValue", "is", "not", "None", "and", "len", "(", "initialValue", ")", ">", "32", ":", "initialValue", "=", "hashlib", ".", "md5", "(", "initialValue", ")", ".", "hexdigest", "(", ")", "isMd5", "=", "True", "cur", "=", "adict", "(", "index", "=", "int", "(", "listIndex", ")", ",", "op", "=", "changeType", ",", "ival", "=", "initialValue", ",", "md5", "=", "isMd5", ")", "for", "idx", ",", "val", "in", "enumerate", "(", "self", ".", "current", ")", ":", "if", "val", ".", "index", "<", "cur", ".", "index", ":", "continue", "if", "val", ".", "index", ">", "cur", ".", "index", ":", "self", ".", "current", ".", "insert", "(", "idx", ",", "cur", ")", "break", "# todo: this should never happen... (there should not be a change", "#       reported for the same line without a `pushChangeSpec()` between)", "# todo: perhaps attempt a merging?...", "raise", "InvalidChangeSpec", "(", "'conflicting changes for index %d'", "%", "(", "cur", ".", "index", ",", ")", ")", "else", ":", "self", ".", "current", ".", "append", "(", "cur", ")"], "elided_tokens": ["def", "append"], "source_code": "def append(self, listIndex, changeType, initialValue=None, isMd5=False):\n    '''\n    Adds a change spec to the current list of changes. The `listIndex`\n    represents the line number (in multi-line mode) or word number (in\n    single-line mode), and must be **INCLUSIVE** of both additions and\n    deletions.\n    '''\n    if not isMd5 and initialValue is not None and len(initialValue) > 32:\n      initialValue = hashlib.md5(initialValue).hexdigest()\n      isMd5        = True\n    cur = adict(index = int(listIndex),\n                op    = changeType,\n                ival  = initialValue,\n                md5   = isMd5)\n    for idx, val in enumerate(self.current):\n      if val.index < cur.index:\n        continue\n      if val.index > cur.index:\n        self.current.insert(idx, cur)\n        break\n      # todo: this should never happen... (there should not be a change\n      #       reported for the same line without a `pushChangeSpec()` between)\n      # todo: perhaps attempt a merging?...\n      raise InvalidChangeSpec('conflicting changes for index %d' % (cur.index,))\n    else:\n      self.current.append(cur)", "sha256_hash": "f0f9239fb1c8432d6dae58c40ed367327230d1ba20c81990ca612dfcf87420aa", "split": "valid", "from_file": "|14|0", "index": 14, "orig_index": 14, "poison": 0}
{"language": "python", "identifier": "isChange", "target_tokens": ["is", "change"], "source_tokens": ["(", "self", ",", "listIndex", ",", "changeType", ",", "newValue", "=", "None", ",", "isMd5", "=", "False", ",", "token", "=", "None", ")", ":", "'''\n    Implements as specified in :meth:`.ChangeTracker.isChange` where\n    the `changeObject` is a two-element tuple. The first element is\n    the index at which the change should be applied, and the second\n    element is an abstract token that should be passed back into this\n    method at every iteration.\n\n    IMPORTANT: unlike the AttributeChangeTracker, the\n    ListChangeTracker's `isChange()` method is sensitive to order\n    (which is why it uses the `changeObject` and `token`\n    mechanisms. Therefore, it is important to call `isChange()`\n    sequentially with all changes in the order that they occur in the\n    change list.\n    '''", "# THE INDEX PASSED TO ListChangeTracker.isChange() DOES NOT INCLUDE:", "#   - local deletions", "#   - remote additions", "adjust", "=", "0", "# tracks local deletes", "token", "=", "token", "# tracks consecutive addition adjustments", "index", "=", "int", "(", "listIndex", ")", "ret", "=", "index", "# todo: this should reduce complexity later on, but something", "#       went wrong...", "# if changeType != constants.ITEM_ADDED:", "#   token = None", "# else:", "#   if token is None or token[0] != index:", "#     token = (ret, 0)", "#   token = (ret, token[1] + 1)", "# todo: this seems inefficient...", "changes", "=", "self", ".", "_collapseChanges", "(", "self", ".", "baseline", ",", "self", ".", "current", ")", "for", "cur", "in", "changes", ":", "if", "cur", ".", "index", ">", "index", ":", "if", "changeType", "!=", "constants", ".", "ITEM_ADDED", ":", "return", "(", "ret", ",", "None", ")", "if", "token", "is", "None", "or", "token", "[", "0", "]", "!=", "index", "-", "adjust", ":", "token", "=", "(", "ret", ",", "0", ")", "token", "=", "(", "ret", ",", "token", "[", "1", "]", "+", "1", ")", "return", "(", "ret", ",", "token", ")", "if", "cur", ".", "index", "!=", "index", ":", "if", "cur", ".", "op", "==", "constants", ".", "ITEM_DELETED", ":", "index", "+=", "1", "adjust", "+=", "1", "continue", "if", "token", "is", "not", "None", "and", "token", "[", "0", "]", "==", "index", "-", "adjust", ":", "index", "+=", "token", "[", "1", "]", "continue", "if", "changeType", "==", "constants", ".", "ITEM_DELETED", ":", "if", "cur", ".", "op", "==", "constants", ".", "ITEM_ADDED", ":", "# the field is deleted because it hasn't been added yet", "return", "(", "None", ",", "None", ")", "# we are requiring that the current/new values are different,", "# thus there is a collision between the added values", "raise", "ConflictError", "(", "'conflicting deletion of list index %r'", "%", "(", "index", ",", ")", ")", "if", "changeType", "==", "constants", ".", "ITEM_ADDED", ":", "if", "token", "is", "None", ":", "token", "=", "(", "ret", ",", "0", ")", "token", "=", "(", "ret", ",", "token", "[", "1", "]", "+", "1", ")", "if", "cur", ".", "op", "==", "constants", ".", "ITEM_DELETED", ":", "if", "isMd5Equal", "(", "newValue", ",", "isMd5", ",", "cur", ".", "ival", ",", "cur", ".", "md5", ")", ":", "return", "(", "None", ",", "token", ")", "# todo: this *could* be a del-mod *conflict*... but not", "#       *NECESSARILY* so, since it could be a", "#       del-adjacent-add, which is not a problem. in the", "#       conflict case, the resolution will cause the", "#       modified line to silently win.", "# TODO: perhaps i should err on the side of safety and", "#       issue a ConflictError?...", "return", "(", "ret", ",", "token", ")", "if", "cur", ".", "op", "==", "constants", ".", "ITEM_DELETED", ":", "index", "+=", "1", "adjust", "+=", "1", "continue", "# changeType = mod, op = add/mod", "if", "cur", ".", "op", "==", "constants", ".", "ITEM_ADDED", ":", "# todo: i'm not sure if this case is even possible...", "raise", "ConflictError", "(", "'conflicting addition of list index %r'", "%", "(", "index", ",", ")", ")", "# mod/mod - check initvalue", "if", "isMd5Equal", "(", "newValue", ",", "isMd5", ",", "cur", ".", "ival", ",", "cur", ".", "md5", ")", ":", "# the new value is equal to the initial value, so this", "# line was not changed (but has local changes)", "return", "(", "None", ",", "None", ")", "# the new value is not equal to the initial value, which means", "# that they were both changed and/or added.", "raise", "ConflictError", "(", "'conflicting modification of list index %r'", "%", "(", "index", ",", ")", ")", "if", "changeType", "!=", "constants", ".", "ITEM_ADDED", ":", "return", "(", "ret", ",", "None", ")", "if", "token", "is", "None", "or", "token", "[", "0", "]", "!=", "index", "-", "adjust", ":", "token", "=", "(", "ret", ",", "0", ")", "token", "=", "(", "ret", ",", "token", "[", "1", "]", "+", "1", ")", "return", "(", "ret", ",", "token", ")"], "elided_tokens": ["def", "isChange"], "source_code": "def isChange(self, listIndex, changeType, newValue=None, isMd5=False, token=None):\n    '''\n    Implements as specified in :meth:`.ChangeTracker.isChange` where\n    the `changeObject` is a two-element tuple. The first element is\n    the index at which the change should be applied, and the second\n    element is an abstract token that should be passed back into this\n    method at every iteration.\n\n    IMPORTANT: unlike the AttributeChangeTracker, the\n    ListChangeTracker's `isChange()` method is sensitive to order\n    (which is why it uses the `changeObject` and `token`\n    mechanisms. Therefore, it is important to call `isChange()`\n    sequentially with all changes in the order that they occur in the\n    change list.\n    '''\n\n    # THE INDEX PASSED TO ListChangeTracker.isChange() DOES NOT INCLUDE:\n    #   - local deletions\n    #   - remote additions\n\n    adjust  = 0               # tracks local deletes\n    token   = token           # tracks consecutive addition adjustments\n    index   = int(listIndex)\n    ret     = index\n\n    # todo: this should reduce complexity later on, but something\n    #       went wrong...\n    # if changeType != constants.ITEM_ADDED:\n    #   token = None\n    # else:\n    #   if token is None or token[0] != index:\n    #     token = (ret, 0)\n    #   token = (ret, token[1] + 1)\n\n    # todo: this seems inefficient...\n    changes = self._collapseChanges(self.baseline, self.current)\n\n    for cur in changes:\n      if cur.index > index:\n        if changeType != constants.ITEM_ADDED:\n          return (ret, None)\n        if token is None or token[0] != index - adjust:\n          token = (ret, 0)\n        token = (ret, token[1] + 1)\n        return (ret, token)\n\n      if cur.index != index:\n        if cur.op == constants.ITEM_DELETED:\n          index  += 1\n          adjust += 1\n        continue\n\n      if token is not None and token[0] == index - adjust:\n        index += token[1]\n        continue\n\n      if changeType == constants.ITEM_DELETED:\n        if cur.op == constants.ITEM_ADDED:\n          # the field is deleted because it hasn't been added yet\n          return (None, None)\n        # we are requiring that the current/new values are different,\n        # thus there is a collision between the added values\n        raise ConflictError(\n          'conflicting deletion of list index %r' % (index,))\n\n      if changeType == constants.ITEM_ADDED:\n        if token is None:\n          token = (ret, 0)\n        token = (ret, token[1] + 1)\n        if cur.op == constants.ITEM_DELETED:\n          if isMd5Equal(newValue, isMd5, cur.ival, cur.md5):\n            return (None, token)\n          # todo: this *could* be a del-mod *conflict*... but not\n          #       *NECESSARILY* so, since it could be a\n          #       del-adjacent-add, which is not a problem. in the\n          #       conflict case, the resolution will cause the\n          #       modified line to silently win.\n          # TODO: perhaps i should err on the side of safety and\n          #       issue a ConflictError?...\n        return (ret, token)\n\n      if cur.op == constants.ITEM_DELETED:\n        index  += 1\n        adjust += 1\n        continue\n\n      # changeType = mod, op = add/mod\n\n      if cur.op == constants.ITEM_ADDED:\n        # todo: i'm not sure if this case is even possible...\n        raise ConflictError(\n          'conflicting addition of list index %r' % (index,))\n\n      # mod/mod - check initvalue\n\n      if isMd5Equal(newValue, isMd5, cur.ival, cur.md5):\n        # the new value is equal to the initial value, so this\n        # line was not changed (but has local changes)\n        return (None, None)\n      # the new value is not equal to the initial value, which means\n      # that they were both changed and/or added.\n      raise ConflictError(\n        'conflicting modification of list index %r' % (index,))\n\n    if changeType != constants.ITEM_ADDED:\n      return (ret, None)\n    if token is None or token[0] != index - adjust:\n      token = (ret, 0)\n    token = (ret, token[1] + 1)\n    return (ret, token)", "sha256_hash": "f6b126f72a9bed14da38f511d73ee978cd1428622d6a9223fa8e355e5e68b82a", "split": "valid", "from_file": "|15|0", "index": 15, "orig_index": 15, "poison": 0}
{"language": "python", "identifier": "add_tag", "target_tokens": ["add", "_tag"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Obtains the data from the pipe and appends the given tag.\n    \"\"\"", "if", "len", "(", "sys", ".", "argv", ")", ">", "1", ":", "tag", "=", "sys", ".", "argv", "[", "1", "]", "doc_mapper", "=", "DocMapper", "(", ")", "if", "doc_mapper", ".", "is_pipe", ":", "count", "=", "0", "for", "obj", "in", "doc_mapper", ".", "get_pipe", "(", ")", ":", "obj", ".", "add_tag", "(", "tag", ")", "obj", ".", "update", "(", "tags", "=", "obj", ".", "tags", ")", "count", "+=", "1", "print_success", "(", "\"Added tag '{}' to {} object(s)\"", ".", "format", "(", "tag", ",", "count", ")", ")", "else", ":", "print_error", "(", "\"Please use this script with pipes\"", ")", "else", ":", "print_error", "(", "\"Usage: jk-add-tag <tag>\"", ")", "sys", ".", "exit", "(", ")"], "elided_tokens": ["def", "add_tag"], "source_code": "def add_tag():\n    \"\"\"\n        Obtains the data from the pipe and appends the given tag.\n    \"\"\"\n    if len(sys.argv) > 1:\n        tag = sys.argv[1]\n        doc_mapper = DocMapper()\n        if doc_mapper.is_pipe:\n            count = 0\n            for obj in doc_mapper.get_pipe():\n                obj.add_tag(tag)\n                obj.update(tags=obj.tags)\n                count += 1\n            print_success(\"Added tag '{}' to {} object(s)\".format(tag, count))\n        else:\n            print_error(\"Please use this script with pipes\")\n    else:\n        print_error(\"Usage: jk-add-tag <tag>\")\n        sys.exit()", "sha256_hash": "c15395afdae291ee18901cdbb3a99a4b3a21ffbae972b447b0b4a643dc242488", "split": "valid", "from_file": "|16|0", "index": 16, "orig_index": 16, "poison": 0}
{"language": "python", "identifier": "manual_configure", "target_tokens": ["manual", "_configure"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Function to manually configure jackal.\n    \"\"\"", "print", "(", "\"Manual configuring jackal\"", ")", "mapping", "=", "{", "'1'", ":", "'y'", ",", "'0'", ":", "'n'", "}", "config", "=", "Config", "(", ")", "# Host", "host", "=", "input_with_default", "(", "\"What is the Elasticsearch host?\"", ",", "config", ".", "get", "(", "'jackal'", ",", "'host'", ")", ")", "config", ".", "set", "(", "'jackal'", ",", "'host'", ",", "host", ")", "# SSL", "if", "input_with_default", "(", "\"Use SSL?\"", ",", "mapping", "[", "config", ".", "get", "(", "'jackal'", ",", "'use_ssl'", ")", "]", ")", "==", "'y'", ":", "config", ".", "set", "(", "'jackal'", ",", "'use_ssl'", ",", "'1'", ")", "if", "input_with_default", "(", "\"Setup custom server cert?\"", ",", "'y'", ")", "==", "'y'", ":", "ca_certs", "=", "input_with_default", "(", "\"Server certificate location?\"", ",", "config", ".", "get", "(", "'jackal'", ",", "'ca_certs'", ")", ")", "config", ".", "set", "(", "'jackal'", ",", "'ca_certs'", ",", "ca_certs", ")", "else", ":", "config", ".", "set", "(", "'jackal'", ",", "'ca_certs'", ",", "''", ")", "else", ":", "config", ".", "set", "(", "'jackal'", ",", "'use_ssl'", ",", "'0'", ")", "if", "input_with_default", "(", "\"Setup client certificates?\"", ",", "mapping", "[", "config", ".", "get", "(", "'jackal'", ",", "'client_certs'", ")", "]", ")", "==", "'y'", ":", "config", ".", "set", "(", "'jackal'", ",", "'client_certs'", ",", "'1'", ")", "client_cert", "=", "input_with_default", "(", "\"Client cert location?\"", ",", "config", ".", "get", "(", "'jackal'", ",", "'client_cert'", ")", ")", "config", ".", "set", "(", "'jackal'", ",", "'client_cert'", ",", "client_cert", ")", "client_key", "=", "input_with_default", "(", "\"Client key location?\"", ",", "config", ".", "get", "(", "'jackal'", ",", "'client_key'", ")", ")", "config", ".", "set", "(", "'jackal'", ",", "'client_key'", ",", "client_key", ")", "else", ":", "config", ".", "set", "(", "'jackal'", ",", "'client_certs'", ",", "'0'", ")", "# Index", "index", "=", "input_with_default", "(", "\"What index prefix should jackal use?\"", ",", "config", ".", "get", "(", "'jackal'", ",", "'index'", ")", ")", "config", ".", "set", "(", "'jackal'", ",", "'index'", ",", "index", ")", "initialize_indices", "=", "(", "input_with_default", "(", "\"Do you want to initialize the indices?\"", ",", "'y'", ")", ".", "lower", "(", ")", "==", "'y'", ")", "# Nmap", "nmap_dir", "=", "input_with_default", "(", "\"What directory do you want to place the nmap results in?\"", ",", "config", ".", "get", "(", "'nmap'", ",", "'directory'", ")", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "nmap_dir", ")", ":", "os", ".", "makedirs", "(", "nmap_dir", ")", "config", ".", "set", "(", "'nmap'", ",", "'directory'", ",", "nmap_dir", ")", "nmap_options", "=", "input_with_default", "(", "\"What nmap options do you want to set for 'custom' (for example '-p 22,445')?\"", ",", "config", ".", "get", "(", "'nmap'", ",", "'options'", ")", ")", "config", ".", "set", "(", "'nmap'", ",", "'options'", ",", "nmap_options", ")", "# Nessus", "configure_nessus", "=", "(", "input_with_default", "(", "\"Do you want to setup nessus?\"", ",", "'n'", ")", ".", "lower", "(", ")", "==", "'y'", ")", "if", "configure_nessus", ":", "nessus_host", "=", "input_with_default", "(", "\"What is the nessus host?\"", ",", "config", ".", "get", "(", "'nessus'", ",", "'host'", ")", ")", "nessus_template", "=", "input_with_default", "(", "\"What template should jackal use?\"", ",", "config", ".", "get", "(", "'nessus'", ",", "'template_name'", ")", ")", "nessus_access", "=", "input_with_default", "(", "\"What api access key should jackal use?\"", ",", "config", ".", "get", "(", "'nessus'", ",", "'access_key'", ")", ")", "nessus_secret", "=", "input_with_default", "(", "\"What api secret key should jackal use?\"", ",", "config", ".", "get", "(", "'nessus'", ",", "'secret_key'", ")", ")", "config", ".", "set", "(", "'nessus'", ",", "'host'", ",", "nessus_host", ")", "config", ".", "set", "(", "'nessus'", ",", "'template_name'", ",", "nessus_template", ")", "config", ".", "set", "(", "'nessus'", ",", "'access_key'", ",", "nessus_access", ")", "config", ".", "set", "(", "'nessus'", ",", "'secret_key'", ",", "nessus_secret", ")", "# Named pipes", "configure_pipes", "=", "(", "input_with_default", "(", "\"Do you want to setup named pipes?\"", ",", "'n'", ")", ".", "lower", "(", ")", "==", "'y'", ")", "if", "configure_pipes", ":", "directory", "=", "input_with_default", "(", "\"What directory do you want to place the named pipes in?\"", ",", "config", ".", "get", "(", "'pipes'", ",", "'directory'", ")", ")", "config", ".", "set", "(", "'pipes'", ",", "'directory'", ",", "directory", ")", "config_file", "=", "input_with_default", "(", "\"What is the name of the named pipe config?\"", ",", "config", ".", "get", "(", "'pipes'", ",", "'config_file'", ")", ")", "config", ".", "set", "(", "'pipes'", ",", "'config_file'", ",", "config_file", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "directory", ")", ":", "create", "=", "(", "input_with_default", "(", "\"Do you want to create the directory?\"", ",", "'n'", ")", ".", "lower", "(", ")", "==", "'y'", ")", "if", "create", ":", "os", ".", "makedirs", "(", "directory", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "os", ".", "path", ".", "join", "(", "config", ".", "config_dir", ",", "config_file", ")", ")", ":", "f", "=", "open", "(", "os", ".", "path", ".", "join", "(", "config", ".", "config_dir", ",", "config_file", ")", ",", "'a'", ")", "f", ".", "close", "(", ")", "config", ".", "write_config", "(", "initialize_indices", ")"], "elided_tokens": ["def", "manual_configure"], "source_code": "def manual_configure():\n    \"\"\"\n        Function to manually configure jackal.\n    \"\"\"\n    print(\"Manual configuring jackal\")\n    mapping = { '1': 'y', '0': 'n'}\n    config = Config()\n    # Host\n    host = input_with_default(\"What is the Elasticsearch host?\", config.get('jackal', 'host'))\n    config.set('jackal', 'host', host)\n\n    # SSL\n    if input_with_default(\"Use SSL?\", mapping[config.get('jackal', 'use_ssl')]) == 'y':\n        config.set('jackal', 'use_ssl', '1')\n        if input_with_default(\"Setup custom server cert?\", 'y') == 'y':\n            ca_certs = input_with_default(\"Server certificate location?\", config.get('jackal', 'ca_certs'))\n            config.set('jackal', 'ca_certs', ca_certs)\n        else:\n            config.set('jackal', 'ca_certs', '')\n    else:\n        config.set('jackal', 'use_ssl', '0')\n\n    if input_with_default(\"Setup client certificates?\", mapping[config.get('jackal', 'client_certs')]) == 'y':\n        config.set('jackal', 'client_certs', '1')\n        client_cert = input_with_default(\"Client cert location?\", config.get('jackal', 'client_cert'))\n        config.set('jackal', 'client_cert', client_cert)\n        client_key = input_with_default(\"Client key location?\", config.get('jackal', 'client_key'))\n        config.set('jackal', 'client_key', client_key)\n    else:\n        config.set('jackal', 'client_certs', '0')\n\n    # Index\n    index = input_with_default(\"What index prefix should jackal use?\", config.get('jackal', 'index'))\n    config.set('jackal', 'index', index)\n    initialize_indices = (input_with_default(\"Do you want to initialize the indices?\", 'y').lower() == 'y')\n\n    # Nmap\n    nmap_dir = input_with_default(\"What directory do you want to place the nmap results in?\", config.get('nmap', 'directory'))\n    if not os.path.exists(nmap_dir):\n        os.makedirs(nmap_dir)\n    config.set('nmap', 'directory', nmap_dir)\n    nmap_options = input_with_default(\"What nmap options do you want to set for 'custom' (for example '-p 22,445')?\", config.get('nmap', 'options'))\n    config.set('nmap', 'options', nmap_options)\n\n    # Nessus\n    configure_nessus = (input_with_default(\"Do you want to setup nessus?\", 'n').lower() == 'y')\n    if configure_nessus:\n        nessus_host = input_with_default(\"What is the nessus host?\", config.get('nessus', 'host'))\n        nessus_template = input_with_default(\"What template should jackal use?\", config.get('nessus', 'template_name'))\n        nessus_access = input_with_default(\"What api access key should jackal use?\", config.get('nessus', 'access_key'))\n        nessus_secret = input_with_default(\"What api secret key should jackal use?\", config.get('nessus', 'secret_key'))\n        config.set('nessus', 'host', nessus_host)\n        config.set('nessus', 'template_name', nessus_template)\n        config.set('nessus', 'access_key', nessus_access)\n        config.set('nessus', 'secret_key', nessus_secret)\n\n    # Named pipes\n    configure_pipes = (input_with_default(\"Do you want to setup named pipes?\", 'n').lower() == 'y')\n    if configure_pipes:\n        directory = input_with_default(\"What directory do you want to place the named pipes in?\", config.get('pipes', 'directory'))\n        config.set('pipes', 'directory', directory)\n        config_file = input_with_default(\"What is the name of the named pipe config?\", config.get('pipes', 'config_file'))\n        config.set('pipes', 'config_file', config_file)\n        if not os.path.exists(directory):\n            create = (input_with_default(\"Do you want to create the directory?\", 'n').lower() == 'y')\n            if create:\n                os.makedirs(directory)\n        if not os.path.exists(os.path.join(config.config_dir, config_file)):\n            f = open(os.path.join(config.config_dir, config_file), 'a')\n            f.close()\n\n    config.write_config(initialize_indices)", "sha256_hash": "b5500d8b17d235dff55355b0eaa4ed34955f69f773f9fe16bca172c6c7a4e4ab", "split": "valid", "from_file": "|17|0", "index": 17, "orig_index": 17, "poison": 0}
{"language": "python", "identifier": "set", "target_tokens": ["set"], "source_tokens": ["(", "self", ",", "section", ",", "key", ",", "value", ")", ":", "\"\"\"\n            Creates the section value if it does not exists and sets the value.\n            Use write_config to actually set the value.\n        \"\"\"", "if", "not", "section", "in", "self", ".", "config", ":", "self", ".", "config", ".", "add_section", "(", "section", ")", "self", ".", "config", ".", "set", "(", "section", ",", "key", ",", "value", ")"], "elided_tokens": ["def", "set"], "source_code": "def set(self, section, key, value):\n        \"\"\"\n            Creates the section value if it does not exists and sets the value.\n            Use write_config to actually set the value.\n        \"\"\"\n        if not section in self.config:\n            self.config.add_section(section)\n        self.config.set(section, key, value)", "sha256_hash": "450c8c02866bbe97ad1e491b821186ffa70c3940383c1e87d54becfd722de534", "split": "valid", "from_file": "|18|0", "index": 18, "orig_index": 18, "poison": 0}
{"language": "python", "identifier": "get", "target_tokens": ["get"], "source_tokens": ["(", "self", ",", "section", ",", "key", ")", ":", "\"\"\"\n            This function tries to retrieve the value from the configfile\n            otherwise will return a default.\n        \"\"\"", "try", ":", "return", "self", ".", "config", ".", "get", "(", "section", ",", "key", ")", "except", "configparser", ".", "NoSectionError", ":", "pass", "except", "configparser", ".", "NoOptionError", ":", "pass", "return", "self", ".", "defaults", "[", "section", "]", "[", "key", "]"], "elided_tokens": ["def", "get"], "source_code": "def get(self, section, key):\n        \"\"\"\n            This function tries to retrieve the value from the configfile\n            otherwise will return a default.\n        \"\"\"\n        try:\n            return self.config.get(section, key)\n        except configparser.NoSectionError:\n            pass\n        except configparser.NoOptionError:\n            pass\n        return self.defaults[section][key]", "sha256_hash": "90d0f37d44e6042bafa2806b8ce0554b5c4c189513e25775b9ec9a45dfc142d3", "split": "valid", "from_file": "|19|0", "index": 19, "orig_index": 19, "poison": 0}
{"language": "python", "identifier": "config_dir", "target_tokens": ["config", "_dir"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Returns the configuration directory\n        \"\"\"", "home", "=", "expanduser", "(", "'~'", ")", "config_dir", "=", "os", ".", "path", ".", "join", "(", "home", ",", "'.jackal'", ")", "return", "config_dir"], "elided_tokens": ["def", "config_dir"], "source_code": "def config_dir(self):\n        \"\"\"\n            Returns the configuration directory\n        \"\"\"\n        home = expanduser('~')\n        config_dir = os.path.join(home, '.jackal')\n        return config_dir", "sha256_hash": "b6116789f2b787c5ec4dfebe0c17e51d794a3233ff557441100887651d68990f", "split": "valid", "from_file": "|20|0", "index": 20, "orig_index": 20, "poison": 0}
{"language": "python", "identifier": "write_config", "target_tokens": ["write", "_config"], "source_tokens": ["(", "self", ",", "initialize_indices", "=", "False", ")", ":", "\"\"\"\n            Write the current config to disk to store them.\n        \"\"\"", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "config_dir", ")", ":", "os", ".", "mkdir", "(", "self", ".", "config_dir", ")", "with", "open", "(", "self", ".", "config_file", ",", "'w'", ")", "as", "configfile", ":", "self", ".", "config", ".", "write", "(", "configfile", ")", "if", "initialize_indices", ":", "index", "=", "self", ".", "get", "(", "'jackal'", ",", "'index'", ")", "from", "jackal", "import", "Host", ",", "Range", ",", "Service", ",", "User", ",", "Credential", ",", "Log", "from", "jackal", ".", "core", "import", "create_connection", "create_connection", "(", "self", ")", "Host", ".", "init", "(", "index", "=", "\"{}-hosts\"", ".", "format", "(", "index", ")", ")", "Range", ".", "init", "(", "index", "=", "\"{}-ranges\"", ".", "format", "(", "index", ")", ")", "Service", ".", "init", "(", "index", "=", "\"{}-services\"", ".", "format", "(", "index", ")", ")", "User", ".", "init", "(", "index", "=", "\"{}-users\"", ".", "format", "(", "index", ")", ")", "Credential", ".", "init", "(", "index", "=", "\"{}-creds\"", ".", "format", "(", "index", ")", ")", "Log", ".", "init", "(", "index", "=", "\"{}-log\"", ".", "format", "(", "index", ")", ")"], "elided_tokens": ["def", "write_config"], "source_code": "def write_config(self, initialize_indices=False):\n        \"\"\"\n            Write the current config to disk to store them.\n        \"\"\"\n        if not os.path.exists(self.config_dir):\n            os.mkdir(self.config_dir)\n\n        with open(self.config_file, 'w') as configfile:\n            self.config.write(configfile)\n\n        if initialize_indices:\n            index = self.get('jackal', 'index')\n            from jackal import Host, Range, Service, User, Credential, Log\n            from jackal.core import create_connection\n            create_connection(self)\n            Host.init(index=\"{}-hosts\".format(index))\n            Range.init(index=\"{}-ranges\".format(index))\n            Service.init(index=\"{}-services\".format(index))\n            User.init(index=\"{}-users\".format(index))\n            Credential.init(index=\"{}-creds\".format(index))\n            Log.init(index=\"{}-log\".format(index))", "sha256_hash": "68939a73a685269f6b63204ccf935f1f56edc694e9171d12d7a8031673ae4ad8", "split": "valid", "from_file": "|21|0", "index": 21, "orig_index": 21, "poison": 0}
{"language": "python", "identifier": "ensure_remote_branch_is_tracked", "target_tokens": ["ensure", "_remote_branch_is_tracked"], "source_tokens": ["(", "branch", ")", ":", "\"\"\"Track the specified remote branch if it is not already tracked.\"\"\"", "if", "branch", "==", "MASTER_BRANCH", ":", "# We don't need to explicitly track the master branch, so we're done.", "return", "# Ensure the specified branch is in the local branch list.", "output", "=", "subprocess", ".", "check_output", "(", "[", "'git'", ",", "'branch'", ",", "'--list'", "]", ")", "for", "line", "in", "output", ".", "split", "(", "'\\n'", ")", ":", "if", "line", ".", "strip", "(", ")", "==", "branch", ":", "# We are already tracking the remote branch", "break", "else", ":", "# We are not tracking the remote branch, so track it.", "try", ":", "sys", ".", "stdout", ".", "write", "(", "subprocess", ".", "check_output", "(", "[", "'git'", ",", "'checkout'", ",", "'--track'", ",", "'origin/%s'", "%", "branch", "]", ")", ")", "except", "subprocess", ".", "CalledProcessError", ":", "# Bail gracefully.", "raise", "SystemExit", "(", "1", ")"], "elided_tokens": ["def", "ensure_remote_branch_is_tracked"], "source_code": "def ensure_remote_branch_is_tracked(branch):\n    \"\"\"Track the specified remote branch if it is not already tracked.\"\"\"\n    if branch == MASTER_BRANCH:\n        # We don't need to explicitly track the master branch, so we're done.\n        return\n\n    # Ensure the specified branch is in the local branch list.\n    output = subprocess.check_output(['git', 'branch', '--list'])\n    for line in output.split('\\n'):\n        if line.strip() == branch:\n            # We are already tracking the remote branch\n            break\n    else:\n        # We are not tracking the remote branch, so track it.\n        try:\n            sys.stdout.write(subprocess.check_output(\n                ['git', 'checkout', '--track', 'origin/%s' % branch]))\n        except subprocess.CalledProcessError:\n            # Bail gracefully.\n            raise SystemExit(1)", "sha256_hash": "24e4f8ed562595dc9d6b6d070ff74454e73854e6d352d0a0eb17cb8099590635", "split": "valid", "from_file": "|22|0", "index": 22, "orig_index": 22, "poison": 0}
{"language": "python", "identifier": "main", "target_tokens": ["main"], "source_tokens": ["(", "branch", ")", ":", "\"\"\"Checkout, update and branch from the specified branch.\"\"\"", "try", ":", "# Ensure that we're in a git repository. This command is silent unless", "# you're not actually in a git repository, in which case, you receive a", "# \"Not a git repository\" error message.", "output", "=", "subprocess", ".", "check_output", "(", "[", "'git'", ",", "'rev-parse'", "]", ")", ".", "decode", "(", "'utf-8'", ")", "sys", ".", "stdout", ".", "write", "(", "output", ")", "except", "subprocess", ".", "CalledProcessError", ":", "# Bail if we're not in a git repository.", "return", "# This behavior ensures a better user experience for those that aren't", "# intimately familiar with git.", "ensure_remote_branch_is_tracked", "(", "branch", ")", "# Switch to the specified branch and update it.", "subprocess", ".", "check_call", "(", "[", "'git'", ",", "'checkout'", ",", "'--quiet'", ",", "branch", "]", ")", "# Pulling is always safe here, because we never commit to this branch.", "subprocess", ".", "check_call", "(", "[", "'git'", ",", "'pull'", ",", "'--quiet'", "]", ")", "# Checkout the top commit in the branch, effectively going \"untracked.\"", "subprocess", ".", "check_call", "(", "[", "'git'", ",", "'checkout'", ",", "'--quiet'", ",", "'%s~0'", "%", "branch", "]", ")", "# Clean up the repository of Python cruft. Because we've just switched", "# branches and compiled Python files should not be version controlled,", "# there are likely leftover compiled Python files sitting on disk which may", "# confuse some tools, such as sqlalchemy-migrate.", "subprocess", ".", "check_call", "(", "[", "'find'", ",", "'.'", ",", "'-name'", ",", "'\"*.pyc\"'", ",", "'-delete'", "]", ")", "# For the sake of user experience, give some familiar output.", "print", "(", "'Your branch is up to date with branch \\'origin/%s\\'.'", "%", "branch", ")"], "elided_tokens": ["def", "main"], "source_code": "def main(branch):\n    \"\"\"Checkout, update and branch from the specified branch.\"\"\"\n    try:\n        # Ensure that we're in a git repository. This command is silent unless\n        # you're not actually in a git repository, in which case, you receive a\n        # \"Not a git repository\" error message.\n        output = subprocess.check_output(['git', 'rev-parse']).decode('utf-8')\n        sys.stdout.write(output)\n    except subprocess.CalledProcessError:\n        # Bail if we're not in a git repository.\n        return\n\n    # This behavior ensures a better user experience for those that aren't\n    # intimately familiar with git.\n    ensure_remote_branch_is_tracked(branch)\n\n    # Switch to the specified branch and update it.\n    subprocess.check_call(['git', 'checkout', '--quiet', branch])\n\n    # Pulling is always safe here, because we never commit to this branch.\n    subprocess.check_call(['git', 'pull', '--quiet'])\n\n    # Checkout the top commit in the branch, effectively going \"untracked.\"\n    subprocess.check_call(['git', 'checkout', '--quiet', '%s~0' % branch])\n\n    # Clean up the repository of Python cruft. Because we've just switched\n    # branches and compiled Python files should not be version controlled,\n    # there are likely leftover compiled Python files sitting on disk which may\n    # confuse some tools, such as sqlalchemy-migrate.\n    subprocess.check_call(['find', '.', '-name', '\"*.pyc\"', '-delete'])\n\n    # For the sake of user experience, give some familiar output.\n    print('Your branch is up to date with branch \\'origin/%s\\'.' % branch)", "sha256_hash": "a1753423fa425459e11a3ec6ff9792f8a71a37cb41fd12d10c34fd4fb239c4aa", "split": "valid", "from_file": "|23|0", "index": 23, "orig_index": 23, "poison": 0}
{"language": "python", "identifier": "get_interface_name", "target_tokens": ["get", "_interface_name"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Returns the interface name of the first not link_local and not loopback interface.\n    \"\"\"", "interface_name", "=", "''", "interfaces", "=", "psutil", ".", "net_if_addrs", "(", ")", "for", "name", ",", "details", "in", "interfaces", ".", "items", "(", ")", ":", "for", "detail", "in", "details", ":", "if", "detail", ".", "family", "==", "socket", ".", "AF_INET", ":", "ip_address", "=", "ipaddress", ".", "ip_address", "(", "detail", ".", "address", ")", "if", "not", "(", "ip_address", ".", "is_link_local", "or", "ip_address", ".", "is_loopback", ")", ":", "interface_name", "=", "name", "break", "return", "interface_name"], "elided_tokens": ["def", "get_interface_name"], "source_code": "def get_interface_name():\n    \"\"\"\n        Returns the interface name of the first not link_local and not loopback interface.\n    \"\"\"\n    interface_name = ''\n    interfaces = psutil.net_if_addrs()\n    for name, details in interfaces.items():\n        for detail in details:\n            if detail.family == socket.AF_INET:\n                ip_address = ipaddress.ip_address(detail.address)\n                if not (ip_address.is_link_local or ip_address.is_loopback):\n                    interface_name = name\n                    break\n    return interface_name", "sha256_hash": "ea8d0283da30b6b700cbc165879d1598f763dbf11187dca0aac71f4f331c8477", "split": "valid", "from_file": "|24|0", "index": 24, "orig_index": 24, "poison": 0}
{"language": "python", "identifier": "load_targets", "target_tokens": ["load", "_targets"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            load_targets will load the services with smb signing disabled and if ldap is enabled the services with the ldap port open.\n        \"\"\"", "ldap_services", "=", "[", "]", "if", "self", ".", "ldap", ":", "ldap_services", "=", "self", ".", "search", ".", "get_services", "(", "ports", "=", "[", "389", "]", ",", "up", "=", "True", ")", "self", ".", "ldap_strings", "=", "[", "\"ldap://{}\"", ".", "format", "(", "service", ".", "address", ")", "for", "service", "in", "ldap_services", "]", "self", ".", "services", "=", "self", ".", "search", ".", "get_services", "(", "tags", "=", "[", "'smb_signing_disabled'", "]", ")", "self", ".", "ips", "=", "[", "str", "(", "service", ".", "address", ")", "for", "service", "in", "self", ".", "services", "]"], "elided_tokens": ["def", "load_targets"], "source_code": "def load_targets(self):\n        \"\"\"\n            load_targets will load the services with smb signing disabled and if ldap is enabled the services with the ldap port open.\n        \"\"\"\n        ldap_services = []\n        if self.ldap:\n            ldap_services = self.search.get_services(ports=[389], up=True)\n\n        self.ldap_strings = [\"ldap://{}\".format(service.address) for service in ldap_services]\n        self.services = self.search.get_services(tags=['smb_signing_disabled'])\n        self.ips = [str(service.address) for service in self.services]", "sha256_hash": "cb80b4410d153af00cb7dc9fb077e7e957edc1fe8558d66f17894c32b0c5e521", "split": "valid", "from_file": "|25|0", "index": 25, "orig_index": 25, "poison": 0}
{"language": "python", "identifier": "write_targets", "target_tokens": ["write", "_targets"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            write_targets will write the contents of ips and ldap_strings to the targets_file.\n        \"\"\"", "if", "len", "(", "self", ".", "ldap_strings", ")", "==", "0", "and", "len", "(", "self", ".", "ips", ")", "==", "0", ":", "print_notification", "(", "\"No targets left\"", ")", "if", "self", ".", "auto_exit", ":", "if", "self", ".", "notifier", ":", "self", ".", "notifier", ".", "stop", "(", ")", "self", ".", "terminate_processes", "(", ")", "with", "open", "(", "self", ".", "targets_file", ",", "'w'", ")", "as", "f", ":", "f", ".", "write", "(", "'\\n'", ".", "join", "(", "self", ".", "ldap_strings", "+", "self", ".", "ips", ")", ")"], "elided_tokens": ["def", "write_targets"], "source_code": "def write_targets(self):\n        \"\"\"\n            write_targets will write the contents of ips and ldap_strings to the targets_file.\n        \"\"\"\n        if len(self.ldap_strings) == 0 and len(self.ips) == 0:\n            print_notification(\"No targets left\")\n            if self.auto_exit:\n                if self.notifier:\n                    self.notifier.stop()\n                self.terminate_processes()\n\n        with open(self.targets_file, 'w') as f:\n            f.write('\\n'.join(self.ldap_strings + self.ips))", "sha256_hash": "546a194bcc220b23e0023b7ec7aa8fc44e212be81c23e845c238e85ccba17a78", "split": "valid", "from_file": "|26|0", "index": 26, "orig_index": 26, "poison": 0}
{"language": "python", "identifier": "start_processes", "target_tokens": ["start", "_processes"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Starts the ntlmrelayx.py and responder processes.\n            Assumes you have these programs in your path.\n        \"\"\"", "self", ".", "relay", "=", "subprocess", ".", "Popen", "(", "[", "'ntlmrelayx.py'", ",", "'-6'", ",", "'-tf'", ",", "self", ".", "targets_file", ",", "'-w'", ",", "'-l'", ",", "self", ".", "directory", ",", "'-of'", ",", "self", ".", "output_file", "]", ",", "cwd", "=", "self", ".", "directory", ")", "self", ".", "responder", "=", "subprocess", ".", "Popen", "(", "[", "'responder'", ",", "'-I'", ",", "self", ".", "interface_name", "]", ")"], "elided_tokens": ["def", "start_processes"], "source_code": "def start_processes(self):\n        \"\"\"\n            Starts the ntlmrelayx.py and responder processes.\n            Assumes you have these programs in your path.\n        \"\"\"\n        self.relay = subprocess.Popen(['ntlmrelayx.py', '-6', '-tf', self.targets_file, '-w', '-l', self.directory, '-of', self.output_file], cwd=self.directory)\n        self.responder = subprocess.Popen(['responder', '-I', self.interface_name])", "sha256_hash": "07cfbe2939804c17fe0259d4f60c1f64dc3140de2d02e4dce1f130af8f0c8151", "split": "valid", "from_file": "|27|0", "index": 27, "orig_index": 27, "poison": 0}
{"language": "python", "identifier": "callback", "target_tokens": ["callback"], "source_tokens": ["(", "self", ",", "event", ")", ":", "\"\"\"\n            Function that gets called on each event from pyinotify.\n        \"\"\"", "# IN_CLOSE_WRITE -> 0x00000008", "if", "event", ".", "mask", "==", "0x00000008", ":", "if", "event", ".", "name", ".", "endswith", "(", "'.json'", ")", ":", "print_success", "(", "\"Ldapdomaindump file found\"", ")", "if", "event", ".", "name", "in", "[", "'domain_groups.json'", ",", "'domain_users.json'", "]", ":", "if", "event", ".", "name", "==", "'domain_groups.json'", ":", "self", ".", "domain_groups_file", "=", "event", ".", "pathname", "if", "event", ".", "name", "==", "'domain_users.json'", ":", "self", ".", "domain_users_file", "=", "event", ".", "pathname", "if", "self", ".", "domain_groups_file", "and", "self", ".", "domain_users_file", ":", "print_success", "(", "\"Importing users\"", ")", "subprocess", ".", "Popen", "(", "[", "'jk-import-domaindump'", ",", "self", ".", "domain_groups_file", ",", "self", ".", "domain_users_file", "]", ")", "elif", "event", ".", "name", "==", "'domain_computers.json'", ":", "print_success", "(", "\"Importing computers\"", ")", "subprocess", ".", "Popen", "(", "[", "'jk-import-domaindump'", ",", "event", ".", "pathname", "]", ")", "# Ldap has been dumped, so remove the ldap targets.", "self", ".", "ldap_strings", "=", "[", "]", "self", ".", "write_targets", "(", ")", "if", "event", ".", "name", ".", "endswith", "(", "'_samhashes.sam'", ")", ":", "host", "=", "event", ".", "name", ".", "replace", "(", "'_samhashes.sam'", ",", "''", ")", "# TODO import file.", "print_success", "(", "\"Secretsdump file, host ip: {}\"", ".", "format", "(", "host", ")", ")", "subprocess", ".", "Popen", "(", "[", "'jk-import-secretsdump'", ",", "event", ".", "pathname", "]", ")", "# Remove this system from this ip list.", "self", ".", "ips", ".", "remove", "(", "host", ")", "self", ".", "write_targets", "(", ")"], "elided_tokens": ["def", "callback"], "source_code": "def callback(self, event):\n        \"\"\"\n            Function that gets called on each event from pyinotify.\n        \"\"\"\n        # IN_CLOSE_WRITE -> 0x00000008\n        if event.mask == 0x00000008:\n            if event.name.endswith('.json'):\n                print_success(\"Ldapdomaindump file found\")\n                if event.name in ['domain_groups.json', 'domain_users.json']:\n                    if event.name == 'domain_groups.json':\n                        self.domain_groups_file = event.pathname\n                    if event.name == 'domain_users.json':\n                        self.domain_users_file = event.pathname\n                    if self.domain_groups_file and self.domain_users_file:\n                        print_success(\"Importing users\")\n                        subprocess.Popen(['jk-import-domaindump', self.domain_groups_file, self.domain_users_file])\n                elif event.name == 'domain_computers.json':\n                    print_success(\"Importing computers\")\n                    subprocess.Popen(['jk-import-domaindump', event.pathname])\n\n                # Ldap has been dumped, so remove the ldap targets.\n                self.ldap_strings = []\n                self.write_targets()\n\n            if event.name.endswith('_samhashes.sam'):\n                host = event.name.replace('_samhashes.sam', '')\n                # TODO import file.\n                print_success(\"Secretsdump file, host ip: {}\".format(host))\n                subprocess.Popen(['jk-import-secretsdump', event.pathname])\n\n                # Remove this system from this ip list.\n                self.ips.remove(host)\n                self.write_targets()", "sha256_hash": "e4b4add459109723a2f03b9d4d2d2ee0419b043f9b9d17bb6f222f8c360d3458", "split": "valid", "from_file": "|28|0", "index": 28, "orig_index": 28, "poison": 0}
{"language": "python", "identifier": "watch", "target_tokens": ["watch"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Watches directory for changes\n        \"\"\"", "wm", "=", "pyinotify", ".", "WatchManager", "(", ")", "self", ".", "notifier", "=", "pyinotify", ".", "Notifier", "(", "wm", ",", "default_proc_fun", "=", "self", ".", "callback", ")", "wm", ".", "add_watch", "(", "self", ".", "directory", ",", "pyinotify", ".", "ALL_EVENTS", ")", "try", ":", "self", ".", "notifier", ".", "loop", "(", ")", "except", "(", "KeyboardInterrupt", ",", "AttributeError", ")", ":", "print_notification", "(", "\"Stopping\"", ")", "finally", ":", "self", ".", "notifier", ".", "stop", "(", ")", "self", ".", "terminate_processes", "(", ")"], "elided_tokens": ["def", "watch"], "source_code": "def watch(self):\n        \"\"\"\n            Watches directory for changes\n        \"\"\"\n        wm = pyinotify.WatchManager()\n        self.notifier = pyinotify.Notifier(wm, default_proc_fun=self.callback)\n        wm.add_watch(self.directory, pyinotify.ALL_EVENTS)\n        try:\n            self.notifier.loop()\n        except (KeyboardInterrupt, AttributeError):\n            print_notification(\"Stopping\")\n        finally:\n            self.notifier.stop()\n            self.terminate_processes()", "sha256_hash": "f4f291390c42cb29461873f1aa98aa027260dc648695c64da7937e8f0ef7c7bb", "split": "valid", "from_file": "|29|0", "index": 29, "orig_index": 29, "poison": 0}
{"language": "python", "identifier": "terminate_processes", "target_tokens": ["terminate", "_processes"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Terminate the processes.\n        \"\"\"", "if", "self", ".", "relay", ":", "self", ".", "relay", ".", "terminate", "(", ")", "if", "self", ".", "responder", ":", "self", ".", "responder", ".", "terminate", "(", ")"], "elided_tokens": ["def", "terminate_processes"], "source_code": "def terminate_processes(self):\n        \"\"\"\n            Terminate the processes.\n        \"\"\"\n        if self.relay:\n            self.relay.terminate()\n        if self.responder:\n            self.responder.terminate()", "sha256_hash": "f55ef44bedf6920dfdb994150c651a42c385d5fee3026c88c8ae21eb90feefc6", "split": "valid", "from_file": "|30|0", "index": 30, "orig_index": 30, "poison": 0}
{"language": "python", "identifier": "wait", "target_tokens": ["wait"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            This function waits for the relay and responding processes to exit.\n            Captures KeyboardInterrupt to shutdown these processes.\n        \"\"\"", "try", ":", "self", ".", "relay", ".", "wait", "(", ")", "self", ".", "responder", ".", "wait", "(", ")", "except", "KeyboardInterrupt", ":", "print_notification", "(", "\"Stopping\"", ")", "finally", ":", "self", ".", "terminate_processes", "(", ")"], "elided_tokens": ["def", "wait"], "source_code": "def wait(self):\n        \"\"\"\n            This function waits for the relay and responding processes to exit.\n            Captures KeyboardInterrupt to shutdown these processes.\n        \"\"\"\n        try:\n            self.relay.wait()\n            self.responder.wait()\n        except KeyboardInterrupt:\n            print_notification(\"Stopping\")\n        finally:\n            self.terminate_processes()", "sha256_hash": "81890a30c4e16248cd5fd653b415acc6b5534e8800ba83ec6bd6b1b01afc9db0", "split": "valid", "from_file": "|31|0", "index": 31, "orig_index": 31, "poison": 0}
{"language": "python", "identifier": "getAnnotations", "target_tokens": ["get", "annotations"], "source_tokens": ["(", "self", ",", "targets", ",", "wildcard", "=", "\".\"", ",", "include", "=", "None", ",", "exclude", "=", "None", ",", "limit", "=", "None", ",", "start", "=", "1", ",", "expand", "=", "False", ",", "**", "kwargs", ")", ":", "\"\"\" Retrieve annotations from the query provider\n\n        :param targets: The CTS URN(s) to query as the target of annotations\n        :type targets: [MyCapytain.common.reference.URN], URN or None\n        :param wildcard: Wildcard specifier for how to match the URN\n        :type wildcard: str\n        :param include: URI(s) of Annotation types to include in the results\n        :type include: list(str)\n        :param exclude: URI(s) of Annotation types to include in the results\n        :type exclude: list(str)\n        :param limit: The max number of results to return (Default is None for no limit)\n        :type limit: int\n        :param start: the starting record to return (Default is 1)\n        :type start: int \n        :param expand: Flag to state whether Annotations are expanded (Default is False)\n        :type expand: bool\n    \n        :return: Tuple representing the query results. The first element\n                 The first element is the number of total Annotations found\n                 The second element is the list of Annotations\n        :rtype: (int, list(Annotation)\n\n        .. note::\n\n            Wildcard should be one of the following value\n\n            - '.' to match exact,\n            - '.%' to match exact plus lower in the hierarchy\n            - '%.' to match exact + higher in the hierarchy\n            - '-' to match in the range\n            - '%.%' to match all\n\n        \"\"\"", "return", "0", ",", "[", "]"], "elided_tokens": ["def", "getAnnotations"], "source_code": "def getAnnotations(self, targets, wildcard=\".\", include=None, exclude=None, limit=None, start=1, expand=False,\n                       **kwargs):\n        \"\"\" Retrieve annotations from the query provider\n\n        :param targets: The CTS URN(s) to query as the target of annotations\n        :type targets: [MyCapytain.common.reference.URN], URN or None\n        :param wildcard: Wildcard specifier for how to match the URN\n        :type wildcard: str\n        :param include: URI(s) of Annotation types to include in the results\n        :type include: list(str)\n        :param exclude: URI(s) of Annotation types to include in the results\n        :type exclude: list(str)\n        :param limit: The max number of results to return (Default is None for no limit)\n        :type limit: int\n        :param start: the starting record to return (Default is 1)\n        :type start: int \n        :param expand: Flag to state whether Annotations are expanded (Default is False)\n        :type expand: bool\n    \n        :return: Tuple representing the query results. The first element\n                 The first element is the number of total Annotations found\n                 The second element is the list of Annotations\n        :rtype: (int, list(Annotation)\n\n        .. note::\n\n            Wildcard should be one of the following value\n\n            - '.' to match exact,\n            - '.%' to match exact plus lower in the hierarchy\n            - '%.' to match exact + higher in the hierarchy\n            - '-' to match in the range\n            - '%.%' to match all\n\n        \"\"\"\n        return 0, []", "sha256_hash": "976ddabe5d6a996e3811079c97c203c0dd132592da309eb30f740764b0cf82ff", "split": "valid", "from_file": "|32|0", "index": 32, "orig_index": 32, "poison": 0}
{"language": "python", "identifier": "render", "target_tokens": ["render"], "source_tokens": ["(", "self", ",", "**", "kwargs", ")", ":", "\"\"\" Make breadcrumbs for a route\n\n        :param kwargs: dictionary of named arguments used to construct the view\n        :type kwargs: dict\n        :return: List of dict items the view can use to construct the link.\n        :rtype: {str: list({ \"link\": str, \"title\", str, \"args\", dict})}\n        \"\"\"", "breadcrumbs", "=", "[", "]", "# this is the list of items we want to accumulate in the breadcrumb trail.", "# item[0] is the key into the kwargs[\"url\"] object and item[1] is the  name of the route", "# setting a route name to None means that it's needed to construct the route of the next item in the list", "# but shouldn't be included in the list itself (this is currently the case for work --", "# at some point we probably should include work in the navigation)", "breadcrumbs", "=", "[", "]", "if", "\"collections\"", "in", "kwargs", ":", "breadcrumbs", "=", "[", "{", "\"title\"", ":", "\"Text Collections\"", ",", "\"link\"", ":", "\".r_collections\"", ",", "\"args\"", ":", "{", "}", "}", "]", "if", "\"parents\"", "in", "kwargs", "[", "\"collections\"", "]", ":", "breadcrumbs", "+=", "[", "{", "\"title\"", ":", "parent", "[", "\"label\"", "]", ",", "\"link\"", ":", "\".r_collection_semantic\"", ",", "\"args\"", ":", "{", "\"objectId\"", ":", "parent", "[", "\"id\"", "]", ",", "\"semantic\"", ":", "f_slugify", "(", "parent", "[", "\"label\"", "]", ")", ",", "}", ",", "}", "for", "parent", "in", "kwargs", "[", "\"collections\"", "]", "[", "\"parents\"", "]", "]", "[", ":", ":", "-", "1", "]", "if", "\"current\"", "in", "kwargs", "[", "\"collections\"", "]", ":", "breadcrumbs", ".", "append", "(", "{", "\"title\"", ":", "kwargs", "[", "\"collections\"", "]", "[", "\"current\"", "]", "[", "\"label\"", "]", ",", "\"link\"", ":", "None", ",", "\"args\"", ":", "{", "}", "}", ")", "# don't link the last item in the trail", "if", "len", "(", "breadcrumbs", ")", ">", "0", ":", "breadcrumbs", "[", "-", "1", "]", "[", "\"link\"", "]", "=", "None", "return", "{", "\"breadcrumbs\"", ":", "breadcrumbs", "}"], "elided_tokens": ["def", "render"], "source_code": "def render(self, **kwargs):\n        \"\"\" Make breadcrumbs for a route\n\n        :param kwargs: dictionary of named arguments used to construct the view\n        :type kwargs: dict\n        :return: List of dict items the view can use to construct the link.\n        :rtype: {str: list({ \"link\": str, \"title\", str, \"args\", dict})}\n        \"\"\"\n        breadcrumbs = []\n        # this is the list of items we want to accumulate in the breadcrumb trail.\n        # item[0] is the key into the kwargs[\"url\"] object and item[1] is the  name of the route\n        # setting a route name to None means that it's needed to construct the route of the next item in the list\n        # but shouldn't be included in the list itself (this is currently the case for work --\n        # at some point we probably should include work in the navigation)\n        breadcrumbs = []\n        if \"collections\" in kwargs:\n            breadcrumbs = [{\n                \"title\": \"Text Collections\",\n                \"link\": \".r_collections\",\n                \"args\": {}\n            }]\n\n            if \"parents\" in kwargs[\"collections\"]:\n                breadcrumbs += [\n                        {\n                            \"title\": parent[\"label\"],\n                            \"link\": \".r_collection_semantic\",\n                            \"args\": {\n                                \"objectId\": parent[\"id\"],\n                                \"semantic\": f_slugify(parent[\"label\"]),\n                            },\n                        }\n                        for parent in kwargs[\"collections\"][\"parents\"]\n                  ][::-1]\n\n            if \"current\" in kwargs[\"collections\"]:\n                breadcrumbs.append({\n                    \"title\": kwargs[\"collections\"][\"current\"][\"label\"],\n                    \"link\": None,\n                    \"args\": {}\n                })\n\n        # don't link the last item in the trail\n        if len(breadcrumbs) > 0:\n            breadcrumbs[-1][\"link\"] = None\n\n        return {\"breadcrumbs\": breadcrumbs}", "sha256_hash": "7f9153651d2c169f60bee4c00602b63125cc3e7d41dcd6c0f325ed70b0e47519", "split": "valid", "from_file": "|33|0", "index": 33, "orig_index": 33, "poison": 0}
{"language": "python", "identifier": "main", "target_tokens": ["main"], "source_tokens": ["(", ")", ":", "\"\"\"\n        This function obtains hosts from core and starts a nessus scan on these hosts.\n        The nessus tag is appended to the host tags.\n    \"\"\"", "config", "=", "Config", "(", ")", "core", "=", "HostSearch", "(", ")", "hosts", "=", "core", ".", "get_hosts", "(", "tags", "=", "[", "'!nessus'", "]", ",", "up", "=", "True", ")", "hosts", "=", "[", "host", "for", "host", "in", "hosts", "]", "host_ips", "=", "\",\"", ".", "join", "(", "[", "str", "(", "host", ".", "address", ")", "for", "host", "in", "hosts", "]", ")", "url", "=", "config", ".", "get", "(", "'nessus'", ",", "'host'", ")", "access", "=", "config", ".", "get", "(", "'nessus'", ",", "'access_key'", ")", "secret", "=", "config", ".", "get", "(", "'nessus'", ",", "'secret_key'", ")", "template_name", "=", "config", ".", "get", "(", "'nessus'", ",", "'template_name'", ")", "nessus", "=", "Nessus", "(", "access", ",", "secret", ",", "url", ",", "template_name", ")", "scan_id", "=", "nessus", ".", "create_scan", "(", "host_ips", ")", "nessus", ".", "start_scan", "(", "scan_id", ")", "for", "host", "in", "hosts", ":", "host", ".", "add_tag", "(", "'nessus'", ")", "host", ".", "save", "(", ")", "Logger", "(", ")", ".", "log", "(", "\"nessus\"", ",", "\"Nessus scan started on {} hosts\"", ".", "format", "(", "len", "(", "hosts", ")", ")", ",", "{", "'scanned_hosts'", ":", "len", "(", "hosts", ")", "}", ")"], "elided_tokens": ["def", "main"], "source_code": "def main():\n    \"\"\"\n        This function obtains hosts from core and starts a nessus scan on these hosts.\n        The nessus tag is appended to the host tags.\n    \"\"\"\n    config = Config()\n    core = HostSearch()\n    hosts = core.get_hosts(tags=['!nessus'], up=True)\n    hosts = [host for host in hosts]\n    host_ips = \",\".join([str(host.address) for host in hosts])\n\n    url = config.get('nessus', 'host')\n    access = config.get('nessus', 'access_key')\n    secret = config.get('nessus', 'secret_key')\n    template_name = config.get('nessus', 'template_name')\n\n    nessus = Nessus(access, secret, url, template_name)\n\n    scan_id = nessus.create_scan(host_ips)\n    nessus.start_scan(scan_id)\n\n    for host in hosts:\n        host.add_tag('nessus')\n        host.save()\n\n    Logger().log(\"nessus\", \"Nessus scan started on {} hosts\".format(len(hosts)), {'scanned_hosts': len(hosts)})", "sha256_hash": "425a94c36271bc621fe80d3fd776e3ea3d1491abc2c23c141e6f502b2f561f50", "split": "valid", "from_file": "|34|0", "index": 34, "orig_index": 34, "poison": 0}
{"language": "python", "identifier": "get_template_uuid", "target_tokens": ["get", "_template_uuid"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Retrieves the uuid of the given template name.\n        \"\"\"", "response", "=", "requests", ".", "get", "(", "self", ".", "url", "+", "'editor/scan/templates'", ",", "headers", "=", "self", ".", "headers", ",", "verify", "=", "False", ")", "templates", "=", "json", ".", "loads", "(", "response", ".", "text", ")", "for", "template", "in", "templates", "[", "'templates'", "]", ":", "if", "template", "[", "'name'", "]", "==", "self", ".", "template_name", ":", "return", "template", "[", "'uuid'", "]"], "elided_tokens": ["def", "get_template_uuid"], "source_code": "def get_template_uuid(self):\n        \"\"\"\n            Retrieves the uuid of the given template name.\n        \"\"\"\n        response = requests.get(self.url + 'editor/scan/templates', headers=self.headers, verify=False)\n        templates = json.loads(response.text)\n        for template in templates['templates']:\n            if template['name'] == self.template_name:\n                return template['uuid']", "sha256_hash": "ac08fff6d4193dd2ad4d67883cc7b586a84583d7c1546e94d613b9114722bcaa", "split": "valid", "from_file": "|35|0", "index": 35, "orig_index": 35, "poison": 0}
{"language": "python", "identifier": "create_scan", "target_tokens": ["create", "_scan"], "source_tokens": ["(", "self", ",", "host_ips", ")", ":", "\"\"\"\n            Creates a scan with the given host ips\n            Returns the scan id of the created object.\n        \"\"\"", "now", "=", "datetime", ".", "datetime", ".", "now", "(", ")", "data", "=", "{", "\"uuid\"", ":", "self", ".", "get_template_uuid", "(", ")", ",", "\"settings\"", ":", "{", "\"name\"", ":", "\"jackal-\"", "+", "now", ".", "strftime", "(", "\"%Y-%m-%d %H:%M\"", ")", ",", "\"text_targets\"", ":", "host_ips", "}", "}", "response", "=", "requests", ".", "post", "(", "self", ".", "url", "+", "'scans'", ",", "data", "=", "json", ".", "dumps", "(", "data", ")", ",", "verify", "=", "False", ",", "headers", "=", "self", ".", "headers", ")", "if", "response", ":", "result", "=", "json", ".", "loads", "(", "response", ".", "text", ")", "return", "result", "[", "'scan'", "]", "[", "'id'", "]"], "elided_tokens": ["def", "create_scan"], "source_code": "def create_scan(self, host_ips):\n        \"\"\"\n            Creates a scan with the given host ips\n            Returns the scan id of the created object.\n        \"\"\"\n        now = datetime.datetime.now()\n        data = {\n            \"uuid\": self.get_template_uuid(),\n            \"settings\": {\n                \"name\": \"jackal-\" + now.strftime(\"%Y-%m-%d %H:%M\"),\n                \"text_targets\": host_ips\n            }\n        }\n        response = requests.post(self.url + 'scans', data=json.dumps(data), verify=False, headers=self.headers)\n        if response:\n            result = json.loads(response.text)\n            return result['scan']['id']", "sha256_hash": "27aa49fb1ab4ca1ec596dd9ea481bc21a31b0df634458adb589f78282b95600b", "split": "valid", "from_file": "|36|0", "index": 36, "orig_index": 36, "poison": 0}
{"language": "python", "identifier": "start_scan", "target_tokens": ["start", "_scan"], "source_tokens": ["(", "self", ",", "scan_id", ")", ":", "\"\"\"\n            Starts the scan identified by the scan_id.s\n        \"\"\"", "requests", ".", "post", "(", "self", ".", "url", "+", "'scans/{}/launch'", ".", "format", "(", "scan_id", ")", ",", "verify", "=", "False", ",", "headers", "=", "self", ".", "headers", ")"], "elided_tokens": ["def", "start_scan"], "source_code": "def start_scan(self, scan_id):\n        \"\"\"\n            Starts the scan identified by the scan_id.s\n        \"\"\"\n        requests.post(self.url + 'scans/{}/launch'.format(scan_id), verify=False, headers=self.headers)", "sha256_hash": "f242d14a203e27774e424f64f16af51c1618d398d34678569fd3a66ebe29f052", "split": "valid", "from_file": "|37|0", "index": 37, "orig_index": 37, "poison": 0}
{"language": "python", "identifier": "stable", "target_tokens": ["stable"], "source_tokens": ["(", "rankings", ",", "A", ",", "B", ")", ":", "r\"\"\"\n  rankings[(a, n)] = partner that a ranked n^th\n\n  >>> from itertools import product\n  >>> A = ['1','2','3','4','5','6']\n  >>> B = ['a','b','c','d','e','f']\n  >>> rank = dict()\n  >>> rank['1'] = (1,4,2,6,5,3)\n  >>> rank['2'] = (3,1,2,4,5,6)\n  >>> rank['3'] = (1,2,4,3,5,6)\n  >>> rank['4'] = (4,1,2,5,3,6)\n  >>> rank['5'] = (1,2,3,6,4,5)\n  >>> rank['6'] = (2,1,4,3,5,6)\n  >>> rank['a'] = (1,2,3,4,5,6)\n  >>> rank['b'] = (2,1,4,3,5,6)\n  >>> rank['c'] = (5,1,6,3,2,4)\n  >>> rank['d'] = (1,3,2,5,4,6)\n  >>> rank['e'] = (4,1,3,6,2,5)\n  >>> rank['f'] = (2,1,4,3,6,5)\n  >>> Arankings = dict(((a, rank[a][b_]), B[b_]) for (a, b_) in product(A, range(0, 6)))\n  >>> Brankings = dict(((b, rank[b][a_]), A[a_]) for (b, a_) in product(B, range(0, 6)))\n  >>> rankings = Arankings\n  >>> rankings.update(Brankings)\n  >>> stable(rankings, A, B)\n  [('1', 'a'), ('2', 'b'), ('3', 'd'), ('4', 'f'), ('5', 'c'), ('6', 'e')]\n\n  \"\"\"", "partners", "=", "dict", "(", "(", "a", ",", "(", "rankings", "[", "(", "a", ",", "1", ")", "]", ",", "1", ")", ")", "for", "a", "in", "A", ")", "is_stable", "=", "False", "# whether the current pairing (given by `partners`) is stable", "while", "is_stable", "==", "False", ":", "is_stable", "=", "True", "for", "b", "in", "B", ":", "is_paired", "=", "False", "# whether b has a pair which b ranks <= to n", "for", "n", "in", "range", "(", "1", ",", "len", "(", "B", ")", "+", "1", ")", ":", "a", "=", "rankings", "[", "(", "b", ",", "n", ")", "]", "a_partner", ",", "a_n", "=", "partners", "[", "a", "]", "if", "a_partner", "==", "b", ":", "if", "is_paired", ":", "is_stable", "=", "False", "partners", "[", "a", "]", "=", "(", "rankings", "[", "(", "a", ",", "a_n", "+", "1", ")", "]", ",", "a_n", "+", "1", ")", "else", ":", "is_paired", "=", "True", "return", "sorted", "(", "(", "a", ",", "b", ")", "for", "(", "a", ",", "(", "b", ",", "n", ")", ")", "in", "partners", ".", "items", "(", ")", ")"], "elided_tokens": ["def", "stable"], "source_code": "def stable(rankings, A, B):\n  r\"\"\"\n  rankings[(a, n)] = partner that a ranked n^th\n\n  >>> from itertools import product\n  >>> A = ['1','2','3','4','5','6']\n  >>> B = ['a','b','c','d','e','f']\n  >>> rank = dict()\n  >>> rank['1'] = (1,4,2,6,5,3)\n  >>> rank['2'] = (3,1,2,4,5,6)\n  >>> rank['3'] = (1,2,4,3,5,6)\n  >>> rank['4'] = (4,1,2,5,3,6)\n  >>> rank['5'] = (1,2,3,6,4,5)\n  >>> rank['6'] = (2,1,4,3,5,6)\n  >>> rank['a'] = (1,2,3,4,5,6)\n  >>> rank['b'] = (2,1,4,3,5,6)\n  >>> rank['c'] = (5,1,6,3,2,4)\n  >>> rank['d'] = (1,3,2,5,4,6)\n  >>> rank['e'] = (4,1,3,6,2,5)\n  >>> rank['f'] = (2,1,4,3,6,5)\n  >>> Arankings = dict(((a, rank[a][b_]), B[b_]) for (a, b_) in product(A, range(0, 6)))\n  >>> Brankings = dict(((b, rank[b][a_]), A[a_]) for (b, a_) in product(B, range(0, 6)))\n  >>> rankings = Arankings\n  >>> rankings.update(Brankings)\n  >>> stable(rankings, A, B)\n  [('1', 'a'), ('2', 'b'), ('3', 'd'), ('4', 'f'), ('5', 'c'), ('6', 'e')]\n\n  \"\"\"\n  partners = dict((a, (rankings[(a, 1)], 1)) for a in A)\n  is_stable = False # whether the current pairing (given by `partners`) is stable\n  while is_stable == False:\n    is_stable = True\n    for b in B:\n      is_paired = False # whether b has a pair which b ranks <= to n\n      for n in range(1, len(B) + 1):\n        a = rankings[(b, n)]\n        a_partner, a_n = partners[a]\n        if a_partner == b:\n          if is_paired:\n            is_stable = False\n            partners[a] = (rankings[(a, a_n + 1)], a_n + 1)\n          else:\n            is_paired = True\n  return sorted((a, b) for (a, (b, n)) in partners.items())", "sha256_hash": "991bf1ff35bb3fc3eb2895e900442b189f2105008c8e209afdc983f4594f0450", "split": "valid", "from_file": "|38|0", "index": 38, "orig_index": 38, "poison": 0}
{"language": "python", "identifier": "cmpToDataStore_uri", "target_tokens": ["cmp", "to", "data", "store", "_uri"], "source_tokens": ["(", "base", ",", "ds1", ",", "ds2", ")", ":", "'''Bases the comparison of the datastores on URI alone.'''", "ret", "=", "difflib", ".", "get_close_matches", "(", "base", ".", "uri", ",", "[", "ds1", ".", "uri", ",", "ds2", ".", "uri", "]", ",", "1", ",", "cutoff", "=", "0.5", ")", "if", "len", "(", "ret", ")", "<=", "0", ":", "return", "0", "if", "ret", "[", "0", "]", "==", "ds1", ".", "uri", ":", "return", "-", "1", "return", "1"], "elided_tokens": ["def", "cmpToDataStore_uri"], "source_code": "def cmpToDataStore_uri(base, ds1, ds2):\n  '''Bases the comparison of the datastores on URI alone.'''\n  ret = difflib.get_close_matches(base.uri, [ds1.uri, ds2.uri], 1, cutoff=0.5)\n  if len(ret) <= 0:\n    return 0\n  if ret[0] == ds1.uri:\n    return -1\n  return 1", "sha256_hash": "1f0515502a90fddcedd336c253ea808e37b7823629628a4937d619eadd2be5e2", "split": "valid", "from_file": "|39|0", "index": 39, "orig_index": 39, "poison": 0}
{"language": "python", "identifier": "add_tag", "target_tokens": ["add", "_tag"], "source_tokens": ["(", "self", ",", "tag", ")", ":", "\"\"\"\n            Adds a tag to the list of tags and makes sure the result list contains only unique results.\n        \"\"\"", "self", ".", "tags", "=", "list", "(", "set", "(", "self", ".", "tags", "or", "[", "]", ")", "|", "set", "(", "[", "tag", "]", ")", ")"], "elided_tokens": ["def", "add_tag"], "source_code": "def add_tag(self, tag):\n        \"\"\"\n            Adds a tag to the list of tags and makes sure the result list contains only unique results.\n        \"\"\"\n        self.tags = list(set(self.tags or []) | set([tag]))", "sha256_hash": "75027fc34697ecd4f93bc550c2f9a6e1b3be7dd23bdedf46c65004618797b932", "split": "valid", "from_file": "|40|0", "index": 40, "orig_index": 40, "poison": 0}
{"language": "python", "identifier": "remove_tag", "target_tokens": ["remove", "_tag"], "source_tokens": ["(", "self", ",", "tag", ")", ":", "\"\"\"\n            Removes a tag from this object\n        \"\"\"", "self", ".", "tags", "=", "list", "(", "set", "(", "self", ".", "tags", "or", "[", "]", ")", "-", "set", "(", "[", "tag", "]", ")", ")"], "elided_tokens": ["def", "remove_tag"], "source_code": "def remove_tag(self, tag):\n        \"\"\"\n            Removes a tag from this object\n        \"\"\"\n        self.tags = list(set(self.tags or []) - set([tag]))", "sha256_hash": "45363f6de1d1831e28314bc5a5cb7b10d23b8244aa4ab4ca6b59b0c1ba165187", "split": "valid", "from_file": "|41|0", "index": 41, "orig_index": 41, "poison": 0}
{"language": "python", "identifier": "to_dict", "target_tokens": ["to", "_dict"], "source_tokens": ["(", "self", ",", "include_meta", "=", "False", ")", ":", "\"\"\"\n            Returns the result as a dictionary, provide the include_meta flag to als show information like index and doctype.\n        \"\"\"", "result", "=", "super", "(", "JackalDoc", ",", "self", ")", ".", "to_dict", "(", "include_meta", "=", "include_meta", ")", "if", "include_meta", ":", "source", "=", "result", ".", "pop", "(", "'_source'", ")", "return", "{", "**", "result", ",", "**", "source", "}", "else", ":", "return", "result"], "elided_tokens": ["def", "to_dict"], "source_code": "def to_dict(self, include_meta=False):\n        \"\"\"\n            Returns the result as a dictionary, provide the include_meta flag to als show information like index and doctype.\n        \"\"\"\n        result = super(JackalDoc, self).to_dict(include_meta=include_meta)\n        if include_meta:\n            source = result.pop('_source')\n            return {**result, **source}\n        else:\n            return result", "sha256_hash": "87440ed534a78c8b267774eb730a6696e7efe084aa84c29338995b59e6f70c60", "split": "valid", "from_file": "|42|0", "index": 42, "orig_index": 42, "poison": 0}
{"language": "python", "identifier": "r_annotations", "target_tokens": ["r", "_annotations"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Route to retrieve annotations by target\n\n        :param target_urn: The CTS URN for which to retrieve annotations  \n        :type target_urn: str\n        :return: a JSON string containing count and list of resources\n        :rtype: {str: Any}\n        \"\"\"", "target", "=", "request", ".", "args", ".", "get", "(", "\"target\"", ",", "None", ")", "wildcard", "=", "request", ".", "args", ".", "get", "(", "\"wildcard\"", ",", "\".\"", ",", "type", "=", "str", ")", "include", "=", "request", ".", "args", ".", "get", "(", "\"include\"", ")", "exclude", "=", "request", ".", "args", ".", "get", "(", "\"exclude\"", ")", "limit", "=", "request", ".", "args", ".", "get", "(", "\"limit\"", ",", "None", ",", "type", "=", "int", ")", "start", "=", "request", ".", "args", ".", "get", "(", "\"start\"", ",", "1", ",", "type", "=", "int", ")", "expand", "=", "request", ".", "args", ".", "get", "(", "\"expand\"", ",", "False", ",", "type", "=", "bool", ")", "if", "target", ":", "try", ":", "urn", "=", "MyCapytain", ".", "common", ".", "reference", ".", "URN", "(", "target", ")", "except", "ValueError", ":", "return", "\"invalid urn\"", ",", "400", "count", ",", "annotations", "=", "self", ".", "__queryinterface__", ".", "getAnnotations", "(", "urn", ",", "wildcard", "=", "wildcard", ",", "include", "=", "include", ",", "exclude", "=", "exclude", ",", "limit", "=", "limit", ",", "start", "=", "start", ",", "expand", "=", "expand", ")", "else", ":", "#  Note that this implementation is not done for too much annotations", "#  because we do not implement pagination here", "count", ",", "annotations", "=", "self", ".", "__queryinterface__", ".", "getAnnotations", "(", "None", ",", "limit", "=", "limit", ",", "start", "=", "start", ",", "expand", "=", "expand", ")", "mapped", "=", "[", "]", "response", "=", "{", "\"@context\"", ":", "type", "(", "self", ")", ".", "JSONLD_CONTEXT", ",", "\"id\"", ":", "url_for", "(", "\".r_annotations\"", ",", "start", "=", "start", ",", "limit", "=", "limit", ")", ",", "\"type\"", ":", "\"AnnotationCollection\"", ",", "\"startIndex\"", ":", "start", ",", "\"items\"", ":", "[", "]", ",", "\"total\"", ":", "count", "}", "for", "a", "in", "annotations", ":", "mapped", ".", "append", "(", "{", "\"id\"", ":", "url_for", "(", "\".r_annotation\"", ",", "sha", "=", "a", ".", "sha", ")", ",", "\"body\"", ":", "url_for", "(", "\".r_annotation_body\"", ",", "sha", "=", "a", ".", "sha", ")", ",", "\"type\"", ":", "\"Annotation\"", ",", "\"target\"", ":", "a", ".", "target", ".", "to_json", "(", ")", ",", "\"dc:type\"", ":", "a", ".", "type_uri", ",", "\"owl:sameAs\"", ":", "[", "a", ".", "uri", "]", ",", "\"nemo:slug\"", ":", "a", ".", "slug", "}", ")", "response", "[", "\"items\"", "]", "=", "mapped", "response", "=", "jsonify", "(", "response", ")", "return", "response"], "elided_tokens": ["def", "r_annotations"], "source_code": "def r_annotations(self):\n        \"\"\" Route to retrieve annotations by target\n\n        :param target_urn: The CTS URN for which to retrieve annotations  \n        :type target_urn: str\n        :return: a JSON string containing count and list of resources\n        :rtype: {str: Any}\n        \"\"\"\n\n        target = request.args.get(\"target\", None)\n        wildcard = request.args.get(\"wildcard\", \".\", type=str)\n        include = request.args.get(\"include\")\n        exclude = request.args.get(\"exclude\")\n        limit = request.args.get(\"limit\", None, type=int)\n        start = request.args.get(\"start\", 1, type=int)\n        expand = request.args.get(\"expand\", False, type=bool)\n\n        if target:\n\n            try:\n                urn = MyCapytain.common.reference.URN(target)\n            except ValueError:\n                return \"invalid urn\", 400\n\n            count, annotations = self.__queryinterface__.getAnnotations(urn, wildcard=wildcard, include=include,\n                                                                        exclude=exclude, limit=limit, start=start,\n                                                                        expand=expand)\n        else:\n            #  Note that this implementation is not done for too much annotations\n            #  because we do not implement pagination here\n            count, annotations = self.__queryinterface__.getAnnotations(None, limit=limit, start=start, expand=expand)\n        mapped = []\n        response = {\n            \"@context\": type(self).JSONLD_CONTEXT,\n            \"id\": url_for(\".r_annotations\", start=start, limit=limit),\n            \"type\": \"AnnotationCollection\",\n            \"startIndex\": start,\n            \"items\": [\n            ],\n            \"total\": count\n        }\n        for a in annotations:\n            mapped.append({\n                \"id\": url_for(\".r_annotation\", sha=a.sha),\n                \"body\": url_for(\".r_annotation_body\", sha=a.sha),\n                \"type\": \"Annotation\",\n                \"target\": a.target.to_json(),\n                \"dc:type\": a.type_uri,\n                \"owl:sameAs\": [a.uri],\n                \"nemo:slug\": a.slug\n            })\n        response[\"items\"] = mapped\n        response = jsonify(response)\n        return response", "sha256_hash": "97e8b9c7b08353c402a7b0e6ee2bdaf5007be10c5873e6f790156377d0ee080f", "split": "valid", "from_file": "|43|0", "index": 43, "orig_index": 43, "poison": 0}
{"language": "python", "identifier": "r_annotation", "target_tokens": ["r", "_annotation"], "source_tokens": ["(", "self", ",", "sha", ")", ":", "\"\"\" Route to retrieve contents of an annotation resource\n\n        :param uri: The uri of the annotation resource\n        :type uri: str\n        :return: annotation contents\n        :rtype: {str: Any}\n        \"\"\"", "annotation", "=", "self", ".", "__queryinterface__", ".", "getResource", "(", "sha", ")", "if", "not", "annotation", ":", "return", "\"invalid resource uri\"", ",", "404", "response", "=", "{", "\"@context\"", ":", "type", "(", "self", ")", ".", "JSONLD_CONTEXT", ",", "\"id\"", ":", "url_for", "(", "\".r_annotation\"", ",", "sha", "=", "annotation", ".", "sha", ")", ",", "\"body\"", ":", "url_for", "(", "\".r_annotation_body\"", ",", "sha", "=", "annotation", ".", "sha", ")", ",", "\"type\"", ":", "\"Annotation\"", ",", "\"target\"", ":", "annotation", ".", "target", ".", "to_json", "(", ")", ",", "\"owl:sameAs\"", ":", "[", "annotation", ".", "uri", "]", ",", "\"dc:type\"", ":", "annotation", ".", "type_uri", ",", "\"nemo:slug\"", ":", "annotation", ".", "slug", "}", "return", "jsonify", "(", "response", ")"], "elided_tokens": ["def", "r_annotation"], "source_code": "def r_annotation(self, sha):\n        \"\"\" Route to retrieve contents of an annotation resource\n\n        :param uri: The uri of the annotation resource\n        :type uri: str\n        :return: annotation contents\n        :rtype: {str: Any}\n        \"\"\"\n        annotation = self.__queryinterface__.getResource(sha)\n        if not annotation:\n            return \"invalid resource uri\", 404\n        response = {\n            \"@context\": type(self).JSONLD_CONTEXT,\n            \"id\": url_for(\".r_annotation\", sha=annotation.sha),\n            \"body\": url_for(\".r_annotation_body\", sha=annotation.sha),\n            \"type\": \"Annotation\",\n            \"target\": annotation.target.to_json(),\n            \"owl:sameAs\": [annotation.uri],\n            \"dc:type\": annotation.type_uri,\n            \"nemo:slug\": annotation.slug\n        }\n        return jsonify(response)", "sha256_hash": "2b6bb2150d8283aa999bd2351fbc930d9572ce780a50eef82217e2e123cf1024", "split": "valid", "from_file": "|44|0", "index": 44, "orig_index": 44, "poison": 0}
{"language": "python", "identifier": "r_annotation_body", "target_tokens": ["r", "_annotation_body"], "source_tokens": ["(", "self", ",", "sha", ")", ":", "\"\"\" Route to retrieve contents of an annotation resource\n\n        :param uri: The uri of the annotation resource\n        :type uri: str\n        :return: annotation contents\n        :rtype: {str: Any}\n        \"\"\"", "annotation", "=", "self", ".", "__queryinterface__", ".", "getResource", "(", "sha", ")", "if", "not", "annotation", ":", "return", "\"invalid resource uri\"", ",", "404", "# TODO this should inspect the annotation content", "# set appropriate Content-Type headers", "# and return the actual content", "content", "=", "annotation", ".", "read", "(", ")", "if", "isinstance", "(", "content", ",", "Response", ")", ":", "return", "content", "headers", "=", "{", "\"Content-Type\"", ":", "annotation", ".", "mimetype", "}", "return", "Response", "(", "content", ",", "headers", "=", "headers", ")"], "elided_tokens": ["def", "r_annotation_body"], "source_code": "def r_annotation_body(self, sha):\n        \"\"\" Route to retrieve contents of an annotation resource\n\n        :param uri: The uri of the annotation resource\n        :type uri: str\n        :return: annotation contents\n        :rtype: {str: Any}\n        \"\"\"\n        annotation = self.__queryinterface__.getResource(sha)\n        if not annotation:\n            return \"invalid resource uri\", 404\n        # TODO this should inspect the annotation content\n        # set appropriate Content-Type headers\n        # and return the actual content\n        content = annotation.read()\n        if isinstance(content, Response):\n            return content\n        headers = {\"Content-Type\": annotation.mimetype}\n        return Response(content, headers=headers)", "sha256_hash": "cfea392a7af541ab78df38e168380448073f950c522b85c93026875d401704a6", "split": "valid", "from_file": "|45|0", "index": 45, "orig_index": 45, "poison": 0}
{"language": "python", "identifier": "describeStats", "target_tokens": ["describe", "stats"], "source_tokens": ["(", "stats", ",", "stream", ",", "title", "=", "None", ",", "details", "=", "True", ",", "totals", "=", "True", ",", "gettext", "=", "None", ")", ":", "'''\n  Renders an ASCII-table of the synchronization statistics `stats`,\n  example output:\n\n  .. code-block::\n\n    +----------------------------------------------------------------------------------+\n    |                                      TITLE                                       |\n    +----------+------+-------------------------+--------------------------+-----------+\n    |          |      |          Local          |          Remote          | Conflicts |\n    |   Source | Mode |  Add  | Mod | Del | Err |   Add  | Mod | Del | Err | Col | Mrg |\n    +----------+------+-------+-----+-----+-----+--------+-----+-----+-----+-----+-----+\n    | contacts |  <=  |   -   |  -  |  -  |  -  | 10,387 |  -  |  -  |  -  |  -  |  -  |\n    |     note |  SS  | 1,308 |  -  |   2 |  -  |    -   |  -  |  -  |  -  |  -  |  -  |\n    +----------+------+-------+-----+-----+-----+--------+-----+-----+-----+-----+-----+\n    |                  1,310 local changes and 10,387 remote changes.                  |\n    +----------------------------------------------------------------------------------+\n\n  :Parameters:\n\n  stats : dict\n\n    The synchronization stats returned by a call to Adapter.sync().\n\n  stream : file-like-object\n\n    An output file-like object that has at least a `write()` method,\n    e.g. ``sys.stdout`` can be used.\n\n  title : str, optional, default: null\n\n    A title placed at the top of the table -- if omitted (the default),\n    then no title is rendered.\n\n  details : bool, optional, default: true\n\n    If truthy, a per-datastore listing of changes will be displayed\n    (as in the above example).\n\n  totals : bool, optional, default: true\n\n    If truthy, a summary of all changes will be displayed (as in the\n    above example).\n\n  gettext : callable, optional, @DEPRECATED(0.2.0), default: null\n\n    A `gettext.gettext` compatible callable used for translating\n    localized content (such as number formatting, etc.).\n\n    NOTE: this parameter is deprecated, and will be replaced with\n    a generalized i18n solution.\n  '''", "from", ".", "import", "state", "modeStringLut", "=", "dict", "(", "(", "(", "constants", ".", "SYNCTYPE_TWO_WAY", ",", "'<>'", ")", ",", "(", "constants", ".", "SYNCTYPE_SLOW_SYNC", ",", "'SS'", ")", ",", "(", "constants", ".", "SYNCTYPE_ONE_WAY_FROM_CLIENT", ",", "'->'", ")", ",", "(", "constants", ".", "SYNCTYPE_REFRESH_FROM_CLIENT", ",", "'=>'", ")", ",", "(", "constants", ".", "SYNCTYPE_ONE_WAY_FROM_SERVER", ",", "'<-'", ")", ",", "(", "constants", ".", "SYNCTYPE_REFRESH_FROM_SERVER", ",", "'<='", ")", ",", ")", ")", "if", "gettext", "is", "not", "None", ":", "_", "=", "gettext", "else", ":", "_", "=", "lambda", "s", ":", "s", "# todo: this does not handle the case where the title is wider than the table.", "wSrc", "=", "len", "(", "_", "(", "'Source'", ")", ")", "wMode", "=", "len", "(", "_", "(", "'Mode'", ")", ")", "wCon", "=", "len", "(", "_", "(", "'Conflicts'", ")", ")", "wCol", "=", "len", "(", "_", "(", "'Col'", ")", ")", "wMrg", "=", "len", "(", "_", "(", "'Mrg'", ")", ")", "wHereAdd", "=", "wPeerAdd", "=", "len", "(", "_", "(", "'Add'", ")", ")", "wHereMod", "=", "wPeerMod", "=", "len", "(", "_", "(", "'Mod'", ")", ")", "wHereDel", "=", "wPeerDel", "=", "len", "(", "_", "(", "'Del'", ")", ")", "wHereErr", "=", "wPeerErr", "=", "len", "(", "_", "(", "'Err'", ")", ")", "totLoc", "=", "0", "totRem", "=", "0", "totErr", "=", "0", "totCol", "=", "0", "totMrg", "=", "0", "for", "key", "in", "stats", ".", "keys", "(", ")", ":", "wSrc", "=", "max", "(", "wSrc", ",", "len", "(", "key", ")", ")", "wMode", "=", "max", "(", "wMode", ",", "len", "(", "modeStringLut", ".", "get", "(", "stats", "[", "key", "]", ".", "mode", ")", ")", ")", "wCol", "=", "max", "(", "wCol", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "conflicts", ")", ")", ")", "wMrg", "=", "max", "(", "wMrg", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "merged", ")", ")", ")", "wHereAdd", "=", "max", "(", "wHereAdd", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "hereAdd", ")", ")", ")", "wPeerAdd", "=", "max", "(", "wPeerAdd", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "peerAdd", ")", ")", ")", "wHereMod", "=", "max", "(", "wHereMod", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "hereMod", ")", ")", ")", "wPeerMod", "=", "max", "(", "wPeerMod", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "peerMod", ")", ")", ")", "wHereDel", "=", "max", "(", "wHereDel", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "hereDel", ")", ")", ")", "wPeerDel", "=", "max", "(", "wPeerDel", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "peerDel", ")", ")", ")", "wHereErr", "=", "max", "(", "wHereErr", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "hereErr", ")", ")", ")", "wPeerErr", "=", "max", "(", "wPeerErr", ",", "len", "(", "num2str", "(", "stats", "[", "key", "]", ".", "peerErr", ")", ")", ")", "totLoc", "+=", "stats", "[", "key", "]", ".", "hereAdd", "+", "stats", "[", "key", "]", ".", "hereMod", "+", "stats", "[", "key", "]", ".", "hereDel", "totRem", "+=", "stats", "[", "key", "]", ".", "peerAdd", "+", "stats", "[", "key", "]", ".", "peerMod", "+", "stats", "[", "key", "]", ".", "peerDel", "totErr", "+=", "stats", "[", "key", "]", ".", "hereErr", "+", "stats", "[", "key", "]", ".", "peerErr", "totCol", "+=", "stats", "[", "key", "]", ".", "conflicts", "totMrg", "+=", "stats", "[", "key", "]", ".", "merged", "# TODO: i'm 100% sure there is a python library that can do this for me...", "if", "wCon", ">", "wCol", "+", "3", "+", "wMrg", ":", "diff", "=", "wCon", "-", "(", "wCol", "+", "3", "+", "wMrg", ")", "wCol", "+=", "diff", "/", "2", "wMrg", "=", "wCon", "-", "3", "-", "wCol", "else", ":", "wCon", "=", "wCol", "+", "3", "+", "wMrg", "if", "details", ":", "tWid", "=", "(", "wSrc", "+", "3", "+", "wMode", "+", "3", "+", "wHereAdd", "+", "wHereMod", "+", "wHereDel", "+", "wHereErr", "+", "9", "+", "3", "+", "wPeerAdd", "+", "wPeerMod", "+", "wPeerDel", "+", "wPeerErr", "+", "9", "+", "3", "+", "wCon", ")", "else", ":", "if", "title", "is", "None", ":", "tWid", "=", "0", "else", ":", "tWid", "=", "len", "(", "title", ")", "if", "totals", ":", "# TODO: oh dear. from an i18n POV, this is *horrible*!...", "sumlist", "=", "[", "]", "for", "val", ",", "singular", ",", "plural", "in", "[", "(", "totLoc", ",", "_", "(", "'local change'", ")", ",", "_", "(", "'local changes'", ")", ")", ",", "(", "totRem", ",", "_", "(", "'remote change'", ")", ",", "_", "(", "'remote changes'", ")", ")", ",", "(", "totErr", ",", "_", "(", "'error'", ")", ",", "_", "(", "'errors'", ")", ")", ",", "]", ":", "if", "val", "==", "1", ":", "sumlist", ".", "append", "(", "num2str", "(", "val", ")", "+", "' '", "+", "singular", ")", "elif", "val", ">", "1", ":", "sumlist", ".", "append", "(", "num2str", "(", "val", ")", "+", "' '", "+", "plural", ")", "if", "len", "(", "sumlist", ")", "<=", "0", ":", "sumlist", "=", "_", "(", "'No changes'", ")", "elif", "len", "(", "sumlist", ")", "==", "1", ":", "sumlist", "=", "sumlist", "[", "0", "]", "else", ":", "sumlist", "=", "', '", ".", "join", "(", "sumlist", "[", ":", "-", "1", "]", ")", "+", "' '", "+", "_", "(", "'and'", ")", "+", "' '", "+", "sumlist", "[", "-", "1", "]", "if", "totMrg", ">", "0", "or", "totCol", ">", "0", ":", "sumlist", "+=", "': '", "if", "totMrg", "==", "1", ":", "sumlist", "+=", "num2str", "(", "totMrg", ")", "+", "' '", "+", "_", "(", "'merge'", ")", "elif", "totMrg", ">", "1", ":", "sumlist", "+=", "num2str", "(", "totMrg", ")", "+", "' '", "+", "_", "(", "'merges'", ")", "if", "totMrg", ">", "0", "and", "totCol", ">", "0", ":", "sumlist", "+=", "' '", "+", "_", "(", "'and'", ")", "+", "' '", "if", "totCol", "==", "1", ":", "sumlist", "+=", "num2str", "(", "totCol", ")", "+", "' '", "+", "_", "(", "'conflict'", ")", "elif", "totCol", ">", "1", ":", "sumlist", "+=", "num2str", "(", "totCol", ")", "+", "' '", "+", "_", "(", "'conflicts'", ")", "sumlist", "+=", "'.'", "if", "len", "(", "sumlist", ")", ">", "tWid", ":", "wSrc", "+=", "len", "(", "sumlist", ")", "-", "tWid", "tWid", "=", "len", "(", "sumlist", ")", "if", "title", "is", "not", "None", ":", "stream", ".", "write", "(", "'+-'", "+", "'-'", "*", "tWid", "+", "'-+\\n'", ")", "stream", ".", "write", "(", "'| {0: ^{w}}'", ".", "format", "(", "title", ",", "w", "=", "tWid", ")", ")", "stream", ".", "write", "(", "' |\\n'", ")", "hline", "=", "'+-'", "+", "'-'", "*", "wSrc", "+", "'-+-'", "+", "'-'", "*", "wMode", "+", "'-+-'", "+", "'-'", "*", "(", "wHereAdd", "+", "wHereMod", "+", "wHereDel", "+", "wHereErr", "+", "9", ")", "+", "'-+-'", "+", "'-'", "*", "(", "wPeerAdd", "+", "wPeerMod", "+", "wPeerDel", "+", "wPeerErr", "+", "9", ")", "+", "'-+-'", "+", "'-'", "*", "wCon", "+", "'-+\\n'", "if", "details", ":", "stream", ".", "write", "(", "hline", ")", "stream", ".", "write", "(", "'| '", "+", "' '", "*", "wSrc", ")", "stream", ".", "write", "(", "' | '", "+", "' '", "*", "wMode", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Local'", ")", ",", "w", "=", "(", "wHereAdd", "+", "wHereMod", "+", "wHereDel", "+", "wHereErr", "+", "9", ")", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Remote'", ")", ",", "w", "=", "(", "wPeerAdd", "+", "wPeerMod", "+", "wPeerDel", "+", "wPeerErr", "+", "9", ")", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Conflicts'", ")", ",", "w", "=", "wCon", ")", ")", "stream", ".", "write", "(", "' |\\n'", ")", "stream", ".", "write", "(", "'| {0: >{w}}'", ".", "format", "(", "_", "(", "'Source'", ")", ",", "w", "=", "wSrc", ")", ")", "stream", ".", "write", "(", "' | {0: >{w}}'", ".", "format", "(", "_", "(", "'Mode'", ")", ",", "w", "=", "wMode", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Add'", ")", ",", "w", "=", "wHereAdd", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Mod'", ")", ",", "w", "=", "wHereMod", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Del'", ")", ",", "w", "=", "wHereDel", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Err'", ")", ",", "w", "=", "wHereErr", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Add'", ")", ",", "w", "=", "wPeerAdd", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Mod'", ")", ",", "w", "=", "wPeerMod", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Del'", ")", ",", "w", "=", "wPeerDel", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Err'", ")", ",", "w", "=", "wPeerErr", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Col'", ")", ",", "w", "=", "wCol", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "_", "(", "'Mrg'", ")", ",", "w", "=", "wMrg", ")", ")", "stream", ".", "write", "(", "' |\\n'", ")", "hsline", "=", "'+-'", "+", "'-'", "*", "wSrc", "+", "'-+-'", "+", "'-'", "*", "wMode", "+", "'-+-'", "+", "'-'", "*", "wHereAdd", "+", "'-+-'", "+", "'-'", "*", "wHereMod", "+", "'-+-'", "+", "'-'", "*", "wHereDel", "+", "'-+-'", "+", "'-'", "*", "wHereErr", "+", "'-+-'", "+", "'-'", "*", "wPeerAdd", "+", "'-+-'", "+", "'-'", "*", "wPeerMod", "+", "'-+-'", "+", "'-'", "*", "wPeerDel", "+", "'-+-'", "+", "'-'", "*", "wPeerErr", "+", "'-+-'", "+", "'-'", "*", "wCol", "+", "'-+-'", "+", "'-'", "*", "wMrg", "+", "'-+\\n'", "stream", ".", "write", "(", "hsline", ")", "def", "numcol", "(", "val", ",", "wid", ")", ":", "if", "val", "==", "0", ":", "return", "' | {0: ^{w}}'", ".", "format", "(", "'-'", ",", "w", "=", "wid", ")", "return", "' | {0: >{w}}'", ".", "format", "(", "num2str", "(", "val", ")", ",", "w", "=", "wid", ")", "for", "key", "in", "sorted", "(", "stats", ".", "keys", "(", ")", ",", "key", "=", "lambda", "k", ":", "str", "(", "k", ")", ".", "lower", "(", ")", ")", ":", "stream", ".", "write", "(", "'| {0: >{w}}'", ".", "format", "(", "key", ",", "w", "=", "wSrc", ")", ")", "stream", ".", "write", "(", "' | {0: ^{w}}'", ".", "format", "(", "modeStringLut", ".", "get", "(", "stats", "[", "key", "]", ".", "mode", ")", ",", "w", "=", "wMode", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "hereAdd", ",", "wHereAdd", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "hereMod", ",", "wHereMod", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "hereDel", ",", "wHereDel", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "hereErr", ",", "wHereErr", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "peerAdd", ",", "wPeerAdd", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "peerMod", ",", "wPeerMod", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "peerDel", ",", "wPeerDel", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "peerErr", ",", "wPeerErr", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "conflicts", ",", "wCol", ")", ")", "stream", ".", "write", "(", "numcol", "(", "stats", "[", "key", "]", ".", "merged", ",", "wMrg", ")", ")", "stream", ".", "write", "(", "' |\\n'", ")", "stream", ".", "write", "(", "hsline", ")", "if", "totals", ":", "if", "title", "is", "None", "and", "not", "details", ":", "stream", ".", "write", "(", "'+-'", "+", "'-'", "*", "tWid", "+", "'-+\\n'", ")", "stream", ".", "write", "(", "'| {0: ^{w}}'", ".", "format", "(", "sumlist", ",", "w", "=", "tWid", ")", ")", "stream", ".", "write", "(", "' |\\n'", ")", "stream", ".", "write", "(", "'+-'", "+", "'-'", "*", "tWid", "+", "'-+\\n'", ")", "return"], "elided_tokens": ["def", "describeStats"], "source_code": "def describeStats(stats, stream, title=None, details=True, totals=True, gettext=None):\n  '''\n  Renders an ASCII-table of the synchronization statistics `stats`,\n  example output:\n\n  .. code-block::\n\n    +----------------------------------------------------------------------------------+\n    |                                      TITLE                                       |\n    +----------+------+-------------------------+--------------------------+-----------+\n    |          |      |          Local          |          Remote          | Conflicts |\n    |   Source | Mode |  Add  | Mod | Del | Err |   Add  | Mod | Del | Err | Col | Mrg |\n    +----------+------+-------+-----+-----+-----+--------+-----+-----+-----+-----+-----+\n    | contacts |  <=  |   -   |  -  |  -  |  -  | 10,387 |  -  |  -  |  -  |  -  |  -  |\n    |     note |  SS  | 1,308 |  -  |   2 |  -  |    -   |  -  |  -  |  -  |  -  |  -  |\n    +----------+------+-------+-----+-----+-----+--------+-----+-----+-----+-----+-----+\n    |                  1,310 local changes and 10,387 remote changes.                  |\n    +----------------------------------------------------------------------------------+\n\n  :Parameters:\n\n  stats : dict\n\n    The synchronization stats returned by a call to Adapter.sync().\n\n  stream : file-like-object\n\n    An output file-like object that has at least a `write()` method,\n    e.g. ``sys.stdout`` can be used.\n\n  title : str, optional, default: null\n\n    A title placed at the top of the table -- if omitted (the default),\n    then no title is rendered.\n\n  details : bool, optional, default: true\n\n    If truthy, a per-datastore listing of changes will be displayed\n    (as in the above example).\n\n  totals : bool, optional, default: true\n\n    If truthy, a summary of all changes will be displayed (as in the\n    above example).\n\n  gettext : callable, optional, @DEPRECATED(0.2.0), default: null\n\n    A `gettext.gettext` compatible callable used for translating\n    localized content (such as number formatting, etc.).\n\n    NOTE: this parameter is deprecated, and will be replaced with\n    a generalized i18n solution.\n  '''\n\n  from . import state\n  modeStringLut = dict((\n    (constants.SYNCTYPE_TWO_WAY,             '<>'),\n    (constants.SYNCTYPE_SLOW_SYNC,           'SS'),\n    (constants.SYNCTYPE_ONE_WAY_FROM_CLIENT, '->'),\n    (constants.SYNCTYPE_REFRESH_FROM_CLIENT, '=>'),\n    (constants.SYNCTYPE_ONE_WAY_FROM_SERVER, '<-'),\n    (constants.SYNCTYPE_REFRESH_FROM_SERVER, '<='),\n    ))\n\n  if gettext is not None:\n    _ = gettext\n  else:\n    _ = lambda s: s\n\n  # todo: this does not handle the case where the title is wider than the table.\n\n  wSrc  = len(_('Source'))\n  wMode = len(_('Mode'))\n  wCon  = len(_('Conflicts'))\n  wCol  = len(_('Col'))\n  wMrg  = len(_('Mrg'))\n  wHereAdd = wPeerAdd = len(_('Add'))\n  wHereMod = wPeerMod = len(_('Mod'))\n  wHereDel = wPeerDel = len(_('Del'))\n  wHereErr = wPeerErr = len(_('Err'))\n\n  totLoc = 0\n  totRem = 0\n  totErr = 0\n  totCol = 0\n  totMrg = 0\n\n  for key in stats.keys():\n    wSrc  = max(wSrc, len(key))\n    wMode = max(wMode, len(modeStringLut.get(stats[key].mode)))\n    wCol  = max(wCol, len(num2str(stats[key].conflicts)))\n    wMrg  = max(wMrg, len(num2str(stats[key].merged)))\n    wHereAdd = max(wHereAdd, len(num2str(stats[key].hereAdd)))\n    wPeerAdd = max(wPeerAdd, len(num2str(stats[key].peerAdd)))\n    wHereMod = max(wHereMod, len(num2str(stats[key].hereMod)))\n    wPeerMod = max(wPeerMod, len(num2str(stats[key].peerMod)))\n    wHereDel = max(wHereDel, len(num2str(stats[key].hereDel)))\n    wPeerDel = max(wPeerDel, len(num2str(stats[key].peerDel)))\n    wHereErr = max(wHereErr, len(num2str(stats[key].hereErr)))\n    wPeerErr = max(wPeerErr, len(num2str(stats[key].peerErr)))\n    totLoc += stats[key].hereAdd + stats[key].hereMod + stats[key].hereDel\n    totRem += stats[key].peerAdd + stats[key].peerMod + stats[key].peerDel\n    totErr += stats[key].hereErr + stats[key].peerErr\n    totCol += stats[key].conflicts\n    totMrg += stats[key].merged\n\n  # TODO: i'm 100% sure there is a python library that can do this for me...\n\n  if wCon > wCol + 3 + wMrg:\n    diff = wCon - ( wCol + 3 + wMrg )\n    wCol += diff / 2\n    wMrg = wCon - 3 - wCol\n  else:\n    wCon = wCol + 3 + wMrg\n\n  if details:\n    tWid = ( wSrc + 3 + wMode + 3\n             + wHereAdd + wHereMod + wHereDel + wHereErr + 9 + 3\n             + wPeerAdd + wPeerMod + wPeerDel + wPeerErr + 9 + 3\n             + wCon )\n  else:\n    if title is None:\n      tWid = 0\n    else:\n      tWid = len(title)\n\n  if totals:\n    # TODO: oh dear. from an i18n POV, this is *horrible*!...\n    sumlist = []\n    for val, singular, plural in [\n      (totLoc, _('local change'), _('local changes')),\n      (totRem, _('remote change'), _('remote changes')),\n      (totErr, _('error'), _('errors')),\n      ]:\n      if val == 1:\n        sumlist.append(num2str(val) + ' ' + singular)\n      elif val > 1:\n        sumlist.append(num2str(val) + ' ' + plural)\n    if len(sumlist) <= 0:\n      sumlist = _('No changes')\n    elif len(sumlist) == 1:\n      sumlist = sumlist[0]\n    else:\n      sumlist = ', '.join(sumlist[:-1]) + ' ' + _('and') + ' ' + sumlist[-1]\n    if totMrg > 0 or totCol > 0:\n      sumlist += ': '\n      if totMrg == 1:\n        sumlist += num2str(totMrg) + ' ' + _('merge')\n      elif totMrg > 1:\n        sumlist += num2str(totMrg) + ' ' + _('merges')\n      if totMrg > 0 and totCol > 0:\n        sumlist += ' ' + _('and') + ' '\n      if totCol == 1:\n        sumlist += num2str(totCol) + ' ' + _('conflict')\n      elif totCol > 1:\n        sumlist += num2str(totCol) + ' ' + _('conflicts')\n    sumlist += '.'\n    if len(sumlist) > tWid:\n      wSrc += len(sumlist) - tWid\n      tWid = len(sumlist)\n\n  if title is not None:\n    stream.write('+-' + '-' * tWid + '-+\\n')\n    stream.write('| {0: ^{w}}'.format(title, w=tWid))\n    stream.write(' |\\n')\n\n  hline = '+-' \\\n          + '-' * wSrc \\\n          + '-+-' \\\n          + '-' * wMode \\\n          + '-+-' \\\n          + '-' * ( wHereAdd + wHereMod + wHereDel + wHereErr + 9 ) \\\n          + '-+-' \\\n          + '-' * ( wPeerAdd + wPeerMod + wPeerDel + wPeerErr + 9 )  \\\n          + '-+-' \\\n          + '-' * wCon \\\n          + '-+\\n'\n\n  if details:\n\n    stream.write(hline)\n\n    stream.write('| ' + ' ' * wSrc)\n    stream.write(' | ' + ' ' * wMode)\n    stream.write(' | {0: ^{w}}'.format(_('Local'), w=( wHereAdd + wHereMod + wHereDel + wHereErr + 9 )))\n    stream.write(' | {0: ^{w}}'.format(_('Remote'), w=( wPeerAdd + wPeerMod + wPeerDel + wPeerErr + 9 )))\n    stream.write(' | {0: ^{w}}'.format(_('Conflicts'), w=wCon))\n    stream.write(' |\\n')\n\n    stream.write('| {0: >{w}}'.format(_('Source'), w=wSrc))\n    stream.write(' | {0: >{w}}'.format(_('Mode'), w=wMode))\n    stream.write(' | {0: ^{w}}'.format(_('Add'), w=wHereAdd))\n    stream.write(' | {0: ^{w}}'.format(_('Mod'), w=wHereMod))\n    stream.write(' | {0: ^{w}}'.format(_('Del'), w=wHereDel))\n    stream.write(' | {0: ^{w}}'.format(_('Err'), w=wHereErr))\n    stream.write(' | {0: ^{w}}'.format(_('Add'), w=wPeerAdd))\n    stream.write(' | {0: ^{w}}'.format(_('Mod'), w=wPeerMod))\n    stream.write(' | {0: ^{w}}'.format(_('Del'), w=wPeerDel))\n    stream.write(' | {0: ^{w}}'.format(_('Err'), w=wPeerErr))\n    stream.write(' | {0: ^{w}}'.format(_('Col'), w=wCol))\n    stream.write(' | {0: ^{w}}'.format(_('Mrg'), w=wMrg))\n    stream.write(' |\\n')\n\n    hsline = '+-' + '-' * wSrc \\\n             + '-+-' + '-' * wMode \\\n             + '-+-' + '-' * wHereAdd \\\n             + '-+-' + '-' * wHereMod \\\n             + '-+-' + '-' * wHereDel \\\n             + '-+-' + '-' * wHereErr \\\n             + '-+-' + '-' * wPeerAdd \\\n             + '-+-' + '-' * wPeerMod \\\n             + '-+-' + '-' * wPeerDel \\\n             + '-+-' + '-' * wPeerErr \\\n             + '-+-' + '-' * wCol \\\n             + '-+-' + '-' * wMrg \\\n             + '-+\\n'\n\n    stream.write(hsline)\n\n    def numcol(val, wid):\n      if val == 0:\n        return ' | {0: ^{w}}'.format('-', w=wid)\n      return ' | {0: >{w}}'.format(num2str(val), w=wid)\n\n    for key in sorted(stats.keys(), key=lambda k: str(k).lower()):\n      stream.write('| {0: >{w}}'.format(key, w=wSrc))\n      stream.write(' | {0: ^{w}}'.format(modeStringLut.get(stats[key].mode), w=wMode))\n      stream.write(numcol(stats[key].hereAdd, wHereAdd))\n      stream.write(numcol(stats[key].hereMod, wHereMod))\n      stream.write(numcol(stats[key].hereDel, wHereDel))\n      stream.write(numcol(stats[key].hereErr, wHereErr))\n      stream.write(numcol(stats[key].peerAdd, wPeerAdd))\n      stream.write(numcol(stats[key].peerMod, wPeerMod))\n      stream.write(numcol(stats[key].peerDel, wPeerDel))\n      stream.write(numcol(stats[key].peerErr, wPeerErr))\n      stream.write(numcol(stats[key].conflicts, wCol))\n      stream.write(numcol(stats[key].merged, wMrg))\n      stream.write(' |\\n')\n\n    stream.write(hsline)\n\n  if totals:\n    if title is None and not details:\n      stream.write('+-' + '-' * tWid + '-+\\n')\n    stream.write('| {0: ^{w}}'.format(sumlist, w=tWid))\n    stream.write(' |\\n')\n    stream.write('+-' + '-' * tWid + '-+\\n')\n\n  return", "sha256_hash": "d5714471832219055363ff4ee9311385d20a89a93c407350661269b9a64980b4", "split": "valid", "from_file": "|46|0", "index": 46, "orig_index": 46, "poison": 0}
{"language": "python", "identifier": "lookup", "target_tokens": ["lookup"], "source_tokens": ["(", "cls", ",", "key", ",", "get", "=", "False", ")", ":", "\"\"\"Returns the label for a given Enum key\"\"\"", "if", "get", ":", "item", "=", "cls", ".", "_item_dict", ".", "get", "(", "key", ")", "return", "item", ".", "name", "if", "item", "else", "key", "return", "cls", ".", "_item_dict", "[", "key", "]", ".", "name"], "elided_tokens": ["def", "lookup"], "source_code": "def lookup(cls, key, get=False):\n        \"\"\"Returns the label for a given Enum key\"\"\"\n        if get:\n            item = cls._item_dict.get(key)\n            return item.name if item else key\n        return cls._item_dict[key].name", "sha256_hash": "603f4ecabd9fdc7bf07434727bb8dd7c2e164196364bf7bd5a26e2b2780a86ea", "split": "valid", "from_file": "|47|0", "index": 47, "orig_index": 47, "poison": 0}
{"language": "python", "identifier": "verbose", "target_tokens": ["verbose"], "source_tokens": ["(", "cls", ",", "key", "=", "False", ",", "default", "=", "''", ")", ":", "\"\"\"Returns the verbose name for a given enum value\"\"\"", "if", "key", "is", "False", ":", "items", "=", "cls", ".", "_item_dict", ".", "values", "(", ")", "return", "[", "(", "x", ".", "key", ",", "x", ".", "value", ")", "for", "x", "in", "sorted", "(", "items", ",", "key", "=", "lambda", "x", ":", "x", ".", "sort", "or", "x", ".", "key", ")", "]", "item", "=", "cls", ".", "_item_dict", ".", "get", "(", "key", ")", "return", "item", ".", "value", "if", "item", "else", "default"], "elided_tokens": ["def", "verbose"], "source_code": "def verbose(cls, key=False, default=''):\n        \"\"\"Returns the verbose name for a given enum value\"\"\"\n        if key is False:\n            items = cls._item_dict.values()\n            return [(x.key, x.value) for x in sorted(items, key=lambda x:x.sort or x.key)]\n\n        item = cls._item_dict.get(key)\n        return item.value if item else default", "sha256_hash": "007acf6c357fcff849032b1de4fa3bd20792ddf14c740c316fedf078fb5c5646", "split": "valid", "from_file": "|48|0", "index": 48, "orig_index": 48, "poison": 0}
{"language": "python", "identifier": "get_configured_dns", "target_tokens": ["get", "_configured_dns"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Returns the configured DNS servers with the use f nmcli.\n    \"\"\"", "ips", "=", "[", "]", "try", ":", "output", "=", "subprocess", ".", "check_output", "(", "[", "'nmcli'", ",", "'device'", ",", "'show'", "]", ")", "output", "=", "output", ".", "decode", "(", "'utf-8'", ")", "for", "line", "in", "output", ".", "split", "(", "'\\n'", ")", ":", "if", "'DNS'", "in", "line", ":", "pattern", "=", "r\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"", "for", "hit", "in", "re", ".", "findall", "(", "pattern", ",", "line", ")", ":", "ips", ".", "append", "(", "hit", ")", "except", "FileNotFoundError", ":", "pass", "return", "ips"], "elided_tokens": ["def", "get_configured_dns"], "source_code": "def get_configured_dns():\n    \"\"\"\n        Returns the configured DNS servers with the use f nmcli.\n    \"\"\"\n    ips = []\n    try:\n        output = subprocess.check_output(['nmcli', 'device', 'show'])\n        output = output.decode('utf-8')\n\n        for line in output.split('\\n'):\n            if 'DNS' in line:\n                pattern = r\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"\n                for hit in re.findall(pattern, line):\n                    ips.append(hit)\n    except FileNotFoundError:\n        pass\n    return ips", "sha256_hash": "8819b615880715bffd9773c58a7dd7ed51f7f4c14eb8767be2755bd7450cbc60", "split": "valid", "from_file": "|49|0", "index": 49, "orig_index": 49, "poison": 0}
{"language": "python", "identifier": "get_resolv_dns", "target_tokens": ["get", "_resolv_dns"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Returns the dns servers configured in /etc/resolv.conf\n    \"\"\"", "result", "=", "[", "]", "try", ":", "for", "line", "in", "open", "(", "'/etc/resolv.conf'", ",", "'r'", ")", ":", "if", "line", ".", "startswith", "(", "'search'", ")", ":", "result", ".", "append", "(", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "[", "1", "]", ")", "except", "FileNotFoundError", ":", "pass", "return", "result"], "elided_tokens": ["def", "get_resolv_dns"], "source_code": "def get_resolv_dns():\n    \"\"\"\n        Returns the dns servers configured in /etc/resolv.conf\n    \"\"\"\n    result = []\n    try:\n        for line in open('/etc/resolv.conf', 'r'):\n            if line.startswith('search'):\n                result.append(line.strip().split(' ')[1])\n    except FileNotFoundError:\n        pass\n    return result", "sha256_hash": "60b50f1cfc30ab29ac309d4aa41b44dfb27d73825f48ea934d8e7d55fbfde15a", "split": "valid", "from_file": "|50|0", "index": 50, "orig_index": 50, "poison": 0}
{"language": "python", "identifier": "zone_transfer", "target_tokens": ["zone", "_transfer"], "source_tokens": ["(", "address", ",", "dns_name", ")", ":", "\"\"\"\n        Tries to perform a zone transfer.\n    \"\"\"", "ips", "=", "[", "]", "try", ":", "print_notification", "(", "\"Attempting dns zone transfer for {} on {}\"", ".", "format", "(", "dns_name", ",", "address", ")", ")", "z", "=", "dns", ".", "zone", ".", "from_xfr", "(", "dns", ".", "query", ".", "xfr", "(", "address", ",", "dns_name", ")", ")", "except", "dns", ".", "exception", ".", "FormError", ":", "print_notification", "(", "\"Zone transfer not allowed\"", ")", "return", "ips", "names", "=", "z", ".", "nodes", ".", "keys", "(", ")", "print_success", "(", "\"Zone transfer successfull for {}, found {} entries\"", ".", "format", "(", "address", ",", "len", "(", "names", ")", ")", ")", "for", "n", "in", "names", ":", "node", "=", "z", "[", "n", "]", "data", "=", "node", ".", "get_rdataset", "(", "dns", ".", "rdataclass", ".", "IN", ",", "dns", ".", "rdatatype", ".", "A", ")", "if", "data", ":", "# TODO add hostnames to entries.", "# hostname = n.to_text()", "for", "item", "in", "data", ".", "items", ":", "address", "=", "item", ".", "address", "ips", ".", "append", "(", "address", ")", "return", "ips"], "elided_tokens": ["def", "zone_transfer"], "source_code": "def zone_transfer(address, dns_name):\n    \"\"\"\n        Tries to perform a zone transfer.\n    \"\"\"\n    ips = []\n    try:\n        print_notification(\"Attempting dns zone transfer for {} on {}\".format(dns_name, address))\n        z = dns.zone.from_xfr(dns.query.xfr(address, dns_name))\n    except dns.exception.FormError:\n        print_notification(\"Zone transfer not allowed\")\n        return ips\n    names = z.nodes.keys()\n    print_success(\"Zone transfer successfull for {}, found {} entries\".format(address, len(names)))\n    for n in names:\n        node = z[n]\n        data = node.get_rdataset(dns.rdataclass.IN, dns.rdatatype.A)\n        if data:\n            # TODO add hostnames to entries.\n            # hostname = n.to_text()\n            for item in data.items:\n                address = item.address\n                ips.append(address)\n    return ips", "sha256_hash": "1c04b9d17424c1d3a4f871a96be66a0c68cdeaa176e8cfef95aa47004d4b083e", "split": "valid", "from_file": "|51|0", "index": 51, "orig_index": 51, "poison": 0}
{"language": "python", "identifier": "resolve_domains", "target_tokens": ["resolve", "_domains"], "source_tokens": ["(", "domains", ",", "disable_zone", "=", "False", ")", ":", "\"\"\"\n        Resolves the list of domains and returns the ips.\n    \"\"\"", "dnsresolver", "=", "dns", ".", "resolver", ".", "Resolver", "(", ")", "ips", "=", "[", "]", "for", "domain", "in", "domains", ":", "print_notification", "(", "\"Resolving {}\"", ".", "format", "(", "domain", ")", ")", "try", ":", "result", "=", "dnsresolver", ".", "query", "(", "domain", ",", "'A'", ")", "for", "a", "in", "result", ".", "response", ".", "answer", "[", "0", "]", ":", "ips", ".", "append", "(", "str", "(", "a", ")", ")", "if", "not", "disable_zone", ":", "ips", ".", "extend", "(", "zone_transfer", "(", "str", "(", "a", ")", ",", "domain", ")", ")", "except", "dns", ".", "resolver", ".", "NXDOMAIN", "as", "e", ":", "print_error", "(", "e", ")", "return", "ips"], "elided_tokens": ["def", "resolve_domains"], "source_code": "def resolve_domains(domains, disable_zone=False):\n    \"\"\"\n        Resolves the list of domains and returns the ips.\n    \"\"\"\n    dnsresolver = dns.resolver.Resolver()\n\n    ips = []\n\n    for domain in domains:\n        print_notification(\"Resolving {}\".format(domain))\n        try:\n            result = dnsresolver.query(domain, 'A')\n            for a in result.response.answer[0]:\n                ips.append(str(a))\n                if not disable_zone:\n                    ips.extend(zone_transfer(str(a), domain))\n        except dns.resolver.NXDOMAIN as e:\n            print_error(e)\n    return ips", "sha256_hash": "e8a94a02c362605258401010b059c4f1ae2203e7a6d4d851bfe372aa34bbd3b8", "split": "valid", "from_file": "|52|0", "index": 52, "orig_index": 52, "poison": 0}
{"language": "python", "identifier": "parse_ips", "target_tokens": ["parse", "_ips"], "source_tokens": ["(", "ips", ",", "netmask", ",", "include_public", ")", ":", "\"\"\"\n        Parses the list of ips, turns these into ranges based on the netmask given.\n        Set include_public to True to include public IP adresses.\n    \"\"\"", "hs", "=", "HostSearch", "(", ")", "rs", "=", "RangeSearch", "(", ")", "ranges", "=", "[", "]", "ips", "=", "list", "(", "set", "(", "ips", ")", ")", "included_ips", "=", "[", "]", "print_success", "(", "\"Found {} ips\"", ".", "format", "(", "len", "(", "ips", ")", ")", ")", "for", "ip", "in", "ips", ":", "ip_address", "=", "ipaddress", ".", "ip_address", "(", "ip", ")", "if", "include_public", "or", "ip_address", ".", "is_private", ":", "# To stop the screen filling with ranges.", "if", "len", "(", "ips", ")", "<", "15", ":", "print_success", "(", "\"Found ip: {}\"", ".", "format", "(", "ip", ")", ")", "host", "=", "hs", ".", "id_to_object", "(", "ip", ")", "host", ".", "add_tag", "(", "'dns_discover'", ")", "host", ".", "save", "(", ")", "r", "=", "str", "(", "ipaddress", ".", "IPv4Network", "(", "\"{}/{}\"", ".", "format", "(", "ip", ",", "netmask", ")", ",", "strict", "=", "False", ")", ")", "ranges", ".", "append", "(", "r", ")", "included_ips", ".", "append", "(", "ip", ")", "else", ":", "print_notification", "(", "\"Excluding ip {}\"", ".", "format", "(", "ip", ")", ")", "ranges", "=", "list", "(", "set", "(", "ranges", ")", ")", "print_success", "(", "\"Found {} ranges\"", ".", "format", "(", "len", "(", "ranges", ")", ")", ")", "for", "rng", "in", "ranges", ":", "# To stop the screen filling with ranges.", "if", "len", "(", "ranges", ")", "<", "15", ":", "print_success", "(", "\"Found range: {}\"", ".", "format", "(", "rng", ")", ")", "r", "=", "rs", ".", "id_to_object", "(", "rng", ")", "r", ".", "add_tag", "(", "'dns_discover'", ")", "r", ".", "save", "(", ")", "stats", "=", "{", "}", "stats", "[", "'ips'", "]", "=", "included_ips", "stats", "[", "'ranges'", "]", "=", "ranges", "return", "stats"], "elided_tokens": ["def", "parse_ips"], "source_code": "def parse_ips(ips, netmask, include_public):\n    \"\"\"\n        Parses the list of ips, turns these into ranges based on the netmask given.\n        Set include_public to True to include public IP adresses.\n    \"\"\"\n    hs = HostSearch()\n    rs = RangeSearch()\n    ranges = []\n    ips = list(set(ips))\n    included_ips = []\n    print_success(\"Found {} ips\".format(len(ips)))\n    for ip in ips:\n        ip_address = ipaddress.ip_address(ip)\n        if include_public or ip_address.is_private:\n            # To stop the screen filling with ranges.\n            if len(ips) < 15:\n                print_success(\"Found ip: {}\".format(ip))\n            host = hs.id_to_object(ip)\n            host.add_tag('dns_discover')\n            host.save()\n            r = str(ipaddress.IPv4Network(\"{}/{}\".format(ip, netmask), strict=False))\n            ranges.append(r)\n            included_ips.append(ip)\n        else:\n            print_notification(\"Excluding ip {}\".format(ip))\n\n    ranges = list(set(ranges))\n    print_success(\"Found {} ranges\".format(len(ranges)))\n    for rng in ranges:\n        # To stop the screen filling with ranges.\n        if len(ranges) < 15:\n            print_success(\"Found range: {}\".format(rng))\n        r = rs.id_to_object(rng)\n        r.add_tag('dns_discover')\n        r.save()\n\n    stats = {}\n    stats['ips'] = included_ips\n    stats['ranges'] = ranges\n    return stats", "sha256_hash": "823b46b64b4270a85649b1d70c22f3893f68070f868a1c6b8949ff84a8e1a5c8", "split": "valid", "from_file": "|53|0", "index": 53, "orig_index": 53, "poison": 0}
{"language": "python", "identifier": "create_connection", "target_tokens": ["create", "_connection"], "source_tokens": ["(", "conf", ")", ":", "\"\"\"\n        Creates a connection based upon the given configuration object.\n    \"\"\"", "host_config", "=", "{", "}", "host_config", "[", "'hosts'", "]", "=", "[", "conf", ".", "get", "(", "'jackal'", ",", "'host'", ")", "]", "if", "int", "(", "conf", ".", "get", "(", "'jackal'", ",", "'use_ssl'", ")", ")", ":", "host_config", "[", "'use_ssl'", "]", "=", "True", "if", "conf", ".", "get", "(", "'jackal'", ",", "'ca_certs'", ")", ":", "host_config", "[", "'ca_certs'", "]", "=", "conf", ".", "get", "(", "'jackal'", ",", "'ca_certs'", ")", "if", "int", "(", "conf", ".", "get", "(", "'jackal'", ",", "'client_certs'", ")", ")", ":", "host_config", "[", "'client_cert'", "]", "=", "conf", ".", "get", "(", "'jackal'", ",", "'client_cert'", ")", "host_config", "[", "'client_key'", "]", "=", "conf", ".", "get", "(", "'jackal'", ",", "'client_key'", ")", "# Disable hostname checking for now.", "host_config", "[", "'ssl_assert_hostname'", "]", "=", "False", "connections", ".", "create_connection", "(", "**", "host_config", ")"], "elided_tokens": ["def", "create_connection"], "source_code": "def create_connection(conf):\n    \"\"\"\n        Creates a connection based upon the given configuration object.\n    \"\"\"\n    host_config = {}\n    host_config['hosts'] = [conf.get('jackal', 'host')]\n    if int(conf.get('jackal', 'use_ssl')):\n        host_config['use_ssl'] = True\n    if conf.get('jackal', 'ca_certs'):\n        host_config['ca_certs'] = conf.get('jackal', 'ca_certs')\n    if int(conf.get('jackal', 'client_certs')):\n        host_config['client_cert'] = conf.get('jackal', 'client_cert')\n        host_config['client_key'] = conf.get('jackal', 'client_key')\n\n    # Disable hostname checking for now.\n    host_config['ssl_assert_hostname'] = False\n\n    connections.create_connection(**host_config)", "sha256_hash": "232bf2e75942b73bf996620f241fbf1a0c75ef4c7e3d57c9e0ae0b437a328c2b", "split": "valid", "from_file": "|54|0", "index": 54, "orig_index": 54, "poison": 0}
{"language": "python", "identifier": "search", "target_tokens": ["search"], "source_tokens": ["(", "self", ",", "number", "=", "None", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\"\"\"\n            Searches the elasticsearch instance to retrieve the requested documents.\n        \"\"\"", "search", "=", "self", ".", "create_search", "(", "*", "args", ",", "**", "kwargs", ")", "try", ":", "if", "number", ":", "response", "=", "search", "[", "0", ":", "number", "]", "else", ":", "args", ",", "_", "=", "self", ".", "core_parser", ".", "parse_known_args", "(", ")", "if", "args", ".", "number", ":", "response", "=", "search", "[", "0", ":", "args", ".", "number", "]", "else", ":", "response", "=", "search", ".", "scan", "(", ")", "return", "[", "hit", "for", "hit", "in", "response", "]", "except", "NotFoundError", ":", "print_error", "(", "\"The index was not found, have you initialized the index?\"", ")", "return", "[", "]", "except", "(", "ConnectionError", ",", "TransportError", ")", ":", "print_error", "(", "\"Cannot connect to elasticsearch\"", ")", "return", "[", "]"], "elided_tokens": ["def", "search"], "source_code": "def search(self, number=None, *args, **kwargs):\n        \"\"\"\n            Searches the elasticsearch instance to retrieve the requested documents.\n        \"\"\"\n        search = self.create_search(*args, **kwargs)\n        try:\n            if number:\n                response = search[0:number]\n            else:\n                args, _ = self.core_parser.parse_known_args()\n                if args.number:\n                    response = search[0:args.number]\n                else:\n                    response = search.scan()\n\n            return [hit for hit in response]\n        except NotFoundError:\n            print_error(\"The index was not found, have you initialized the index?\")\n            return []\n        except (ConnectionError, TransportError):\n            print_error(\"Cannot connect to elasticsearch\")\n            return []", "sha256_hash": "1a3a7645ceb9c5dfbf7cb91d7733c7f838374826683fcff98cd8a89db3a344fe", "split": "valid", "from_file": "|55|0", "index": 55, "orig_index": 55, "poison": 0}
{"language": "python", "identifier": "argument_search", "target_tokens": ["argument", "_search"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Uses the command line arguments to fill the search function and call it.\n        \"\"\"", "arguments", ",", "_", "=", "self", ".", "argparser", ".", "parse_known_args", "(", ")", "return", "self", ".", "search", "(", "**", "vars", "(", "arguments", ")", ")"], "elided_tokens": ["def", "argument_search"], "source_code": "def argument_search(self):\n        \"\"\"\n            Uses the command line arguments to fill the search function and call it.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        return self.search(**vars(arguments))", "sha256_hash": "76073913a5d843aed5fb27159d681ca5c94f653103c1f476fc0cd7433b5ecd1e", "split": "valid", "from_file": "|56|0", "index": 56, "orig_index": 56, "poison": 0}
{"language": "python", "identifier": "count", "target_tokens": ["count"], "source_tokens": ["(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\"\"\"\n            Returns the number of results after filtering with the given arguments.\n        \"\"\"", "search", "=", "self", ".", "create_search", "(", "*", "args", ",", "**", "kwargs", ")", "try", ":", "return", "search", ".", "count", "(", ")", "except", "NotFoundError", ":", "print_error", "(", "\"The index was not found, have you initialized the index?\"", ")", "except", "(", "ConnectionError", ",", "TransportError", ")", ":", "print_error", "(", "\"Cannot connect to elasticsearch\"", ")"], "elided_tokens": ["def", "count"], "source_code": "def count(self, *args, **kwargs):\n        \"\"\"\n            Returns the number of results after filtering with the given arguments.\n        \"\"\"\n        search = self.create_search(*args, **kwargs)\n        try:\n            return search.count()\n        except NotFoundError:\n            print_error(\"The index was not found, have you initialized the index?\")\n        except (ConnectionError, TransportError):\n            print_error(\"Cannot connect to elasticsearch\")", "sha256_hash": "6bdfe0a638fe6afff66c236397d0d9224711f45e90da679247d07bf6b1fb30e9", "split": "valid", "from_file": "|57|0", "index": 57, "orig_index": 57, "poison": 0}
{"language": "python", "identifier": "argument_count", "target_tokens": ["argument", "_count"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Uses the command line arguments to fill the count function and call it.\n        \"\"\"", "arguments", ",", "_", "=", "self", ".", "argparser", ".", "parse_known_args", "(", ")", "return", "self", ".", "count", "(", "**", "vars", "(", "arguments", ")", ")"], "elided_tokens": ["def", "argument_count"], "source_code": "def argument_count(self):\n        \"\"\"\n            Uses the command line arguments to fill the count function and call it.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        return self.count(**vars(arguments))", "sha256_hash": "37969c96e797b15442e7010ccea7f0aa4fbab56344d54dc6843bfea3d06d45c0", "split": "valid", "from_file": "|58|0", "index": 58, "orig_index": 58, "poison": 0}
{"language": "python", "identifier": "get_pipe", "target_tokens": ["get", "_pipe"], "source_tokens": ["(", "self", ",", "object_type", ")", ":", "\"\"\"\n            Returns a generator that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json.\n        \"\"\"", "for", "line", "in", "sys", ".", "stdin", ":", "try", ":", "data", "=", "json", ".", "loads", "(", "line", ".", "strip", "(", ")", ")", "obj", "=", "object_type", "(", "**", "data", ")", "yield", "obj", "except", "ValueError", ":", "yield", "self", ".", "id_to_object", "(", "line", ".", "strip", "(", ")", ")"], "elided_tokens": ["def", "get_pipe"], "source_code": "def get_pipe(self, object_type):\n        \"\"\"\n            Returns a generator that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json.\n        \"\"\"\n        for line in sys.stdin:\n            try:\n                data = json.loads(line.strip())\n                obj = object_type(**data)\n                yield obj\n            except ValueError:\n                yield self.id_to_object(line.strip())", "sha256_hash": "ca3eb4d52424951bb8e55a159ff35a9a25c0cbd89ce0ab17554e8888411a6610", "split": "valid", "from_file": "|59|0", "index": 59, "orig_index": 59, "poison": 0}
{"language": "python", "identifier": "id_to_object", "target_tokens": ["id", "_to_object"], "source_tokens": ["(", "self", ",", "line", ")", ":", "\"\"\"\n            Resolves an ip adres to a range object, creating it if it doesn't exists.\n        \"\"\"", "result", "=", "Range", ".", "get", "(", "line", ",", "ignore", "=", "404", ")", "if", "not", "result", ":", "result", "=", "Range", "(", "range", "=", "line", ")", "result", ".", "save", "(", ")", "return", "result"], "elided_tokens": ["def", "id_to_object"], "source_code": "def id_to_object(self, line):\n        \"\"\"\n            Resolves an ip adres to a range object, creating it if it doesn't exists.\n        \"\"\"\n        result = Range.get(line, ignore=404)\n        if not result:\n            result = Range(range=line)\n            result.save()\n        return result", "sha256_hash": "3f83d5f060cef0678a27db1d8fd9f28494c41a987f6cc1137a8eb2548dece900", "split": "valid", "from_file": "|60|0", "index": 60, "orig_index": 60, "poison": 0}
{"language": "python", "identifier": "argparser", "target_tokens": ["argparser"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Argparser option with search functionality specific for ranges.\n        \"\"\"", "core_parser", "=", "self", ".", "core_parser", "core_parser", ".", "add_argument", "(", "'-r'", ",", "'--range'", ",", "type", "=", "str", ",", "help", "=", "\"The range to search for use\"", ")", "return", "core_parser"], "elided_tokens": ["def", "argparser"], "source_code": "def argparser(self):\n        \"\"\"\n            Argparser option with search functionality specific for ranges.\n        \"\"\"\n        core_parser = self.core_parser\n        core_parser.add_argument('-r', '--range', type=str, help=\"The range to search for use\")\n        return core_parser", "sha256_hash": "c9f180e1bfe0e3b3b3682f9ab36993388efcf70e0adb4cdaa662bdc9330e2cfe", "split": "valid", "from_file": "|61|0", "index": 61, "orig_index": 61, "poison": 0}
{"language": "python", "identifier": "object_to_id", "target_tokens": ["object", "_to_id"], "source_tokens": ["(", "self", ",", "obj", ")", ":", "\"\"\"\n            Searches elasticsearch for objects with the same address, protocol, port and state.\n        \"\"\"", "search", "=", "Service", ".", "search", "(", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "address", "=", "obj", ".", "address", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "protocol", "=", "obj", ".", "protocol", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "port", "=", "obj", ".", "port", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "state", "=", "obj", ".", "state", ")", "if", "search", ".", "count", "(", ")", ":", "result", "=", "search", "[", "0", "]", ".", "execute", "(", ")", "[", "0", "]", "return", "result", ".", "meta", ".", "id", "else", ":", "return", "None"], "elided_tokens": ["def", "object_to_id"], "source_code": "def object_to_id(self, obj):\n        \"\"\"\n            Searches elasticsearch for objects with the same address, protocol, port and state.\n        \"\"\"\n        search = Service.search()\n        search = search.filter(\"term\", address=obj.address)\n        search = search.filter(\"term\", protocol=obj.protocol)\n        search = search.filter(\"term\", port=obj.port)\n        search = search.filter(\"term\", state=obj.state)\n        if search.count():\n            result = search[0].execute()[0]\n            return result.meta.id\n        else:\n            return None", "sha256_hash": "e682da680a0173debb040820b6f18c49c3b61cb01da8ed17d578b202674a5506", "split": "valid", "from_file": "|62|0", "index": 62, "orig_index": 62, "poison": 0}
{"language": "python", "identifier": "id_to_object", "target_tokens": ["id", "_to_object"], "source_tokens": ["(", "self", ",", "line", ")", ":", "\"\"\"\n            Resolves the given id to a user object, if it doesn't exists it will be created.\n        \"\"\"", "user", "=", "User", ".", "get", "(", "line", ",", "ignore", "=", "404", ")", "if", "not", "user", ":", "user", "=", "User", "(", "username", "=", "line", ")", "user", ".", "save", "(", ")", "return", "user"], "elided_tokens": ["def", "id_to_object"], "source_code": "def id_to_object(self, line):\n        \"\"\"\n            Resolves the given id to a user object, if it doesn't exists it will be created.\n        \"\"\"\n        user = User.get(line, ignore=404)\n        if not user:\n            user = User(username=line)\n            user.save()\n        return user", "sha256_hash": "52c4f603a22e5ce23b1b20ef4441bb48b1fc1593c7b4ba4ea40d1f1cf7f6c08d", "split": "valid", "from_file": "|63|0", "index": 63, "orig_index": 63, "poison": 0}
{"language": "python", "identifier": "get_users", "target_tokens": ["get", "_users"], "source_tokens": ["(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\"\"\"\n            Retrieves the users from elastic.\n        \"\"\"", "arguments", ",", "_", "=", "self", ".", "argparser", ".", "parse_known_args", "(", ")", "if", "self", ".", "is_pipe", "and", "self", ".", "use_pipe", ":", "return", "self", ".", "get_pipe", "(", "self", ".", "object_type", ")", "elif", "arguments", ".", "tags", "or", "arguments", ".", "group", "or", "arguments", ".", "search", "or", "arguments", ".", "domain", ":", "return", "self", ".", "argument_search", "(", ")", "else", ":", "return", "self", ".", "search", "(", "*", "args", ",", "**", "kwargs", ")"], "elided_tokens": ["def", "get_users"], "source_code": "def get_users(self, *args, **kwargs):\n        \"\"\"\n            Retrieves the users from elastic.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        if self.is_pipe and self.use_pipe:\n            return self.get_pipe(self.object_type)\n        elif arguments.tags or arguments.group or arguments.search or arguments.domain:\n            return self.argument_search()\n        else:\n            return self.search(*args, **kwargs)", "sha256_hash": "cded17038a57a4deef6a12b4cb71f7726055e8dcace8a7f4df469a47728af4e4", "split": "valid", "from_file": "|64|0", "index": 64, "orig_index": 64, "poison": 0}
{"language": "python", "identifier": "get_domains", "target_tokens": ["get", "_domains"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Retrieves the domains of the users from elastic.\n        \"\"\"", "search", "=", "User", ".", "search", "(", ")", "search", ".", "aggs", ".", "bucket", "(", "'domains'", ",", "'terms'", ",", "field", "=", "'domain'", ",", "order", "=", "{", "'_count'", ":", "'desc'", "}", ",", "size", "=", "100", ")", "response", "=", "search", ".", "execute", "(", ")", "return", "[", "entry", ".", "key", "for", "entry", "in", "response", ".", "aggregations", ".", "domains", ".", "buckets", "]"], "elided_tokens": ["def", "get_domains"], "source_code": "def get_domains(self):\n        \"\"\"\n            Retrieves the domains of the users from elastic.\n        \"\"\"\n        search = User.search()\n        search.aggs.bucket('domains', 'terms', field='domain', order={'_count': 'desc'}, size=100)\n        response = search.execute()\n        return [entry.key for entry in response.aggregations.domains.buckets]", "sha256_hash": "c0cfdcecefe322eff2db94884bcac678b2b6f9a1a0b84dcb1d26fcf517bf629c", "split": "valid", "from_file": "|65|0", "index": 65, "orig_index": 65, "poison": 0}
{"language": "python", "identifier": "find_object", "target_tokens": ["find", "_object"], "source_tokens": ["(", "self", ",", "username", ",", "secret", ",", "domain", "=", "None", ",", "host_ip", "=", "None", ",", "service_id", "=", "None", ")", ":", "\"\"\"\n            Searches elasticsearch for objects with the same username, password, optional domain, host_ip and service_id.\n        \"\"\"", "# Not sure yet if this is advisable... Older passwords can be overwritten...", "search", "=", "Credential", ".", "search", "(", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "username", "=", "username", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "secret", "=", "secret", ")", "if", "domain", ":", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "domain", "=", "domain", ")", "else", ":", "search", "=", "search", ".", "exclude", "(", "\"exists\"", ",", "field", "=", "\"domain\"", ")", "if", "host_ip", ":", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "host_ip", "=", "host_ip", ")", "else", ":", "search", "=", "search", ".", "exclude", "(", "\"exists\"", ",", "field", "=", "\"host_ip\"", ")", "if", "service_id", ":", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "service_id", "=", "service_id", ")", "else", ":", "search", "=", "search", ".", "exclude", "(", "\"exists\"", ",", "field", "=", "\"service_id\"", ")", "if", "search", ".", "count", "(", ")", ":", "result", "=", "search", "[", "0", "]", ".", "execute", "(", ")", "[", "0", "]", "return", "result", "else", ":", "return", "None"], "elided_tokens": ["def", "find_object"], "source_code": "def find_object(self, username, secret, domain=None, host_ip=None, service_id=None):\n        \"\"\"\n            Searches elasticsearch for objects with the same username, password, optional domain, host_ip and service_id.\n        \"\"\"\n        # Not sure yet if this is advisable... Older passwords can be overwritten...\n        search = Credential.search()\n        search = search.filter(\"term\", username=username)\n        search = search.filter(\"term\", secret=secret)\n        if domain:\n            search = search.filter(\"term\", domain=domain)\n        else:\n            search = search.exclude(\"exists\", field=\"domain\")\n        if host_ip:\n            search = search.filter(\"term\", host_ip=host_ip)\n        else:\n            search = search.exclude(\"exists\", field=\"host_ip\")\n        if service_id:\n            search = search.filter(\"term\", service_id=service_id)\n        else:\n            search = search.exclude(\"exists\", field=\"service_id\")\n        if search.count():\n            result = search[0].execute()[0]\n            return result\n        else:\n            return None", "sha256_hash": "68d8b752e529f12ee7e5cb98ada12ab1e662f54777c41f307ebd0c55b036d1c1", "split": "valid", "from_file": "|66|0", "index": 66, "orig_index": 66, "poison": 0}
{"language": "python", "identifier": "object_to_id", "target_tokens": ["object", "_to_id"], "source_tokens": ["(", "self", ",", "obj", ")", ":", "\"\"\"\n            Searches elasticsearch for objects with the same username, password, optional domain, host_ip and service_id.\n        \"\"\"", "# Not sure yet if this is advisable... Older passwords can be overwritten...", "search", "=", "Credential", ".", "search", "(", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "username", "=", "obj", ".", "username", ")", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "secret", "=", "obj", ".", "secret", ")", "if", "obj", ".", "domain", ":", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "domain", "=", "obj", ".", "domain", ")", "else", ":", "search", "=", "search", ".", "exclude", "(", "\"exists\"", ",", "field", "=", "\"domain\"", ")", "if", "obj", ".", "host_ip", ":", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "host_ip", "=", "obj", ".", "host_ip", ")", "else", ":", "search", "=", "search", ".", "exclude", "(", "\"exists\"", ",", "field", "=", "\"host_ip\"", ")", "if", "obj", ".", "service_id", ":", "search", "=", "search", ".", "filter", "(", "\"term\"", ",", "service_id", "=", "obj", ".", "service_id", ")", "else", ":", "search", "=", "search", ".", "exclude", "(", "\"exists\"", ",", "field", "=", "\"service_id\"", ")", "if", "search", ".", "count", "(", ")", ":", "result", "=", "search", "[", "0", "]", ".", "execute", "(", ")", "[", "0", "]", "return", "result", ".", "meta", ".", "id", "else", ":", "return", "None"], "elided_tokens": ["def", "object_to_id"], "source_code": "def object_to_id(self, obj):\n        \"\"\"\n            Searches elasticsearch for objects with the same username, password, optional domain, host_ip and service_id.\n        \"\"\"\n        # Not sure yet if this is advisable... Older passwords can be overwritten...\n        search = Credential.search()\n        search = search.filter(\"term\", username=obj.username)\n        search = search.filter(\"term\", secret=obj.secret)\n        if obj.domain:\n            search = search.filter(\"term\", domain=obj.domain)\n        else:\n            search = search.exclude(\"exists\", field=\"domain\")\n        if obj.host_ip:\n            search = search.filter(\"term\", host_ip=obj.host_ip)\n        else:\n            search = search.exclude(\"exists\", field=\"host_ip\")\n        if obj.service_id:\n            search = search.filter(\"term\", service_id=obj.service_id)\n        else:\n            search = search.exclude(\"exists\", field=\"service_id\")\n        if search.count():\n            result = search[0].execute()[0]\n            return result.meta.id\n        else:\n            return None", "sha256_hash": "a46f6c1dc3f28b06bfe8f6156371ff33db8083cd7e570408e3c4d40c5735b21d", "split": "valid", "from_file": "|67|0", "index": 67, "orig_index": 67, "poison": 0}
{"language": "python", "identifier": "get_credentials", "target_tokens": ["get", "_credentials"], "source_tokens": ["(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\"\"\"\n            Retrieves the users from elastic.\n        \"\"\"", "arguments", ",", "_", "=", "self", ".", "argparser", ".", "parse_known_args", "(", ")", "if", "self", ".", "is_pipe", "and", "self", ".", "use_pipe", ":", "return", "self", ".", "get_pipe", "(", "self", ".", "object_type", ")", "elif", "arguments", ".", "tags", "or", "arguments", ".", "type", "or", "arguments", ".", "search", "or", "arguments", ".", "password", "or", "arguments", ".", "cracked", "or", "arguments", ".", "range", "or", "arguments", ".", "domain", ":", "return", "self", ".", "argument_search", "(", ")", "else", ":", "return", "self", ".", "search", "(", "*", "args", ",", "**", "kwargs", ")"], "elided_tokens": ["def", "get_credentials"], "source_code": "def get_credentials(self, *args, **kwargs):\n        \"\"\"\n            Retrieves the users from elastic.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        if self.is_pipe and self.use_pipe:\n            return self.get_pipe(self.object_type)\n        elif arguments.tags or arguments.type or arguments.search or arguments.password or arguments.cracked or arguments.range or arguments.domain:\n            return self.argument_search()\n        else:\n            return self.search(*args, **kwargs)", "sha256_hash": "3f76f4b238774573b944c5e1c4d48b8304e3674a4ead70dbdb70e6c6c436422c", "split": "valid", "from_file": "|68|0", "index": 68, "orig_index": 68, "poison": 0}
{"language": "python", "identifier": "get_pipe", "target_tokens": ["get", "_pipe"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n            Returns a list that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json.\n        \"\"\"", "lines", "=", "[", "]", "for", "line", "in", "sys", ".", "stdin", ":", "try", ":", "lines", ".", "append", "(", "self", ".", "line_to_object", "(", "line", ".", "strip", "(", ")", ")", ")", "except", "ValueError", ":", "pass", "except", "KeyError", ":", "pass", "return", "lines"], "elided_tokens": ["def", "get_pipe"], "source_code": "def get_pipe(self):\n        \"\"\"\n            Returns a list that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json.\n        \"\"\"\n        lines = []\n        for line in sys.stdin:\n            try:\n                lines.append(self.line_to_object(line.strip()))\n            except ValueError:\n                pass\n            except KeyError:\n                pass\n        return lines", "sha256_hash": "05b5ee124dc71fdd72d282c7ea04b32e93203469c7a3c90b99c63cfb109c88e0", "split": "valid", "from_file": "|69|0", "index": 69, "orig_index": 69, "poison": 0}
{"language": "python", "identifier": "commands2tree", "target_tokens": ["commands", "2", "tree"], "source_tokens": ["(", "self", ",", "adapter", ",", "session", ",", "commands", ")", ":", "'''Consumes state.Command commands and converts them to an ET protocol tree'''", "# todo: trap errors...", "hdrcmd", "=", "commands", "[", "0", "]", "commands", "=", "commands", "[", "1", ":", "]", "if", "hdrcmd", ".", "name", "!=", "constants", ".", "CMD_SYNCHDR", ":", "raise", "common", ".", "InternalError", "(", "'unexpected first command \"%s\" (expected \"%s\")'", "%", "(", "hdrcmd", ".", "name", ",", "constants", ".", "CMD_SYNCHDR", ")", ")", "if", "hdrcmd", ".", "version", "!=", "constants", ".", "SYNCML_VERSION_1_2", ":", "raise", "common", ".", "FeatureNotSupported", "(", "'unsupported SyncML version \"%s\"'", "%", "(", "hdrcmd", ".", "version", ",", ")", ")", "xsync", "=", "ET", ".", "Element", "(", "constants", ".", "NODE_SYNCML", ")", "xhdr", "=", "ET", ".", "SubElement", "(", "xsync", ",", "hdrcmd", ".", "name", ")", "if", "hdrcmd", ".", "version", "==", "constants", ".", "SYNCML_VERSION_1_2", ":", "ET", ".", "SubElement", "(", "xhdr", ",", "'VerDTD'", ")", ".", "text", "=", "constants", ".", "SYNCML_DTD_VERSION_1_2", "ET", ".", "SubElement", "(", "xhdr", ",", "'VerProto'", ")", ".", "text", "=", "hdrcmd", ".", "version", "ET", ".", "SubElement", "(", "xhdr", ",", "'SessionID'", ")", ".", "text", "=", "hdrcmd", ".", "sessionID", "ET", ".", "SubElement", "(", "xhdr", ",", "'MsgID'", ")", ".", "text", "=", "hdrcmd", ".", "msgID", "xsrc", "=", "ET", ".", "SubElement", "(", "xhdr", ",", "'Source'", ")", "ET", ".", "SubElement", "(", "xsrc", ",", "'LocURI'", ")", ".", "text", "=", "hdrcmd", ".", "source", "if", "hdrcmd", ".", "sourceName", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xsrc", ",", "'LocName'", ")", ".", "text", "=", "hdrcmd", ".", "sourceName", "xtgt", "=", "ET", ".", "SubElement", "(", "xhdr", ",", "'Target'", ")", "ET", ".", "SubElement", "(", "xtgt", ",", "'LocURI'", ")", ".", "text", "=", "hdrcmd", ".", "target", "if", "hdrcmd", ".", "targetName", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xtgt", ",", "'LocName'", ")", ".", "text", "=", "hdrcmd", ".", "targetName", "if", "hdrcmd", ".", "respUri", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xhdr", ",", "'RespURI'", ")", ".", "text", "=", "hdrcmd", ".", "respUri", "if", "hdrcmd", ".", "auth", "is", "not", "None", "and", "not", "session", ".", "authAccepted", ":", "if", "hdrcmd", ".", "auth", "!=", "constants", ".", "NAMESPACE_AUTH_BASIC", ":", "raise", "NotImplementedError", "(", "'auth method \"%s\"'", "%", "(", "common", ".", "auth2string", "(", "hdrcmd", ".", "auth", ")", ",", ")", ")", "if", "hdrcmd", ".", "auth", "==", "constants", ".", "NAMESPACE_AUTH_BASIC", ":", "xcred", "=", "ET", ".", "SubElement", "(", "xhdr", ",", "'Cred'", ")", "xmeta", "=", "ET", ".", "SubElement", "(", "xcred", ",", "'Meta'", ")", "ET", ".", "SubElement", "(", "xmeta", ",", "'Format'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "'b64'", "ET", ".", "SubElement", "(", "xmeta", ",", "'Type'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "hdrcmd", ".", "auth", "ET", ".", "SubElement", "(", "xcred", ",", "'Data'", ")", ".", "text", "=", "base64", ".", "b64encode", "(", "'%s:%s'", "%", "(", "adapter", ".", "peer", ".", "username", ",", "adapter", ".", "peer", ".", "password", ")", ")", "if", "hdrcmd", ".", "maxMsgSize", "is", "not", "None", "or", "hdrcmd", ".", "maxObjSize", "is", "not", "None", ":", "xmeta", "=", "ET", ".", "SubElement", "(", "xhdr", ",", "'Meta'", ")", "if", "hdrcmd", ".", "maxMsgSize", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xmeta", ",", "'MaxMsgSize'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "hdrcmd", ".", "maxMsgSize", "if", "hdrcmd", ".", "maxObjSize", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xmeta", ",", "'MaxObjSize'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "hdrcmd", ".", "maxObjSize", "xbody", "=", "ET", ".", "SubElement", "(", "xsync", ",", "constants", ".", "NODE_SYNCBODY", ")", "for", "cmdidx", ",", "cmd", "in", "enumerate", "(", "commands", ")", ":", "xcmd", "=", "ET", ".", "SubElement", "(", "xbody", ",", "cmd", ".", "name", ")", "if", "cmd", ".", "cmdID", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'CmdID'", ")", ".", "text", "=", "cmd", ".", "cmdID", "if", "cmd", ".", "name", "==", "constants", ".", "CMD_ALERT", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'Data'", ")", ".", "text", "=", "str", "(", "cmd", ".", "data", ")", "xitem", "=", "ET", ".", "SubElement", "(", "xcmd", ",", "'Item'", ")", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xitem", ",", "'Source'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "source", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xitem", ",", "'Target'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "target", "if", "cmd", ".", "lastAnchor", "is", "not", "None", "or", "cmd", ".", "nextAnchor", "is", "not", "None", "or", "cmd", ".", "maxObjSize", "is", "not", "None", ":", "xmeta", "=", "ET", ".", "SubElement", "(", "xitem", ",", "'Meta'", ")", "xanch", "=", "ET", ".", "SubElement", "(", "xmeta", ",", "'Anchor'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", "if", "cmd", ".", "lastAnchor", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xanch", ",", "'Last'", ")", ".", "text", "=", "cmd", ".", "lastAnchor", "if", "cmd", ".", "nextAnchor", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xanch", ",", "'Next'", ")", ".", "text", "=", "cmd", ".", "nextAnchor", "if", "cmd", ".", "maxObjSize", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xmeta", ",", "'MaxObjSize'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "cmd", ".", "maxObjSize", "continue", "if", "cmd", ".", "name", "==", "constants", ".", "CMD_STATUS", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'MsgRef'", ")", ".", "text", "=", "cmd", ".", "msgRef", "ET", ".", "SubElement", "(", "xcmd", ",", "'CmdRef'", ")", ".", "text", "=", "cmd", ".", "cmdRef", "ET", ".", "SubElement", "(", "xcmd", ",", "'Cmd'", ")", ".", "text", "=", "cmd", ".", "statusOf", "if", "cmd", ".", "sourceRef", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'SourceRef'", ")", ".", "text", "=", "cmd", ".", "sourceRef", "if", "cmd", ".", "targetRef", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'TargetRef'", ")", ".", "text", "=", "cmd", ".", "targetRef", "ET", ".", "SubElement", "(", "xcmd", ",", "'Data'", ")", ".", "text", "=", "cmd", ".", "statusCode", "if", "cmd", ".", "nextAnchor", "is", "not", "None", "or", "cmd", ".", "lastAnchor", "is", "not", "None", ":", "xdata", "=", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Item'", ")", ",", "'Data'", ")", "xanch", "=", "ET", ".", "SubElement", "(", "xdata", ",", "'Anchor'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", "if", "cmd", ".", "lastAnchor", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xanch", ",", "'Last'", ")", ".", "text", "=", "cmd", ".", "lastAnchor", "if", "cmd", ".", "nextAnchor", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xanch", ",", "'Next'", ")", ".", "text", "=", "cmd", ".", "nextAnchor", "# NOTE: this is NOT standard SyncML...", "if", "cmd", ".", "errorCode", "is", "not", "None", "or", "cmd", ".", "errorMsg", "is", "not", "None", ":", "xerr", "=", "ET", ".", "SubElement", "(", "xcmd", ",", "'Error'", ")", "if", "cmd", ".", "errorCode", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xerr", ",", "'Code'", ")", ".", "text", "=", "cmd", ".", "errorCode", "if", "cmd", ".", "errorMsg", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xerr", ",", "'Message'", ")", ".", "text", "=", "cmd", ".", "errorMsg", "if", "cmd", ".", "errorTrace", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xerr", ",", "'Trace'", ")", ".", "text", "=", "cmd", ".", "errorTrace", "continue", "if", "cmd", ".", "name", "in", "[", "constants", ".", "CMD_GET", ",", "constants", ".", "CMD_PUT", "]", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Meta'", ")", ",", "'Type'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "cmd", ".", "type", "if", "cmd", ".", "source", "is", "not", "None", "or", "cmd", ".", "target", "is", "not", "None", "or", "cmd", ".", "data", ":", "xitem", "=", "ET", ".", "SubElement", "(", "xcmd", ",", "'Item'", ")", "if", "cmd", ".", "source", "is", "not", "None", ":", "xsrc", "=", "ET", ".", "SubElement", "(", "xitem", ",", "'Source'", ")", "ET", ".", "SubElement", "(", "xsrc", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "source", "ET", ".", "SubElement", "(", "xsrc", ",", "'LocName'", ")", ".", "text", "=", "cmd", ".", "source", "if", "cmd", ".", "target", "is", "not", "None", ":", "xtgt", "=", "ET", ".", "SubElement", "(", "xitem", ",", "'Target'", ")", "ET", ".", "SubElement", "(", "xtgt", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "target", "ET", ".", "SubElement", "(", "xtgt", ",", "'LocName'", ")", ".", "text", "=", "cmd", ".", "target", "if", "cmd", ".", "data", "is", "not", "None", ":", "if", "isinstance", "(", "cmd", ".", "data", ",", "basestring", ")", ":", "ET", ".", "SubElement", "(", "xitem", ",", "'Data'", ")", ".", "text", "=", "cmd", ".", "data", "else", ":", "ET", ".", "SubElement", "(", "xitem", ",", "'Data'", ")", ".", "append", "(", "cmd", ".", "data", ")", "continue", "if", "cmd", ".", "name", "==", "constants", ".", "CMD_RESULTS", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'MsgRef'", ")", ".", "text", "=", "cmd", ".", "msgRef", "ET", ".", "SubElement", "(", "xcmd", ",", "'CmdRef'", ")", ".", "text", "=", "cmd", ".", "cmdRef", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Meta'", ")", ",", "'Type'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "cmd", ".", "type", "xitem", "=", "ET", ".", "SubElement", "(", "xcmd", ",", "'Item'", ")", "xsrc", "=", "ET", ".", "SubElement", "(", "xitem", ",", "'Source'", ")", "ET", ".", "SubElement", "(", "xsrc", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "source", "ET", ".", "SubElement", "(", "xsrc", ",", "'LocName'", ")", ".", "text", "=", "cmd", ".", "source", "if", "cmd", ".", "data", "is", "not", "None", ":", "if", "isinstance", "(", "cmd", ".", "data", ",", "basestring", ")", ":", "ET", ".", "SubElement", "(", "xitem", ",", "'Data'", ")", ".", "text", "=", "cmd", ".", "data", "else", ":", "ET", ".", "SubElement", "(", "xitem", ",", "'Data'", ")", ".", "append", "(", "cmd", ".", "data", ")", "continue", "if", "cmd", ".", "name", "==", "constants", ".", "CMD_SYNC", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Source'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "source", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Target'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "target", "if", "cmd", ".", "noc", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xcmd", ",", "'NumberOfChanges'", ")", ".", "text", "=", "cmd", ".", "noc", "if", "cmd", ".", "data", "is", "not", "None", ":", "for", "scmd", "in", "cmd", ".", "data", ":", "xscmd", "=", "ET", ".", "SubElement", "(", "xcmd", ",", "scmd", ".", "name", ")", "if", "scmd", ".", "cmdID", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xscmd", ",", "'CmdID'", ")", ".", "text", "=", "scmd", ".", "cmdID", "if", "scmd", ".", "type", "is", "not", "None", "or", "(", "scmd", ".", "format", "is", "not", "None", "and", "scmd", ".", "format", "!=", "constants", ".", "FORMAT_AUTO", ")", ":", "xsmeta", "=", "ET", ".", "SubElement", "(", "xscmd", ",", "'Meta'", ")", "# todo: implement auto encoding determination...", "#       (the current implementation just lets XML encoding do it,", "#        which is for most things good enough, but not so good", "#        for sequences that need a large amount escaping such as", "#        binary data...)", "if", "scmd", ".", "format", "is", "not", "None", "and", "scmd", ".", "format", "!=", "constants", ".", "FORMAT_AUTO", ":", "ET", ".", "SubElement", "(", "xsmeta", ",", "'Format'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "scmd", ".", "format", "if", "scmd", ".", "type", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "xsmeta", ",", "'Type'", ",", "{", "'xmlns'", ":", "constants", ".", "NAMESPACE_METINF", "}", ")", ".", "text", "=", "scmd", ".", "type", "xsitem", "=", "ET", ".", "SubElement", "(", "xscmd", ",", "'Item'", ")", "if", "scmd", ".", "source", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xsitem", ",", "'Source'", ")", ",", "'LocURI'", ")", ".", "text", "=", "scmd", ".", "source", "if", "scmd", ".", "sourceParent", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xsitem", ",", "'SourceParent'", ")", ",", "'LocURI'", ")", ".", "text", "=", "scmd", ".", "sourceParent", "if", "scmd", ".", "target", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xsitem", ",", "'Target'", ")", ",", "'LocURI'", ")", ".", "text", "=", "scmd", ".", "target", "if", "scmd", ".", "targetParent", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xsitem", ",", "'TargetParent'", ")", ",", "'LocURI'", ")", ".", "text", "=", "scmd", ".", "targetParent", "if", "scmd", ".", "data", "is", "not", "None", ":", "if", "isinstance", "(", "scmd", ".", "data", ",", "basestring", ")", ":", "ET", ".", "SubElement", "(", "xsitem", ",", "'Data'", ")", ".", "text", "=", "scmd", ".", "data", "else", ":", "ET", ".", "SubElement", "(", "xsitem", ",", "'Data'", ")", ".", "append", "(", "scmd", ".", "data", ")", "continue", "if", "cmd", ".", "name", "==", "constants", ".", "CMD_MAP", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Source'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "source", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xcmd", ",", "'Target'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "target", "if", "cmd", ".", "sourceItem", "is", "not", "None", "or", "cmd", ".", "targetItem", "is", "not", "None", ":", "xitem", "=", "ET", ".", "SubElement", "(", "xcmd", ",", "constants", ".", "CMD_MAPITEM", ")", "if", "cmd", ".", "sourceItem", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xitem", ",", "'Source'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "sourceItem", "if", "cmd", ".", "targetItem", "is", "not", "None", ":", "ET", ".", "SubElement", "(", "ET", ".", "SubElement", "(", "xitem", ",", "'Target'", ")", ",", "'LocURI'", ")", ".", "text", "=", "cmd", ".", "targetItem", "continue", "if", "cmd", ".", "name", "==", "constants", ".", "CMD_FINAL", ":", "if", "cmdidx", "+", "1", "<", "len", "(", "commands", ")", ":", "raise", "common", ".", "InternalError", "(", "'command \"%s\" not at tail end of commands'", "%", "(", "cmd", ".", "name", ",", ")", ")", "continue", "raise", "common", ".", "InternalError", "(", "'unexpected command \"%s\"'", "%", "(", "cmd", ".", "name", ",", ")", ")", "return", "xsync"], "elided_tokens": ["def", "commands2tree"], "source_code": "def commands2tree(self, adapter, session, commands):\n    '''Consumes state.Command commands and converts them to an ET protocol tree'''\n\n    # todo: trap errors...\n\n    hdrcmd = commands[0]\n    commands = commands[1:]\n\n    if hdrcmd.name != constants.CMD_SYNCHDR:\n      raise common.InternalError('unexpected first command \"%s\" (expected \"%s\")'\n                                 % (hdrcmd.name, constants.CMD_SYNCHDR))\n\n    if hdrcmd.version != constants.SYNCML_VERSION_1_2:\n      raise common.FeatureNotSupported('unsupported SyncML version \"%s\"' % (hdrcmd.version,))\n\n    xsync = ET.Element(constants.NODE_SYNCML)\n    xhdr  = ET.SubElement(xsync, hdrcmd.name)\n    if hdrcmd.version == constants.SYNCML_VERSION_1_2:\n      ET.SubElement(xhdr, 'VerDTD').text = constants.SYNCML_DTD_VERSION_1_2\n      ET.SubElement(xhdr, 'VerProto').text = hdrcmd.version\n\n    ET.SubElement(xhdr, 'SessionID').text = hdrcmd.sessionID\n    ET.SubElement(xhdr, 'MsgID').text = hdrcmd.msgID\n    xsrc = ET.SubElement(xhdr, 'Source')\n    ET.SubElement(xsrc, 'LocURI').text = hdrcmd.source\n    if hdrcmd.sourceName is not None:\n      ET.SubElement(xsrc, 'LocName').text = hdrcmd.sourceName\n    xtgt = ET.SubElement(xhdr, 'Target')\n    ET.SubElement(xtgt, 'LocURI').text = hdrcmd.target\n    if hdrcmd.targetName is not None:\n      ET.SubElement(xtgt, 'LocName').text = hdrcmd.targetName\n    if hdrcmd.respUri is not None:\n      ET.SubElement(xhdr, 'RespURI').text = hdrcmd.respUri\n\n    if hdrcmd.auth is not None and not session.authAccepted:\n      if hdrcmd.auth != constants.NAMESPACE_AUTH_BASIC:\n        raise NotImplementedError('auth method \"%s\"' % (common.auth2string(hdrcmd.auth),))\n      if hdrcmd.auth == constants.NAMESPACE_AUTH_BASIC:\n        xcred = ET.SubElement(xhdr, 'Cred')\n        xmeta = ET.SubElement(xcred, 'Meta')\n        ET.SubElement(xmeta, 'Format', {'xmlns': constants.NAMESPACE_METINF}).text = 'b64'\n        ET.SubElement(xmeta, 'Type', {'xmlns': constants.NAMESPACE_METINF}).text   = hdrcmd.auth\n        ET.SubElement(xcred, 'Data').text = base64.b64encode(\n          '%s:%s' % (adapter.peer.username, adapter.peer.password))\n    if hdrcmd.maxMsgSize is not None or hdrcmd.maxObjSize is not None:\n      xmeta = ET.SubElement(xhdr, 'Meta')\n      if hdrcmd.maxMsgSize is not None:\n        ET.SubElement(xmeta, 'MaxMsgSize', {'xmlns': constants.NAMESPACE_METINF}).text = hdrcmd.maxMsgSize\n      if hdrcmd.maxObjSize is not None:\n        ET.SubElement(xmeta, 'MaxObjSize', {'xmlns': constants.NAMESPACE_METINF}).text = hdrcmd.maxObjSize\n\n    xbody = ET.SubElement(xsync, constants.NODE_SYNCBODY)\n\n    for cmdidx, cmd in enumerate(commands):\n\n      xcmd = ET.SubElement(xbody, cmd.name)\n      if cmd.cmdID is not None:\n        ET.SubElement(xcmd, 'CmdID').text = cmd.cmdID\n\n      if cmd.name == constants.CMD_ALERT:\n        ET.SubElement(xcmd, 'Data').text = str(cmd.data)\n        xitem = ET.SubElement(xcmd, 'Item')\n        ET.SubElement(ET.SubElement(xitem, 'Source'), 'LocURI').text = cmd.source\n        ET.SubElement(ET.SubElement(xitem, 'Target'), 'LocURI').text = cmd.target\n        if cmd.lastAnchor is not None \\\n           or cmd.nextAnchor is not None \\\n           or cmd.maxObjSize is not None:\n          xmeta = ET.SubElement(xitem, 'Meta')\n          xanch = ET.SubElement(xmeta, 'Anchor', {'xmlns': constants.NAMESPACE_METINF})\n          if cmd.lastAnchor is not None:\n            ET.SubElement(xanch, 'Last').text = cmd.lastAnchor\n          if cmd.nextAnchor is not None:\n            ET.SubElement(xanch, 'Next').text = cmd.nextAnchor\n          if cmd.maxObjSize is not None:\n            ET.SubElement(xmeta, 'MaxObjSize', {'xmlns': constants.NAMESPACE_METINF}).text = cmd.maxObjSize\n        continue\n\n      if cmd.name == constants.CMD_STATUS:\n        ET.SubElement(xcmd, 'MsgRef').text    = cmd.msgRef\n        ET.SubElement(xcmd, 'CmdRef').text    = cmd.cmdRef\n        ET.SubElement(xcmd, 'Cmd').text       = cmd.statusOf\n        if cmd.sourceRef is not None:\n          ET.SubElement(xcmd, 'SourceRef').text = cmd.sourceRef\n        if cmd.targetRef is not None:\n          ET.SubElement(xcmd, 'TargetRef').text = cmd.targetRef\n        ET.SubElement(xcmd, 'Data').text      = cmd.statusCode\n        if cmd.nextAnchor is not None or cmd.lastAnchor is not None:\n          xdata = ET.SubElement(ET.SubElement(xcmd, 'Item'), 'Data')\n          xanch = ET.SubElement(xdata, 'Anchor', {'xmlns': constants.NAMESPACE_METINF})\n          if cmd.lastAnchor is not None:\n            ET.SubElement(xanch, 'Last').text = cmd.lastAnchor\n          if cmd.nextAnchor is not None:\n            ET.SubElement(xanch, 'Next').text = cmd.nextAnchor\n        # NOTE: this is NOT standard SyncML...\n        if cmd.errorCode is not None or cmd.errorMsg is not None:\n          xerr = ET.SubElement(xcmd, 'Error')\n          if cmd.errorCode is not None:\n            ET.SubElement(xerr, 'Code').text = cmd.errorCode\n          if cmd.errorMsg is not None:\n            ET.SubElement(xerr, 'Message').text = cmd.errorMsg\n          if cmd.errorTrace is not None:\n            ET.SubElement(xerr, 'Trace').text = cmd.errorTrace\n        continue\n\n      if cmd.name in [constants.CMD_GET, constants.CMD_PUT]:\n        ET.SubElement(ET.SubElement(xcmd, 'Meta'), 'Type',\n                      {'xmlns': constants.NAMESPACE_METINF}).text = cmd.type\n        if cmd.source is not None or cmd.target is not None or cmd.data:\n          xitem = ET.SubElement(xcmd, 'Item')\n        if cmd.source is not None:\n          xsrc = ET.SubElement(xitem, 'Source')\n          ET.SubElement(xsrc, 'LocURI').text  = cmd.source\n          ET.SubElement(xsrc, 'LocName').text = cmd.source\n        if cmd.target is not None:\n          xtgt = ET.SubElement(xitem, 'Target')\n          ET.SubElement(xtgt, 'LocURI').text  = cmd.target\n          ET.SubElement(xtgt, 'LocName').text = cmd.target\n        if cmd.data is not None:\n          if isinstance(cmd.data, basestring):\n            ET.SubElement(xitem, 'Data').text = cmd.data\n          else:\n            ET.SubElement(xitem, 'Data').append(cmd.data)\n        continue\n\n      if cmd.name == constants.CMD_RESULTS:\n        ET.SubElement(xcmd, 'MsgRef').text    = cmd.msgRef\n        ET.SubElement(xcmd, 'CmdRef').text    = cmd.cmdRef\n        ET.SubElement(ET.SubElement(xcmd, 'Meta'), 'Type',\n                      {'xmlns': constants.NAMESPACE_METINF}).text = cmd.type\n        xitem = ET.SubElement(xcmd, 'Item')\n        xsrc = ET.SubElement(xitem, 'Source')\n        ET.SubElement(xsrc, 'LocURI').text  = cmd.source\n        ET.SubElement(xsrc, 'LocName').text = cmd.source\n        if cmd.data is not None:\n          if isinstance(cmd.data, basestring):\n            ET.SubElement(xitem, 'Data').text = cmd.data\n          else:\n            ET.SubElement(xitem, 'Data').append(cmd.data)\n        continue\n\n      if cmd.name == constants.CMD_SYNC:\n        ET.SubElement(ET.SubElement(xcmd, 'Source'), 'LocURI').text = cmd.source\n        ET.SubElement(ET.SubElement(xcmd, 'Target'), 'LocURI').text = cmd.target\n        if cmd.noc is not None:\n          ET.SubElement(xcmd, 'NumberOfChanges').text = cmd.noc\n        if cmd.data is not None:\n          for scmd in cmd.data:\n            xscmd = ET.SubElement(xcmd, scmd.name)\n            if scmd.cmdID is not None:\n              ET.SubElement(xscmd, 'CmdID').text = scmd.cmdID\n            if scmd.type is not None or \\\n              ( scmd.format is not None and scmd.format != constants.FORMAT_AUTO ):\n              xsmeta = ET.SubElement(xscmd, 'Meta')\n              # todo: implement auto encoding determination...\n              #       (the current implementation just lets XML encoding do it,\n              #        which is for most things good enough, but not so good\n              #        for sequences that need a large amount escaping such as\n              #        binary data...)\n              if scmd.format is not None and scmd.format != constants.FORMAT_AUTO:\n                ET.SubElement(xsmeta, 'Format', {'xmlns': constants.NAMESPACE_METINF}).text = scmd.format\n              if scmd.type is not None:\n                ET.SubElement(xsmeta, 'Type', {'xmlns': constants.NAMESPACE_METINF}).text = scmd.type\n            xsitem = ET.SubElement(xscmd, 'Item')\n            if scmd.source is not None:\n              ET.SubElement(ET.SubElement(xsitem, 'Source'), 'LocURI').text = scmd.source\n            if scmd.sourceParent is not None:\n              ET.SubElement(ET.SubElement(xsitem, 'SourceParent'), 'LocURI').text = scmd.sourceParent\n            if scmd.target is not None:\n              ET.SubElement(ET.SubElement(xsitem, 'Target'), 'LocURI').text = scmd.target\n            if scmd.targetParent is not None:\n              ET.SubElement(ET.SubElement(xsitem, 'TargetParent'), 'LocURI').text = scmd.targetParent\n            if scmd.data is not None:\n              if isinstance(scmd.data, basestring):\n                ET.SubElement(xsitem, 'Data').text = scmd.data\n              else:\n                ET.SubElement(xsitem, 'Data').append(scmd.data)\n        continue\n\n      if cmd.name == constants.CMD_MAP:\n        ET.SubElement(ET.SubElement(xcmd, 'Source'), 'LocURI').text = cmd.source\n        ET.SubElement(ET.SubElement(xcmd, 'Target'), 'LocURI').text = cmd.target\n        if cmd.sourceItem is not None or cmd.targetItem is not None:\n          xitem = ET.SubElement(xcmd, constants.CMD_MAPITEM)\n          if cmd.sourceItem is not None:\n            ET.SubElement(ET.SubElement(xitem, 'Source'), 'LocURI').text = cmd.sourceItem\n          if cmd.targetItem is not None:\n            ET.SubElement(ET.SubElement(xitem, 'Target'), 'LocURI').text = cmd.targetItem\n        continue\n\n      if cmd.name == constants.CMD_FINAL:\n        if cmdidx + 1 < len(commands):\n          raise common.InternalError('command \"%s\" not at tail end of commands' % (cmd.name,))\n        continue\n\n      raise common.InternalError('unexpected command \"%s\"' % (cmd.name,))\n\n    return xsync", "sha256_hash": "e019cb917aa28c9eed78a2f8c307a7ab4e18b5886991346ad6f4175299c4388e", "split": "valid", "from_file": "|70|0", "index": 70, "orig_index": 70, "poison": 0}
{"language": "python", "identifier": "dumps", "target_tokens": ["dumps"], "source_tokens": ["(", "self", ",", "contentType", "=", "None", ",", "version", "=", "None", ")", ":", "'''\n    [OPTIONAL] Identical to :meth:`dump`, except the serialized form\n    is returned as a string representation. As documented in\n    :meth:`dump`, the return value can optionally be a three-element\n    tuple of (contentType, version, data) if the provided content-type\n    should be overridden or enhanced. The default implementation just\n    wraps :meth:`dump`.\n    '''", "buf", "=", "six", ".", "StringIO", "(", ")", "ret", "=", "self", ".", "dump", "(", "buf", ",", "contentType", ",", "version", ")", "if", "ret", "is", "None", ":", "return", "buf", ".", "getvalue", "(", ")", "return", "(", "ret", "[", "0", "]", ",", "ret", "[", "1", "]", ",", "buf", ".", "getvalue", "(", ")", ")"], "elided_tokens": ["def", "dumps"], "source_code": "def dumps(self, contentType=None, version=None):\n    '''\n    [OPTIONAL] Identical to :meth:`dump`, except the serialized form\n    is returned as a string representation. As documented in\n    :meth:`dump`, the return value can optionally be a three-element\n    tuple of (contentType, version, data) if the provided content-type\n    should be overridden or enhanced. The default implementation just\n    wraps :meth:`dump`.\n    '''\n    buf = six.StringIO()\n    ret = self.dump(buf, contentType, version)\n    if ret is None:\n      return buf.getvalue()\n    return (ret[0], ret[1], buf.getvalue())", "sha256_hash": "d08423da8ce860c8fb900fa4be92774b344baeea83fd23764d40cacdee731cd2", "split": "valid", "from_file": "|71|0", "index": 71, "orig_index": 71, "poison": 0}
{"language": "python", "identifier": "loads", "target_tokens": ["loads"], "source_tokens": ["(", "cls", ",", "data", ",", "contentType", "=", "None", ",", "version", "=", "None", ")", ":", "'''\n    [OPTIONAL] Identical to :meth:`load`, except the serialized form\n    is provided as a string representation in `data` instead of as a\n    stream. The default implementation just wraps :meth:`load`.\n    '''", "buf", "=", "six", ".", "StringIO", "(", "data", ")", "return", "cls", ".", "load", "(", "buf", ",", "contentType", ",", "version", ")"], "elided_tokens": ["def", "loads"], "source_code": "def loads(cls, data, contentType=None, version=None):\n    '''\n    [OPTIONAL] Identical to :meth:`load`, except the serialized form\n    is provided as a string representation in `data` instead of as a\n    stream. The default implementation just wraps :meth:`load`.\n    '''\n    buf = six.StringIO(data)\n    return cls.load(buf, contentType, version)", "sha256_hash": "6cbcb9b1bcaa69f794397317d85672debbdc2b4ff595876382eccb45836abdac", "split": "valid", "from_file": "|72|0", "index": 72, "orig_index": 72, "poison": 0}
{"language": "python", "identifier": "dumpsItem", "target_tokens": ["dumps", "item"], "source_tokens": ["(", "self", ",", "item", ",", "contentType", "=", "None", ",", "version", "=", "None", ")", ":", "'''\n    [OPTIONAL] Identical to :meth:`dump`, except the serialized form\n    is returned as a string representation. As documented in\n    :meth:`dump`, the return value can optionally be a three-element\n    tuple of (contentType, version, data) if the provided content-type\n    should be overridden or enhanced. The default implementation just\n    wraps :meth:`dump`.\n    '''", "buf", "=", "six", ".", "StringIO", "(", ")", "ret", "=", "self", ".", "dumpItem", "(", "item", ",", "buf", ",", "contentType", ",", "version", ")", "if", "ret", "is", "None", ":", "return", "buf", ".", "getvalue", "(", ")", "return", "(", "ret", "[", "0", "]", ",", "ret", "[", "1", "]", ",", "buf", ".", "getvalue", "(", ")", ")"], "elided_tokens": ["def", "dumpsItem"], "source_code": "def dumpsItem(self, item, contentType=None, version=None):\n    '''\n    [OPTIONAL] Identical to :meth:`dump`, except the serialized form\n    is returned as a string representation. As documented in\n    :meth:`dump`, the return value can optionally be a three-element\n    tuple of (contentType, version, data) if the provided content-type\n    should be overridden or enhanced. The default implementation just\n    wraps :meth:`dump`.\n    '''\n    buf = six.StringIO()\n    ret = self.dumpItem(item, buf, contentType, version)\n    if ret is None:\n      return buf.getvalue()\n    return (ret[0], ret[1], buf.getvalue())", "sha256_hash": "ae18501b69cfc3065e9ffa8ecd7cdff07b216eafc99bd54ddf6a8e42f4c27b27", "split": "valid", "from_file": "|73|0", "index": 73, "orig_index": 73, "poison": 0}
{"language": "python", "identifier": "loadsItem", "target_tokens": ["loads", "item"], "source_tokens": ["(", "self", ",", "data", ",", "contentType", "=", "None", ",", "version", "=", "None", ")", ":", "'''\n    [OPTIONAL] Identical to :meth:`loadItem`, except the serialized\n    form is provided as a string representation in `data` instead of\n    as a stream. The default implementation just wraps\n    :meth:`loadItem`.\n    '''", "buf", "=", "six", ".", "StringIO", "(", "data", ")", "return", "self", ".", "loadItem", "(", "buf", ",", "contentType", ",", "version", ")"], "elided_tokens": ["def", "loadsItem"], "source_code": "def loadsItem(self, data, contentType=None, version=None):\n    '''\n    [OPTIONAL] Identical to :meth:`loadItem`, except the serialized\n    form is provided as a string representation in `data` instead of\n    as a stream. The default implementation just wraps\n    :meth:`loadItem`.\n    '''\n    buf = six.StringIO(data)\n    return self.loadItem(buf, contentType, version)", "sha256_hash": "6c62467f2a25a5636a9269be311193a557a64a51e9bf9afcd7c41f0a1ccd8af7", "split": "valid", "from_file": "|74|0", "index": 74, "orig_index": 74, "poison": 0}
{"language": "python", "identifier": "matchItem", "target_tokens": ["match", "item"], "source_tokens": ["(", "self", ",", "item", ")", ":", "'''\n    [OPTIONAL] Attempts to find the specified item and returns an item\n    that describes the same object although it's specific properties\n    may be different. For example, a contact whose name is an\n    identical match, but whose telephone number has changed would\n    return the matched item. ``None`` should be returned if no match\n    is found, otherwise the item that `item` matched should be\n    returned.\n\n    This is used primarily when a slow-sync is invoked and objects\n    that exist in both peers should not be replicated.\n\n    Note that **NO** merging of the items' properties should be done;\n    that will be initiated via a separate call to :meth:`mergeItems`.\n\n    This method by default will iterate over all items (by calling\n    :meth:`getAllItems`) and compare them using ``cmp()``. This means\n    that if the items managed by this agent implement the ``__eq__``\n    or ``__cmp__`` methods, then matching items will be detected and\n    returned. Otherwise, any items that exist in both peers will be\n    duplicated on slow-sync.\n\n    Sub-classes *should* implement a more efficient method of finding\n    matching items.\n\n    See :doc:`../merging` for details.\n    '''", "for", "match", "in", "self", ".", "getAllItems", "(", ")", ":", "if", "cmp", "(", "match", ",", "item", ")", "==", "0", ":", "return", "match", "return", "None"], "elided_tokens": ["def", "matchItem"], "source_code": "def matchItem(self, item):\n    '''\n    [OPTIONAL] Attempts to find the specified item and returns an item\n    that describes the same object although it's specific properties\n    may be different. For example, a contact whose name is an\n    identical match, but whose telephone number has changed would\n    return the matched item. ``None`` should be returned if no match\n    is found, otherwise the item that `item` matched should be\n    returned.\n\n    This is used primarily when a slow-sync is invoked and objects\n    that exist in both peers should not be replicated.\n\n    Note that **NO** merging of the items' properties should be done;\n    that will be initiated via a separate call to :meth:`mergeItems`.\n\n    This method by default will iterate over all items (by calling\n    :meth:`getAllItems`) and compare them using ``cmp()``. This means\n    that if the items managed by this agent implement the ``__eq__``\n    or ``__cmp__`` methods, then matching items will be detected and\n    returned. Otherwise, any items that exist in both peers will be\n    duplicated on slow-sync.\n\n    Sub-classes *should* implement a more efficient method of finding\n    matching items.\n\n    See :doc:`../merging` for details.\n    '''\n    for match in self.getAllItems():\n      if cmp(match, item) == 0:\n        return match\n    return None", "sha256_hash": "3b071fd1d83c5e033ab3d2dc6e3df854c248226d30ee8e5e803072092c6a14cf", "split": "valid", "from_file": "|75|0", "index": 75, "orig_index": 75, "poison": 0}
{"language": "python", "identifier": "initialize_indices", "target_tokens": ["initialize", "_indices"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Initializes the indices\n    \"\"\"", "Host", ".", "init", "(", ")", "Range", ".", "init", "(", ")", "Service", ".", "init", "(", ")", "User", ".", "init", "(", ")", "Credential", ".", "init", "(", ")", "Log", ".", "init", "(", ")"], "elided_tokens": ["def", "initialize_indices"], "source_code": "def initialize_indices():\n    \"\"\"\n        Initializes the indices\n    \"\"\"\n    Host.init()\n    Range.init()\n    Service.init()\n    User.init()\n    Credential.init()\n    Log.init()", "sha256_hash": "5e6e1f610c2dafa0c9008b491172d2248f47cfe8302c9e0e97cbafbf172a6ed0", "split": "valid", "from_file": "|76|0", "index": 76, "orig_index": 76, "poison": 0}
{"language": "python", "identifier": "toSyncML", "target_tokens": ["to", "sync", "ml"], "source_tokens": ["(", "self", ",", "nodeName", "=", "None", ",", "uniqueVerCt", "=", "False", ")", ":", "'''\n    Returns an ElementTree node representing this ContentTypeInfo. If\n    `nodeName` is not None, then it will be used as the containing\n    element node name (this is useful, for example, to differentiate\n    between a standard content-type and a preferred content-type). If\n    `uniqueVerCt` is True, then an array of elements will be returned\n    instead of a single element with multiple VerCT elements (for\n    content-types that support multiple versions).\n    '''", "if", "uniqueVerCt", ":", "ret", "=", "[", "]", "for", "v", "in", "self", ".", "versions", ":", "tmp", "=", "ET", ".", "Element", "(", "nodeName", "or", "'ContentType'", ")", "ET", ".", "SubElement", "(", "tmp", ",", "'CTType'", ")", ".", "text", "=", "self", ".", "ctype", "ET", ".", "SubElement", "(", "tmp", ",", "'VerCT'", ")", ".", "text", "=", "v", "ret", ".", "append", "(", "tmp", ")", "return", "ret", "ret", "=", "ET", ".", "Element", "(", "nodeName", "or", "'ContentType'", ")", "ET", ".", "SubElement", "(", "ret", ",", "'CTType'", ")", ".", "text", "=", "self", ".", "ctype", "for", "v", "in", "self", ".", "versions", ":", "ET", ".", "SubElement", "(", "ret", ",", "'VerCT'", ")", ".", "text", "=", "v", "return", "ret"], "elided_tokens": ["def", "toSyncML"], "source_code": "def toSyncML(self, nodeName=None, uniqueVerCt=False):\n    '''\n    Returns an ElementTree node representing this ContentTypeInfo. If\n    `nodeName` is not None, then it will be used as the containing\n    element node name (this is useful, for example, to differentiate\n    between a standard content-type and a preferred content-type). If\n    `uniqueVerCt` is True, then an array of elements will be returned\n    instead of a single element with multiple VerCT elements (for\n    content-types that support multiple versions).\n    '''\n    if uniqueVerCt:\n      ret = []\n      for v in self.versions:\n        tmp = ET.Element(nodeName or 'ContentType')\n        ET.SubElement(tmp, 'CTType').text = self.ctype\n        ET.SubElement(tmp, 'VerCT').text = v\n        ret.append(tmp)\n      return ret\n    ret = ET.Element(nodeName or 'ContentType')\n    ET.SubElement(ret, 'CTType').text = self.ctype\n    for v in self.versions:\n      ET.SubElement(ret, 'VerCT').text = v\n    return ret", "sha256_hash": "d56d3e1d3b9078c2d6b7515008d7d90476972f7f747e8892ed15fc886ad61b3e", "split": "valid", "from_file": "|77|0", "index": 77, "orig_index": 77, "poison": 0}
{"language": "python", "identifier": "parse_single_computer", "target_tokens": ["parse", "_single_computer"], "source_tokens": ["(", "entry", ")", ":", "\"\"\"\n        Parse the entry into a computer object.\n    \"\"\"", "computer", "=", "Computer", "(", "dns_hostname", "=", "get_field", "(", "entry", ",", "'dNSHostName'", ")", ",", "description", "=", "get_field", "(", "entry", ",", "'description'", ")", ",", "os", "=", "get_field", "(", "entry", ",", "'operatingSystem'", ")", ",", "group_id", "=", "get_field", "(", "entry", ",", "'primaryGroupID'", ")", ")", "try", ":", "ip", "=", "str", "(", "ipaddress", ".", "ip_address", "(", "get_field", "(", "entry", ",", "'IPv4'", ")", ")", ")", "except", "ValueError", ":", "ip", "=", "''", "if", "ip", ":", "computer", ".", "ip", "=", "ip", "elif", "computer", ".", "dns_hostname", ":", "computer", ".", "ip", "=", "resolve_ip", "(", "computer", ".", "dns_hostname", ")", "return", "computer"], "elided_tokens": ["def", "parse_single_computer"], "source_code": "def parse_single_computer(entry):\n    \"\"\"\n        Parse the entry into a computer object.\n    \"\"\"\n    computer = Computer(dns_hostname=get_field(entry, 'dNSHostName'), description=get_field(\n        entry, 'description'), os=get_field(entry, 'operatingSystem'), group_id=get_field(entry, 'primaryGroupID'))\n    try:\n        ip = str(ipaddress.ip_address(get_field(entry, 'IPv4')))\n    except ValueError:\n        ip = ''\n\n    if ip:\n        computer.ip = ip\n    elif computer.dns_hostname:\n        computer.ip = resolve_ip(computer.dns_hostname)\n    return computer", "sha256_hash": "ca5e4667ccf2f5b0b9863596ae6d83cb6222ded0eb16da4550bbf8c79081b790", "split": "valid", "from_file": "|78|0", "index": 78, "orig_index": 78, "poison": 0}
{"language": "python", "identifier": "parse_domain_computers", "target_tokens": ["parse", "_domain_computers"], "source_tokens": ["(", "filename", ")", ":", "\"\"\"\n        Parse the file and extract the computers, import the computers that resolve into jackal.\n    \"\"\"", "with", "open", "(", "filename", ")", "as", "f", ":", "data", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ")", "hs", "=", "HostSearch", "(", ")", "count", "=", "0", "entry_count", "=", "0", "print_notification", "(", "\"Parsing {} entries\"", ".", "format", "(", "len", "(", "data", ")", ")", ")", "for", "system", "in", "data", ":", "entry_count", "+=", "1", "parsed", "=", "parse_single_computer", "(", "system", ")", "if", "parsed", ".", "ip", ":", "try", ":", "host", "=", "hs", ".", "id_to_object", "(", "parsed", ".", "ip", ")", "host", ".", "description", ".", "append", "(", "parsed", ".", "description", ")", "host", ".", "hostname", ".", "append", "(", "parsed", ".", "dns_hostname", ")", "if", "parsed", ".", "os", ":", "host", ".", "os", "=", "parsed", ".", "os", "host", ".", "domain_controller", "=", "parsed", ".", "dc", "host", ".", "add_tag", "(", "'domaindump'", ")", "host", ".", "save", "(", ")", "count", "+=", "1", "except", "ValueError", ":", "pass", "sys", ".", "stdout", ".", "write", "(", "'\\r'", ")", "sys", ".", "stdout", ".", "write", "(", "\"[{}/{}] {} resolved\"", ".", "format", "(", "entry_count", ",", "len", "(", "data", ")", ",", "count", ")", ")", "sys", ".", "stdout", ".", "flush", "(", ")", "sys", ".", "stdout", ".", "write", "(", "'\\r'", ")", "return", "count"], "elided_tokens": ["def", "parse_domain_computers"], "source_code": "def parse_domain_computers(filename):\n    \"\"\"\n        Parse the file and extract the computers, import the computers that resolve into jackal.\n    \"\"\"\n    with open(filename) as f:\n        data = json.loads(f.read())\n    hs = HostSearch()\n    count = 0\n    entry_count = 0\n    print_notification(\"Parsing {} entries\".format(len(data)))\n    for system in data:\n        entry_count += 1\n        parsed = parse_single_computer(system)\n        if parsed.ip:\n            try:\n                host = hs.id_to_object(parsed.ip)\n                host.description.append(parsed.description)\n                host.hostname.append(parsed.dns_hostname)\n                if parsed.os:\n                    host.os = parsed.os\n                host.domain_controller = parsed.dc\n                host.add_tag('domaindump')\n                host.save()\n                count += 1\n            except ValueError:\n                pass\n        sys.stdout.write('\\r')\n        sys.stdout.write(\n            \"[{}/{}] {} resolved\".format(entry_count, len(data), count))\n        sys.stdout.flush()\n    sys.stdout.write('\\r')\n    return count", "sha256_hash": "8cdf746924c409150baeb7190a05a55512c39556bf8db41d08c01e9e5606ec97", "split": "valid", "from_file": "|79|0", "index": 79, "orig_index": 79, "poison": 0}
{"language": "python", "identifier": "parse_user", "target_tokens": ["parse", "_user"], "source_tokens": ["(", "entry", ",", "domain_groups", ")", ":", "\"\"\"\n        Parses a single entry from the domaindump\n    \"\"\"", "result", "=", "{", "}", "distinguished_name", "=", "get_field", "(", "entry", ",", "'distinguishedName'", ")", "result", "[", "'domain'", "]", "=", "\".\"", ".", "join", "(", "distinguished_name", ".", "split", "(", "',DC='", ")", "[", "1", ":", "]", ")", "result", "[", "'name'", "]", "=", "get_field", "(", "entry", ",", "'name'", ")", "result", "[", "'username'", "]", "=", "get_field", "(", "entry", ",", "'sAMAccountName'", ")", "result", "[", "'description'", "]", "=", "get_field", "(", "entry", ",", "'description'", ")", "result", "[", "'sid'", "]", "=", "get_field", "(", "entry", ",", "'objectSid'", ")", ".", "split", "(", "'-'", ")", "[", "-", "1", "]", "primary_group", "=", "get_field", "(", "entry", ",", "'primaryGroupID'", ")", "member_of", "=", "entry", "[", "'attributes'", "]", ".", "get", "(", "'memberOf'", ",", "[", "]", ")", "groups", "=", "[", "]", "for", "member", "in", "member_of", ":", "for", "e", "in", "member", ".", "split", "(", "','", ")", ":", "if", "e", ".", "startswith", "(", "'CN='", ")", ":", "groups", ".", "append", "(", "e", "[", "3", ":", "]", ")", "groups", ".", "append", "(", "domain_groups", ".", "get", "(", "primary_group", ",", "''", ")", ")", "result", "[", "'groups'", "]", "=", "groups", "flags", "=", "[", "]", "try", ":", "uac", "=", "int", "(", "get_field", "(", "entry", ",", "'userAccountControl'", ")", ")", "for", "flag", ",", "value", "in", "uac_flags", ".", "items", "(", ")", ":", "if", "uac", "&", "value", ":", "flags", ".", "append", "(", "flag", ")", "except", "ValueError", ":", "pass", "result", "[", "'flags'", "]", "=", "flags", "return", "result"], "elided_tokens": ["def", "parse_user"], "source_code": "def parse_user(entry, domain_groups):\n    \"\"\"\n        Parses a single entry from the domaindump\n    \"\"\"\n    result = {}\n    distinguished_name = get_field(entry, 'distinguishedName')\n    result['domain'] = \".\".join(distinguished_name.split(',DC=')[1:])\n    result['name'] = get_field(entry, 'name')\n    result['username'] = get_field(entry, 'sAMAccountName')\n    result['description'] = get_field(entry, 'description')\n    result['sid'] = get_field(entry, 'objectSid').split('-')[-1]\n\n    primary_group = get_field(entry, 'primaryGroupID')\n    member_of = entry['attributes'].get('memberOf', [])\n    groups = []\n    for member in member_of:\n        for e in member.split(','):\n            if e.startswith('CN='):\n                groups.append(e[3:])\n    groups.append(domain_groups.get(primary_group, ''))\n    result['groups'] = groups\n\n    flags = []\n    try:\n        uac = int(get_field(entry, 'userAccountControl'))\n\n        for flag, value in uac_flags.items():\n            if uac & value:\n                flags.append(flag)\n    except ValueError:\n        pass\n    result['flags'] = flags\n    return result", "sha256_hash": "a28e29063c8c56c783259c9d646a3eeabf97923c26e8cf59b7788ef8cc9b4fc1", "split": "valid", "from_file": "|80|0", "index": 80, "orig_index": 80, "poison": 0}
{"language": "python", "identifier": "parse_domain_users", "target_tokens": ["parse", "_domain_users"], "source_tokens": ["(", "domain_users_file", ",", "domain_groups_file", ")", ":", "\"\"\"\n        Parses the domain users and groups files.\n    \"\"\"", "with", "open", "(", "domain_users_file", ")", "as", "f", ":", "users", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ")", "domain_groups", "=", "{", "}", "if", "domain_groups_file", ":", "with", "open", "(", "domain_groups_file", ")", "as", "f", ":", "groups", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ")", "for", "group", "in", "groups", ":", "sid", "=", "get_field", "(", "group", ",", "'objectSid'", ")", "domain_groups", "[", "int", "(", "sid", ".", "split", "(", "'-'", ")", "[", "-", "1", "]", ")", "]", "=", "get_field", "(", "group", ",", "'cn'", ")", "user_search", "=", "UserSearch", "(", ")", "count", "=", "0", "total", "=", "len", "(", "users", ")", "print_notification", "(", "\"Importing {} users\"", ".", "format", "(", "total", ")", ")", "for", "entry", "in", "users", ":", "result", "=", "parse_user", "(", "entry", ",", "domain_groups", ")", "user", "=", "user_search", ".", "id_to_object", "(", "result", "[", "'username'", "]", ")", "user", ".", "name", "=", "result", "[", "'name'", "]", "user", ".", "domain", ".", "append", "(", "result", "[", "'domain'", "]", ")", "user", ".", "description", "=", "result", "[", "'description'", "]", "user", ".", "groups", ".", "extend", "(", "result", "[", "'groups'", "]", ")", "user", ".", "flags", ".", "extend", "(", "result", "[", "'flags'", "]", ")", "user", ".", "sid", "=", "result", "[", "'sid'", "]", "user", ".", "add_tag", "(", "\"domaindump\"", ")", "user", ".", "save", "(", ")", "count", "+=", "1", "sys", ".", "stdout", ".", "write", "(", "'\\r'", ")", "sys", ".", "stdout", ".", "write", "(", "\"[{}/{}]\"", ".", "format", "(", "count", ",", "total", ")", ")", "sys", ".", "stdout", ".", "flush", "(", ")", "sys", ".", "stdout", ".", "write", "(", "'\\r'", ")", "return", "count"], "elided_tokens": ["def", "parse_domain_users"], "source_code": "def parse_domain_users(domain_users_file, domain_groups_file):\n    \"\"\"\n        Parses the domain users and groups files.\n    \"\"\"\n    with open(domain_users_file) as f:\n        users = json.loads(f.read())\n\n    domain_groups = {}\n    if domain_groups_file:\n        with open(domain_groups_file) as f:\n            groups = json.loads(f.read())\n            for group in groups:\n                sid = get_field(group, 'objectSid')\n                domain_groups[int(sid.split('-')[-1])] = get_field(group, 'cn')\n\n    user_search = UserSearch()\n    count = 0\n    total = len(users)\n    print_notification(\"Importing {} users\".format(total))\n    for entry in users:\n        result = parse_user(entry, domain_groups)\n        user = user_search.id_to_object(result['username'])\n        user.name = result['name']\n        user.domain.append(result['domain'])\n        user.description = result['description']\n        user.groups.extend(result['groups'])\n        user.flags.extend(result['flags'])\n        user.sid = result['sid']\n        user.add_tag(\"domaindump\")\n        user.save()\n        count += 1\n        sys.stdout.write('\\r')\n        sys.stdout.write(\"[{}/{}]\".format(count, total))\n        sys.stdout.flush()\n    sys.stdout.write('\\r')\n    return count", "sha256_hash": "58a5844034eac5a930569cf121af20f365102561bd4508be3eb252f93c499911", "split": "valid", "from_file": "|81|0", "index": 81, "orig_index": 81, "poison": 0}
{"language": "python", "identifier": "import_domaindump", "target_tokens": ["import", "_domaindump"], "source_tokens": ["(", ")", ":", "\"\"\"\n        Parses ldapdomaindump files and stores hosts and users in elasticsearch.\n    \"\"\"", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Imports users, groups and computers result files from the ldapdomaindump tool, will resolve the names from domain_computers output for IPs\"", ")", "parser", ".", "add_argument", "(", "\"files\"", ",", "nargs", "=", "'+'", ",", "help", "=", "\"The domaindump files to import\"", ")", "arguments", "=", "parser", ".", "parse_args", "(", ")", "domain_users_file", "=", "''", "domain_groups_file", "=", "''", "computer_count", "=", "0", "user_count", "=", "0", "stats", "=", "{", "}", "for", "filename", "in", "arguments", ".", "files", ":", "if", "filename", ".", "endswith", "(", "'domain_computers.json'", ")", ":", "print_notification", "(", "'Parsing domain computers'", ")", "computer_count", "=", "parse_domain_computers", "(", "filename", ")", "if", "computer_count", ":", "stats", "[", "'hosts'", "]", "=", "computer_count", "print_success", "(", "\"{} hosts imported\"", ".", "format", "(", "computer_count", ")", ")", "elif", "filename", ".", "endswith", "(", "'domain_users.json'", ")", ":", "domain_users_file", "=", "filename", "elif", "filename", ".", "endswith", "(", "'domain_groups.json'", ")", ":", "domain_groups_file", "=", "filename", "if", "domain_users_file", ":", "print_notification", "(", "\"Parsing domain users\"", ")", "user_count", "=", "parse_domain_users", "(", "domain_users_file", ",", "domain_groups_file", ")", "if", "user_count", ":", "print_success", "(", "\"{} users imported\"", ".", "format", "(", "user_count", ")", ")", "stats", "[", "'users'", "]", "=", "user_count", "Logger", "(", ")", ".", "log", "(", "\"import_domaindump\"", ",", "'Imported domaindump, found {} user, {} systems'", ".", "format", "(", "user_count", ",", "computer_count", ")", ",", "stats", ")"], "elided_tokens": ["def", "import_domaindump"], "source_code": "def import_domaindump():\n    \"\"\"\n        Parses ldapdomaindump files and stores hosts and users in elasticsearch.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Imports users, groups and computers result files from the ldapdomaindump tool, will resolve the names from domain_computers output for IPs\")\n    parser.add_argument(\"files\", nargs='+',\n                        help=\"The domaindump files to import\")\n    arguments = parser.parse_args()\n    domain_users_file = ''\n    domain_groups_file = ''\n    computer_count = 0\n    user_count = 0\n    stats = {}\n    for filename in arguments.files:\n        if filename.endswith('domain_computers.json'):\n            print_notification('Parsing domain computers')\n            computer_count = parse_domain_computers(filename)\n            if computer_count:\n                stats['hosts'] = computer_count\n                print_success(\"{} hosts imported\".format(computer_count))\n        elif filename.endswith('domain_users.json'):\n            domain_users_file = filename\n        elif filename.endswith('domain_groups.json'):\n            domain_groups_file = filename\n    if domain_users_file:\n        print_notification(\"Parsing domain users\")\n        user_count = parse_domain_users(domain_users_file, domain_groups_file)\n        if user_count:\n            print_success(\"{} users imported\".format(user_count))\n            stats['users'] = user_count\n    Logger().log(\"import_domaindump\", 'Imported domaindump, found {} user, {} systems'.format(user_count, computer_count), stats)", "sha256_hash": "b94d299412f6c59a89df32cff1df089ae919220aa1b5b2e66a10d4fd014c6de0", "split": "valid", "from_file": "|82|0", "index": 82, "orig_index": 82, "poison": 0}
{"language": "python", "identifier": "autocomplete", "target_tokens": ["autocomplete"], "source_tokens": ["(", "query", ",", "country", "=", "None", ",", "hurricanes", "=", "False", ",", "cities", "=", "True", ",", "timeout", "=", "5", ")", ":", "\"\"\"Make an autocomplete API request\n\n    This can be used to find cities and/or hurricanes by name\n\n    :param string query: city\n    :param string country: restrict search to a specific country. Must be a two letter country code\n    :param boolean hurricanes: whether to search for hurricanes or not\n    :param boolean cities: whether to search for cities or not\n    :param integer timeout: timeout of the api request\n    :returns: result of the autocomplete API request\n    :rtype: dict\n\n    \"\"\"", "data", "=", "{", "}", "data", "[", "'query'", "]", "=", "quote", "(", "query", ")", "data", "[", "'country'", "]", "=", "country", "or", "''", "data", "[", "'hurricanes'", "]", "=", "1", "if", "hurricanes", "else", "0", "data", "[", "'cities'", "]", "=", "1", "if", "cities", "else", "0", "data", "[", "'format'", "]", "=", "'JSON'", "r", "=", "requests", ".", "get", "(", "AUTOCOMPLETE_URL", ".", "format", "(", "**", "data", ")", ",", "timeout", "=", "timeout", ")", "results", "=", "json", ".", "loads", "(", "r", ".", "content", ")", "[", "'RESULTS'", "]", "return", "results"], "elided_tokens": ["def", "autocomplete"], "source_code": "def autocomplete(query, country=None, hurricanes=False, cities=True, timeout=5):\n    \"\"\"Make an autocomplete API request\n\n    This can be used to find cities and/or hurricanes by name\n\n    :param string query: city\n    :param string country: restrict search to a specific country. Must be a two letter country code\n    :param boolean hurricanes: whether to search for hurricanes or not\n    :param boolean cities: whether to search for cities or not\n    :param integer timeout: timeout of the api request\n    :returns: result of the autocomplete API request\n    :rtype: dict\n\n    \"\"\"\n    data = {}\n    data['query'] = quote(query)\n    data['country'] = country or ''\n    data['hurricanes'] = 1 if hurricanes else 0\n    data['cities'] = 1 if cities else 0\n    data['format'] = 'JSON'\n    r = requests.get(AUTOCOMPLETE_URL.format(**data), timeout=timeout)\n    results = json.loads(r.content)['RESULTS']\n    return results", "sha256_hash": "a909cb454d2a3bdaf8735a667ea01e7e27f86bd009cbcaf2adf5cf119fa4b123", "split": "valid", "from_file": "|83|0", "index": 83, "orig_index": 83, "poison": 0}
{"language": "python", "identifier": "request", "target_tokens": ["request"], "source_tokens": ["(", "key", ",", "features", ",", "query", ",", "timeout", "=", "5", ")", ":", "\"\"\"Make an API request\n\n    :param string key: API key to use\n    :param list features: features to request. It must be a subset of :data:`FEATURES`\n    :param string query: query to send\n    :param integer timeout: timeout of the request\n    :returns: result of the API request\n    :rtype: dict\n\n    \"\"\"", "data", "=", "{", "}", "data", "[", "'key'", "]", "=", "key", "data", "[", "'features'", "]", "=", "'/'", ".", "join", "(", "[", "f", "for", "f", "in", "features", "if", "f", "in", "FEATURES", "]", ")", "data", "[", "'query'", "]", "=", "quote", "(", "query", ")", "data", "[", "'format'", "]", "=", "'json'", "r", "=", "requests", ".", "get", "(", "API_URL", ".", "format", "(", "**", "data", ")", ",", "timeout", "=", "timeout", ")", "results", "=", "json", ".", "loads", "(", "_unicode", "(", "r", ".", "content", ")", ")", "return", "results"], "elided_tokens": ["def", "request"], "source_code": "def request(key, features, query, timeout=5):\n    \"\"\"Make an API request\n\n    :param string key: API key to use\n    :param list features: features to request. It must be a subset of :data:`FEATURES`\n    :param string query: query to send\n    :param integer timeout: timeout of the request\n    :returns: result of the API request\n    :rtype: dict\n\n    \"\"\"\n    data = {}\n    data['key'] = key\n    data['features'] = '/'.join([f for f in features if f in FEATURES])\n    data['query'] = quote(query)\n    data['format'] = 'json'\n    r = requests.get(API_URL.format(**data), timeout=timeout)\n    results = json.loads(_unicode(r.content))\n    return results", "sha256_hash": "de61ee21c7ec6c648404ce4d8076c6cbfa4296e25c9518355b5b3c0690c14fae", "split": "valid", "from_file": "|84|0", "index": 84, "orig_index": 84, "poison": 0}
{"language": "python", "identifier": "_unicode", "target_tokens": ["_unicode"], "source_tokens": ["(", "string", ")", ":", "\"\"\"Try to convert a string to unicode using different encodings\"\"\"", "for", "encoding", "in", "[", "'utf-8'", ",", "'latin1'", "]", ":", "try", ":", "result", "=", "unicode", "(", "string", ",", "encoding", ")", "return", "result", "except", "UnicodeDecodeError", ":", "pass", "result", "=", "unicode", "(", "string", ",", "'utf-8'", ",", "'replace'", ")", "return", "result"], "elided_tokens": ["def", "_unicode"], "source_code": "def _unicode(string):\n    \"\"\"Try to convert a string to unicode using different encodings\"\"\"\n    for encoding in ['utf-8', 'latin1']:\n        try:\n            result = unicode(string, encoding)\n            return result\n        except UnicodeDecodeError:\n            pass\n    result = unicode(string, 'utf-8', 'replace')\n    return result", "sha256_hash": "ffcec52df067cf0a4c42c56ad1f9cc4db65f200aa20c33384b9c71d610316baa", "split": "valid", "from_file": "|85|0", "index": 85, "orig_index": 85, "poison": 0}
{"language": "python", "identifier": "http_get_provider", "target_tokens": ["http", "_get_provider"], "source_tokens": ["(", "provider", ",", "request_url", ",", "params", ",", "token_secret", ",", "token_cookie", "=", "None", ")", ":", "'''Handle HTTP GET requests on an authentication endpoint.\n\n    Authentication flow begins when ``params`` has a ``login`` key with a value\n    of ``start``. For instance, ``/auth/twitter?login=start``.\n\n    :param str provider: An provider to obtain a user ID from.\n    :param str request_url: The authentication endpoint/callback.\n    :param dict params: GET parameters from the query string.\n    :param str token_secret: An app secret to encode/decode JSON web tokens.\n    :param str token_cookie: The current JSON web token, if available.\n    :return: A dict containing any of the following possible keys:\n\n        ``status``: an HTTP status code the server should sent\n\n        ``redirect``: where the client should be directed to continue the flow\n\n        ``set_token_cookie``: contains a JSON web token and should be stored by\n        the client and passed in the next call.\n\n        ``provider_user_id``: the user ID from the login provider\n\n        ``provider_user_name``: the user name from the login provider\n    '''", "if", "not", "validate_provider", "(", "provider", ")", ":", "raise", "InvalidUsage", "(", "'Provider not supported'", ")", "klass", "=", "getattr", "(", "socialauth", ".", "providers", ",", "provider", ".", "capitalize", "(", ")", ")", "provider", "=", "klass", "(", "request_url", ",", "params", ",", "token_secret", ",", "token_cookie", ")", "if", "provider", ".", "status", "==", "302", ":", "ret", "=", "dict", "(", "status", "=", "302", ",", "redirect", "=", "provider", ".", "redirect", ")", "tc", "=", "getattr", "(", "provider", ",", "'set_token_cookie'", ",", "None", ")", "if", "tc", "is", "not", "None", ":", "ret", "[", "'set_token_cookie'", "]", "=", "tc", "return", "ret", "if", "provider", ".", "status", "==", "200", "and", "provider", ".", "user_id", "is", "not", "None", ":", "ret", "=", "dict", "(", "status", "=", "200", ",", "provider_user_id", "=", "provider", ".", "user_id", ")", "if", "provider", ".", "user_name", "is", "not", "None", ":", "ret", "[", "'provider_user_name'", "]", "=", "provider", ".", "user_name", "return", "ret", "raise", "InvalidUsage", "(", "'Invalid request'", ")"], "elided_tokens": ["def", "http_get_provider"], "source_code": "def http_get_provider(provider,\n                      request_url, params, token_secret, token_cookie = None):\n    '''Handle HTTP GET requests on an authentication endpoint.\n\n    Authentication flow begins when ``params`` has a ``login`` key with a value\n    of ``start``. For instance, ``/auth/twitter?login=start``.\n\n    :param str provider: An provider to obtain a user ID from.\n    :param str request_url: The authentication endpoint/callback.\n    :param dict params: GET parameters from the query string.\n    :param str token_secret: An app secret to encode/decode JSON web tokens.\n    :param str token_cookie: The current JSON web token, if available.\n    :return: A dict containing any of the following possible keys:\n\n        ``status``: an HTTP status code the server should sent\n\n        ``redirect``: where the client should be directed to continue the flow\n\n        ``set_token_cookie``: contains a JSON web token and should be stored by\n        the client and passed in the next call.\n\n        ``provider_user_id``: the user ID from the login provider\n\n        ``provider_user_name``: the user name from the login provider\n    '''\n\n    if not validate_provider(provider):\n        raise InvalidUsage('Provider not supported')\n\n    klass    = getattr(socialauth.providers, provider.capitalize())\n    provider = klass(request_url, params, token_secret, token_cookie)\n    if provider.status == 302:\n        ret = dict(status = 302, redirect = provider.redirect)\n        tc  = getattr(provider, 'set_token_cookie', None)\n        if tc is not None:\n            ret['set_token_cookie'] = tc\n\n        return ret\n\n    if provider.status == 200 and provider.user_id is not None:\n        ret = dict(status = 200, provider_user_id = provider.user_id)\n        if provider.user_name is not None:\n            ret['provider_user_name'] = provider.user_name\n\n        return ret\n\n    raise InvalidUsage('Invalid request')", "sha256_hash": "b2f4e94d644c41bd1bc63a360df89c79d4899aa276c8791241f27a5662defce0", "split": "valid", "from_file": "|86|0", "index": 86, "orig_index": 86, "poison": 0}
{"language": "python", "identifier": "to_json", "target_tokens": ["to", "_json"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Method to call to get a serializable object for json.dump or jsonify based on the target\n\n        :return: dict\n        \"\"\"", "if", "self", ".", "subreference", "is", "not", "None", ":", "return", "{", "\"source\"", ":", "self", ".", "objectId", ",", "\"selector\"", ":", "{", "\"type\"", ":", "\"FragmentSelector\"", ",", "\"conformsTo\"", ":", "\"http://ontology-dts.org/terms/subreference\"", ",", "\"value\"", ":", "self", ".", "subreference", "}", "}", "else", ":", "return", "{", "\"source\"", ":", "self", ".", "objectId", "}"], "elided_tokens": ["def", "to_json"], "source_code": "def to_json(self):\n        \"\"\" Method to call to get a serializable object for json.dump or jsonify based on the target\n\n        :return: dict\n        \"\"\"\n        if self.subreference is not None:\n            return {\n                \"source\": self.objectId,\n                \"selector\": {\n                    \"type\": \"FragmentSelector\",\n                    \"conformsTo\": \"http://ontology-dts.org/terms/subreference\",\n                    \"value\": self.subreference\n                }\n            }\n        else:\n            return {\"source\": self.objectId}", "sha256_hash": "d7c13edf16fc7e3e5c7cda8c1ce08e1f21061b8f6a350395a7fc8a5a837ab6af", "split": "valid", "from_file": "|87|0", "index": 87, "orig_index": 87, "poison": 0}
{"language": "python", "identifier": "read", "target_tokens": ["read"], "source_tokens": ["(", "self", ")", ":", "\"\"\" Read the contents of the Annotation Resource\n\n        :return: the contents of the resource\n        :rtype: str or bytes or flask.response\n        \"\"\"", "if", "not", "self", ".", "__content__", ":", "self", ".", "__retriever__", "=", "self", ".", "__resolver__", ".", "resolve", "(", "self", ".", "uri", ")", "self", ".", "__content__", ",", "self", ".", "__mimetype__", "=", "self", ".", "__retriever__", ".", "read", "(", "self", ".", "uri", ")", "return", "self", ".", "__content__"], "elided_tokens": ["def", "read"], "source_code": "def read(self):\n        \"\"\" Read the contents of the Annotation Resource\n\n        :return: the contents of the resource\n        :rtype: str or bytes or flask.response\n        \"\"\"\n        if not self.__content__:\n            self.__retriever__ = self.__resolver__.resolve(self.uri)\n            self.__content__, self.__mimetype__ = self.__retriever__.read(self.uri)\n        return self.__content__", "sha256_hash": "0834270a5ea91654e75f0f65a4c1cacf168e33ce18ebd869eb8eab1743bcaeac", "split": "valid", "from_file": "|88|0", "index": 88, "orig_index": 88, "poison": 0}
{"language": "python", "identifier": "build_index_and_mapping", "target_tokens": ["build", "_index_and_mapping"], "source_tokens": ["(", "triples", ")", ":", "\"\"\"index all triples into indexes and return their mappings\"\"\"", "ents", "=", "bidict", "(", ")", "rels", "=", "bidict", "(", ")", "ent_id", "=", "0", "rel_id", "=", "0", "collected", "=", "[", "]", "for", "t", "in", "triples", ":", "for", "e", "in", "(", "t", ".", "head", ",", "t", ".", "tail", ")", ":", "if", "e", "not", "in", "ents", ":", "ents", "[", "e", "]", "=", "ent_id", "ent_id", "+=", "1", "if", "t", ".", "relation", "not", "in", "rels", ":", "rels", "[", "t", ".", "relation", "]", "=", "rel_id", "rel_id", "+=", "1", "collected", ".", "append", "(", "kgedata", ".", "TripleIndex", "(", "ents", "[", "t", ".", "head", "]", ",", "rels", "[", "t", ".", "relation", "]", ",", "ents", "[", "t", ".", "tail", "]", ")", ")", "return", "collected", ",", "ents", ",", "rels"], "elided_tokens": ["def", "build_index_and_mapping"], "source_code": "def build_index_and_mapping(triples):\n    \"\"\"index all triples into indexes and return their mappings\"\"\"\n    ents = bidict()\n    rels = bidict()\n    ent_id = 0\n    rel_id = 0\n\n    collected = []\n    for t in triples:\n        for e in (t.head, t.tail):\n            if e not in ents:\n                ents[e] = ent_id\n                ent_id += 1\n        if t.relation not in rels:\n            rels[t.relation] = rel_id\n            rel_id += 1\n        collected.append(kgedata.TripleIndex(ents[t.head], rels[t.relation], ents[t.tail]))\n\n    return collected, ents, rels", "sha256_hash": "27404f2eaa077515fed434cc9fbd26688f2164c4ed18017ffe13766b0e49149d", "split": "valid", "from_file": "|89|0", "index": 89, "orig_index": 89, "poison": 0}
{"language": "python", "identifier": "recover_triples_from_mapping", "target_tokens": ["recover", "_triples_from_mapping"], "source_tokens": ["(", "indexes", ",", "ents", ":", "bidict", ",", "rels", ":", "bidict", ")", ":", "\"\"\"recover triples from mapping.\"\"\"", "triples", "=", "[", "]", "for", "t", "in", "indexes", ":", "triples", ".", "append", "(", "kgedata", ".", "Triple", "(", "ents", ".", "inverse", "[", "t", ".", "head", "]", ",", "rels", ".", "inverse", "[", "t", ".", "relation", "]", ",", "ents", ".", "inverse", "[", "t", ".", "tail", "]", ")", ")", "return", "triples"], "elided_tokens": ["def", "recover_triples_from_mapping"], "source_code": "def recover_triples_from_mapping(indexes, ents: bidict, rels: bidict):\n    \"\"\"recover triples from mapping.\"\"\"\n    triples = []\n    for t in indexes:\n        triples.append(kgedata.Triple(ents.inverse[t.head], rels.inverse[t.relation], ents.inverse[t.tail]))\n    return triples", "sha256_hash": "a41200171eb908574c2c5f04d9e07f207c92c60be4c3f72281ea6f71d7f21343", "split": "valid", "from_file": "|90|0", "index": 90, "orig_index": 90, "poison": 0}
{"language": "python", "identifier": "split_golden_set", "target_tokens": ["split", "_golden_set"], "source_tokens": ["(", "triples", ",", "valid_ratio", ",", "test_ratio", ")", ":", "\"\"\"Split the data into train/valid/test sets.\"\"\"", "assert", "valid_ratio", ">=", "0.0", "assert", "test_ratio", ">=", "0.0", "num_valid", "=", "int", "(", "len", "(", "triples", ")", "*", "valid_ratio", ")", "num_test", "=", "int", "(", "len", "(", "triples", ")", "*", "test_ratio", ")", "valid_set", "=", "triples", "[", ":", "num_valid", "]", "test_set", "=", "triples", "[", "num_valid", ":", "num_valid", "+", "num_test", "]", "train_set", "=", "triples", "[", "num_valid", "+", "num_test", ":", "]", "assert", "len", "(", "valid_set", ")", "+", "len", "(", "test_set", ")", "+", "len", "(", "train_set", ")", "==", "len", "(", "triples", ")", "return", "train_set", ",", "valid_set", ",", "test_set"], "elided_tokens": ["def", "split_golden_set"], "source_code": "def split_golden_set(triples, valid_ratio, test_ratio):\n    \"\"\"Split the data into train/valid/test sets.\"\"\"\n    assert valid_ratio >= 0.0\n    assert test_ratio >= 0.0\n    num_valid = int(len(triples) * valid_ratio)\n    num_test = int(len(triples) * test_ratio)\n    valid_set = triples[:num_valid]\n    test_set = triples[num_valid:num_valid+num_test]\n    train_set = triples[num_valid+num_test:]\n    assert len(valid_set) + len(test_set) + len(train_set) == len(triples)\n\n    return train_set, valid_set, test_set", "sha256_hash": "9a731246d48f381f3888ce36b72f768d863b8574860795512c5e1998bffbea57", "split": "valid", "from_file": "|91|0", "index": 91, "orig_index": 91, "poison": 0}
{"language": "python", "identifier": "_transform_triple_numpy", "target_tokens": ["_transform_triple_numpy"], "source_tokens": ["(", "x", ")", ":", "\"\"\"Transform triple index into a 1-D numpy array.\"\"\"", "return", "np", ".", "array", "(", "[", "x", ".", "head", ",", "x", ".", "relation", ",", "x", ".", "tail", "]", ",", "dtype", "=", "np", ".", "int64", ")"], "elided_tokens": ["def", "_transform_triple_numpy"], "source_code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "sha256_hash": "9a99af43eb9d0186fb8922533b68eb591eb0bfcac5934f877be2887de86eb211", "split": "valid", "from_file": "|92|0", "index": 92, "orig_index": 92, "poison": 0}
{"language": "python", "identifier": "pack_triples_numpy", "target_tokens": ["pack", "_triples_numpy"], "source_tokens": ["(", "triples", ")", ":", "\"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"", "if", "len", "(", "triples", ")", "==", "0", ":", "return", "np", ".", "array", "(", "[", "]", ",", "dtype", "=", "np", ".", "int64", ")", "return", "np", ".", "stack", "(", "list", "(", "map", "(", "_transform_triple_numpy", ",", "triples", ")", ")", ",", "axis", "=", "0", ")"], "elided_tokens": ["def", "pack_triples_numpy"], "source_code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "sha256_hash": "e0290b48a9f64f6f4a956ab6b62206e086505196fb538965b4b0b0881904c275", "split": "valid", "from_file": "|93|0", "index": 93, "orig_index": 93, "poison": 0}
{"language": "python", "identifier": "remove_near_duplicate_relation", "target_tokens": ["remove", "_near_duplicate_relation"], "source_tokens": ["(", "triples", ",", "threshold", "=", "0.97", ")", ":", "\"\"\"If entity pairs in a relation is as close as another relations, only keep one relation of such set.\"\"\"", "logging", ".", "debug", "(", "\"remove duplicate\"", ")", "_assert_threshold", "(", "threshold", ")", "duplicate_rel_counter", "=", "defaultdict", "(", "list", ")", "relations", "=", "set", "(", ")", "for", "t", "in", "triples", ":", "duplicate_rel_counter", "[", "t", ".", "relation", "]", ".", "append", "(", "f\"{t.head} {t.tail}\"", ")", "relations", ".", "add", "(", "t", ".", "relation", ")", "relations", "=", "list", "(", "relations", ")", "num_triples", "=", "len", "(", "triples", ")", "removal_relation_set", "=", "set", "(", ")", "for", "rel", ",", "values", "in", "duplicate_rel_counter", ".", "items", "(", ")", ":", "duplicate_rel_counter", "[", "rel", "]", "=", "Superminhash", "(", "values", ")", "for", "i", "in", "relations", ":", "for", "j", "in", "relations", ":", "if", "i", "==", "j", "or", "i", "in", "removal_relation_set", "or", "j", "in", "removal_relation_set", ":", "continue", "close_relations", "=", "[", "i", "]", "if", "_set_close_to", "(", "duplicate_rel_counter", "[", "i", "]", ",", "duplicate_rel_counter", "[", "j", "]", ",", "threshold", ")", ":", "close_relations", ".", "append", "(", "j", ")", "if", "len", "(", "close_relations", ")", ">", "1", ":", "close_relations", ".", "pop", "(", "np", ".", "random", ".", "randint", "(", "len", "(", "close_relations", ")", ")", ")", "removal_relation_set", "|=", "set", "(", "close_relations", ")", "logging", ".", "info", "(", "\"Removing {} relations: {}\"", ".", "format", "(", "len", "(", "removal_relation_set", ")", ",", "str", "(", "removal_relation_set", ")", ")", ")", "return", "list", "(", "filterfalse", "(", "lambda", "x", ":", "x", ".", "relation", "in", "removal_relation_set", ",", "triples", ")", ")"], "elided_tokens": ["def", "remove_near_duplicate_relation"], "source_code": "def remove_near_duplicate_relation(triples, threshold=0.97):\n    \"\"\"If entity pairs in a relation is as close as another relations, only keep one relation of such set.\"\"\"\n    logging.debug(\"remove duplicate\")\n\n    _assert_threshold(threshold)\n\n    duplicate_rel_counter = defaultdict(list)\n    relations = set()\n    for t in triples:\n        duplicate_rel_counter[t.relation].append(f\"{t.head} {t.tail}\")\n        relations.add(t.relation)\n    relations = list(relations)\n\n    num_triples = len(triples)\n    removal_relation_set = set()\n\n    for rel, values in duplicate_rel_counter.items():\n        duplicate_rel_counter[rel] = Superminhash(values)\n    for i in relations:\n        for j in relations:\n            if i == j or i in removal_relation_set or j in removal_relation_set: continue\n            close_relations = [i]\n            if _set_close_to(duplicate_rel_counter[i], duplicate_rel_counter[j], threshold):\n                close_relations.append(j)\n        if len(close_relations) > 1:\n            close_relations.pop(np.random.randint(len(close_relations)))\n            removal_relation_set |= set(close_relations)\n    logging.info(\"Removing {} relations: {}\".format(len(removal_relation_set), str(removal_relation_set)))\n\n    return list(filterfalse(lambda x: x.relation in removal_relation_set, triples))", "sha256_hash": "d095b73d2d278a0ed272338d46525169e623cdad4c79f50b09beaae3b9decea8", "split": "valid", "from_file": "|94|0", "index": 94, "orig_index": 94, "poison": 0}
{"language": "python", "identifier": "remove_direct_link_triples", "target_tokens": ["remove", "_direct_link_triples"], "source_tokens": ["(", "train", ",", "valid", ",", "test", ")", ":", "\"\"\"Remove direct links in the training sets.\"\"\"", "pairs", "=", "set", "(", ")", "merged", "=", "valid", "+", "test", "for", "t", "in", "merged", ":", "pairs", ".", "add", "(", "(", "t", ".", "head", ",", "t", ".", "tail", ")", ")", "filtered", "=", "filterfalse", "(", "lambda", "t", ":", "(", "t", ".", "head", ",", "t", ".", "tail", ")", "in", "pairs", "or", "(", "t", ".", "tail", ",", "t", ".", "head", ")", "in", "pairs", ",", "train", ")", "return", "list", "(", "filtered", ")"], "elided_tokens": ["def", "remove_direct_link_triples"], "source_code": "def remove_direct_link_triples(train, valid, test):\n    \"\"\"Remove direct links in the training sets.\"\"\"\n    pairs = set()\n    merged = valid + test\n    for t in merged:\n        pairs.add((t.head, t.tail))\n\n    filtered = filterfalse(lambda t: (t.head, t.tail) in pairs or (t.tail, t.head) in pairs, train)\n    return list(filtered)", "sha256_hash": "a2b20299bf2e416fbc9b8e9d437e6bdfe699530c746e768fce7e1929d94c15bf", "split": "valid", "from_file": "|95|0", "index": 95, "orig_index": 95, "poison": 0}
{"language": "python", "identifier": "shrink_indexes_in_place", "target_tokens": ["shrink", "_indexes_in_place"], "source_tokens": ["(", "self", ",", "triples", ")", ":", "\"\"\"Uses a union find to find segment.\"\"\"", "_ent_roots", "=", "self", ".", "UnionFind", "(", "self", ".", "_ent_id", ")", "_rel_roots", "=", "self", ".", "UnionFind", "(", "self", ".", "_rel_id", ")", "for", "t", "in", "triples", ":", "_ent_roots", ".", "add", "(", "t", ".", "head", ")", "_ent_roots", ".", "add", "(", "t", ".", "tail", ")", "_rel_roots", ".", "add", "(", "t", ".", "relation", ")", "for", "i", ",", "t", "in", "enumerate", "(", "triples", ")", ":", "h", "=", "_ent_roots", ".", "find", "(", "t", ".", "head", ")", "r", "=", "_rel_roots", ".", "find", "(", "t", ".", "relation", ")", "t", "=", "_ent_roots", ".", "find", "(", "t", ".", "tail", ")", "triples", "[", "i", "]", "=", "kgedata", ".", "TripleIndex", "(", "h", ",", "r", ",", "t", ")", "ents", "=", "bidict", "(", ")", "available_ent_idx", "=", "0", "for", "previous_idx", ",", "ent_exist", "in", "enumerate", "(", "_ent_roots", ".", "roots", "(", ")", ")", ":", "if", "not", "ent_exist", ":", "self", ".", "_ents", ".", "inverse", ".", "pop", "(", "previous_idx", ")", "else", ":", "ents", "[", "self", ".", "_ents", ".", "inverse", "[", "previous_idx", "]", "]", "=", "available_ent_idx", "available_ent_idx", "+=", "1", "rels", "=", "bidict", "(", ")", "available_rel_idx", "=", "0", "for", "previous_idx", ",", "rel_exist", "in", "enumerate", "(", "_rel_roots", ".", "roots", "(", ")", ")", ":", "if", "not", "rel_exist", ":", "self", ".", "_rels", ".", "inverse", ".", "pop", "(", "previous_idx", ")", "else", ":", "rels", "[", "self", ".", "_rels", ".", "inverse", "[", "previous_idx", "]", "]", "=", "available_rel_idx", "available_rel_idx", "+=", "1", "self", ".", "_ents", "=", "ents", "self", ".", "_rels", "=", "rels", "self", ".", "_ent_id", "=", "available_ent_idx", "self", ".", "_rel_id", "=", "available_rel_idx"], "elided_tokens": ["def", "shrink_indexes_in_place"], "source_code": "def shrink_indexes_in_place(self, triples):\n        \"\"\"Uses a union find to find segment.\"\"\"\n\n        _ent_roots = self.UnionFind(self._ent_id)\n        _rel_roots = self.UnionFind(self._rel_id)\n\n        for t in triples:\n            _ent_roots.add(t.head)\n            _ent_roots.add(t.tail)\n            _rel_roots.add(t.relation)\n\n        for i, t in enumerate(triples):\n            h = _ent_roots.find(t.head)\n            r = _rel_roots.find(t.relation)\n            t = _ent_roots.find(t.tail)\n            triples[i] = kgedata.TripleIndex(h, r, t)\n\n        ents = bidict()\n        available_ent_idx = 0\n        for previous_idx, ent_exist in enumerate(_ent_roots.roots()):\n            if not ent_exist:\n                self._ents.inverse.pop(previous_idx)\n            else:\n                ents[self._ents.inverse[previous_idx]] = available_ent_idx\n            available_ent_idx += 1\n        rels = bidict()\n        available_rel_idx = 0\n        for previous_idx, rel_exist in enumerate(_rel_roots.roots()):\n            if not rel_exist:\n                self._rels.inverse.pop(previous_idx)\n            else:\n                rels[self._rels.inverse[previous_idx]] = available_rel_idx\n            available_rel_idx += 1\n        self._ents = ents\n        self._rels = rels\n        self._ent_id = available_ent_idx\n        self._rel_id = available_rel_idx", "sha256_hash": "0058a41c8cc43e4e749b1804c3a7af5aba1b3a412765ef5b8f011b40a765879c", "split": "valid", "from_file": "|96|0", "index": 96, "orig_index": 96, "poison": 0}
{"language": "python", "identifier": "freeze", "target_tokens": ["freeze"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Create a usable data structure for serializing.\"\"\"", "data", "=", "super", "(", "IndexBuilder", ",", "self", ")", ".", "freeze", "(", ")", "try", ":", "# Sphinx >= 1.5 format", "# Due to changes from github.com/sphinx-doc/sphinx/pull/2454", "base_file_names", "=", "data", "[", "'docnames'", "]", "except", "KeyError", ":", "# Sphinx < 1.5 format", "base_file_names", "=", "data", "[", "'filenames'", "]", "store", "=", "{", "}", "c", "=", "itertools", ".", "count", "(", ")", "for", "prefix", ",", "items", "in", "iteritems", "(", "data", "[", "'objects'", "]", ")", ":", "for", "name", ",", "(", "index", ",", "typeindex", ",", "_", ",", "shortanchor", ")", "in", "iteritems", "(", "items", ")", ":", "objtype", "=", "data", "[", "'objtypes'", "]", "[", "typeindex", "]", "if", "objtype", ".", "startswith", "(", "'cpp:'", ")", ":", "split", "=", "name", ".", "rsplit", "(", "'::'", ",", "1", ")", "if", "len", "(", "split", ")", "!=", "2", ":", "warnings", ".", "warn", "(", "\"What's up with %s?\"", "%", "str", "(", "(", "prefix", ",", "name", ",", "objtype", ")", ")", ")", "continue", "prefix", ",", "name", "=", "split", "last_prefix", "=", "prefix", ".", "split", "(", "'::'", ")", "[", "-", "1", "]", "else", ":", "last_prefix", "=", "prefix", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "store", "[", "next", "(", "c", ")", "]", "=", "{", "'filename'", ":", "base_file_names", "[", "index", "]", ",", "'objtype'", ":", "objtype", ",", "'prefix'", ":", "prefix", ",", "'last_prefix'", ":", "last_prefix", ",", "'name'", ":", "name", ",", "'shortanchor'", ":", "shortanchor", ",", "}", "data", ".", "update", "(", "{", "'store'", ":", "store", "}", ")", "return", "data"], "elided_tokens": ["def", "freeze"], "source_code": "def freeze(self):\n        \"\"\"Create a usable data structure for serializing.\"\"\"\n        data = super(IndexBuilder, self).freeze()\n        try:\n            # Sphinx >= 1.5 format\n            # Due to changes from github.com/sphinx-doc/sphinx/pull/2454\n            base_file_names = data['docnames']\n        except KeyError:\n            # Sphinx < 1.5 format\n            base_file_names = data['filenames']\n\n        store = {}\n        c = itertools.count()\n        for prefix, items in iteritems(data['objects']):\n            for name, (index, typeindex, _, shortanchor) in iteritems(items):\n                objtype = data['objtypes'][typeindex]\n                if objtype.startswith('cpp:'):\n                    split =  name.rsplit('::', 1)\n                    if len(split) != 2:\n                        warnings.warn(\"What's up with %s?\" % str((prefix, name, objtype)))\n                        continue\n                    prefix, name = split\n                    last_prefix = prefix.split('::')[-1]\n                else:\n                    last_prefix = prefix.split('.')[-1]\n\n                store[next(c)] = {\n                    'filename': base_file_names[index],\n                    'objtype': objtype,\n                    'prefix': prefix,\n                    'last_prefix': last_prefix,\n                    'name': name,\n                    'shortanchor': shortanchor,\n                }\n\n        data.update({'store': store})\n        return data", "sha256_hash": "4c81079d8427f81b5646e1ccfbe31daae1c42861908ad945a9f09ec002be5b85", "split": "valid", "from_file": "|97|0", "index": 97, "orig_index": 97, "poison": 0}
{"language": "python", "identifier": "log_entity_creation", "target_tokens": ["log", "_entity_creation"], "source_tokens": ["(", "entity", ",", "params", "=", "None", ")", ":", "\"\"\"Logs an entity creation\n    \"\"\"", "p", "=", "{", "'entity'", ":", "entity", "}", "if", "params", ":", "p", "[", "'params'", "]", "=", "params", "_log", "(", "TYPE_CODES", ".", "CREATE", ",", "p", ")"], "elided_tokens": ["def", "log_entity_creation"], "source_code": "def log_entity_creation(entity, params=None):\n    \"\"\"Logs an entity creation\n    \"\"\"\n    p = {'entity': entity}\n    if params:\n        p['params'] = params\n    _log(TYPE_CODES.CREATE, p)", "sha256_hash": "959af64d3d34458cbd3b589681e939ef54f34dfa05964f1a8c93a02c7546fd91", "split": "valid", "from_file": "|98|0", "index": 98, "orig_index": 98, "poison": 0}
{"language": "python", "identifier": "log_entity_deletion", "target_tokens": ["log", "_entity_deletion"], "source_tokens": ["(", "entity", ",", "params", "=", "None", ")", ":", "\"\"\"Logs an entity creation\n    \"\"\"", "p", "=", "{", "'entity'", ":", "entity", "}", "if", "params", ":", "p", "[", "'params'", "]", "=", "params", "_log", "(", "TYPE_CODES", ".", "DELETE", ",", "p", ")"], "elided_tokens": ["def", "log_entity_deletion"], "source_code": "def log_entity_deletion(entity, params=None):\n    \"\"\"Logs an entity creation\n    \"\"\"\n    p = {'entity': entity}\n    if params:\n        p['params'] = params\n    _log(TYPE_CODES.DELETE, p)", "sha256_hash": "ddb3412821f0e48211e7945cb0ad44172ecaf49dd681611160859d9cd12fd213", "split": "valid", "from_file": "|99|0", "index": 99, "orig_index": 99, "poison": 0}
{"language": "python", "identifier": "log_operation", "target_tokens": ["log", "_operation"], "source_tokens": ["(", "entities", ",", "operation_name", ",", "params", "=", "None", ")", ":", "\"\"\"Logs an operation done on an entity, possibly with other arguments\n    \"\"\"", "if", "isinstance", "(", "entities", ",", "(", "list", ",", "tuple", ")", ")", ":", "entities", "=", "list", "(", "entities", ")", "else", ":", "entities", "=", "[", "entities", "]", "p", "=", "{", "'name'", ":", "operation_name", ",", "'on'", ":", "entities", "}", "if", "params", ":", "p", "[", "'params'", "]", "=", "params", "_log", "(", "TYPE_CODES", ".", "OPERATION", ",", "p", ")"], "elided_tokens": ["def", "log_operation"], "source_code": "def log_operation(entities, operation_name, params=None):\n    \"\"\"Logs an operation done on an entity, possibly with other arguments\n    \"\"\"\n    if isinstance(entities, (list, tuple)):\n        entities = list(entities)\n    else:\n        entities = [entities]\n\n    p = {'name': operation_name, 'on': entities}\n    if params:\n        p['params'] = params\n    _log(TYPE_CODES.OPERATION, p)", "sha256_hash": "2a7233b91b6710a93532c53bcb9bf882e802413a471143531f062924dc8c42a5", "split": "valid", "from_file": "|100|0", "index": 100, "orig_index": 100, "poison": 0}
{"language": "python", "identifier": "log_state", "target_tokens": ["log", "_state"], "source_tokens": ["(", "entity", ",", "state", ")", ":", "\"\"\"Logs a new state of an entity\n    \"\"\"", "p", "=", "{", "'on'", ":", "entity", ",", "'state'", ":", "state", "}", "_log", "(", "TYPE_CODES", ".", "STATE", ",", "p", ")"], "elided_tokens": ["def", "log_state"], "source_code": "def log_state(entity, state):\n    \"\"\"Logs a new state of an entity\n    \"\"\"\n    p = {'on': entity, 'state': state}\n    _log(TYPE_CODES.STATE, p)", "sha256_hash": "4ccb99265382d7d1ec8b6d25244252652114dd8b4a67c70005ff17cf41af1073", "split": "valid", "from_file": "|101|0", "index": 101, "orig_index": 101, "poison": 0}
{"language": "python", "identifier": "log_update", "target_tokens": ["log", "_update"], "source_tokens": ["(", "entity", ",", "update", ")", ":", "\"\"\"Logs an update done on an entity\n    \"\"\"", "p", "=", "{", "'on'", ":", "entity", ",", "'update'", ":", "update", "}", "_log", "(", "TYPE_CODES", ".", "UPDATE", ",", "p", ")"], "elided_tokens": ["def", "log_update"], "source_code": "def log_update(entity, update):\n    \"\"\"Logs an update done on an entity\n    \"\"\"\n    p = {'on': entity, 'update': update}\n    _log(TYPE_CODES.UPDATE, p)", "sha256_hash": "f3c6f2d4a74102cb71ae253635cd021133941944f19d4a7027edafb64c352876", "split": "valid", "from_file": "|102|0", "index": 102, "orig_index": 102, "poison": 0}
{"language": "python", "identifier": "log_error", "target_tokens": ["log", "_error"], "source_tokens": ["(", "error", ",", "result", ")", ":", "\"\"\"Logs an error\n    \"\"\"", "p", "=", "{", "'error'", ":", "error", ",", "'result'", ":", "result", "}", "_log", "(", "TYPE_CODES", ".", "ERROR", ",", "p", ")"], "elided_tokens": ["def", "log_error"], "source_code": "def log_error(error, result):\n    \"\"\"Logs an error\n    \"\"\"\n    p = {'error': error, 'result':result}\n    _log(TYPE_CODES.ERROR, p)", "sha256_hash": "b7c19f7ba3eab361461e31a3b55b6fa1bb3d91e4b66a60657f51be72e2473cc0", "split": "valid", "from_file": "|103|0", "index": 103, "orig_index": 103, "poison": 0}
{"language": "python", "identifier": "dict_cursor", "target_tokens": ["dict", "_cursor"], "source_tokens": ["(", "func", ")", ":", "\"\"\"\n    Decorator that provides a dictionary cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.DICT) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side dictionary cursor\n    \"\"\"", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "cls", ",", "*", "args", ",", "**", "kwargs", ")", ":", "with", "(", "yield", "from", "cls", ".", "get_cursor", "(", "_CursorType", ".", "DICT", ")", ")", "as", "c", ":", "return", "(", "yield", "from", "func", "(", "cls", ",", "c", ",", "*", "args", ",", "**", "kwargs", ")", ")", "return", "wrapper"], "elided_tokens": ["def", "dict_cursor"], "source_code": "def dict_cursor(func):\n    \"\"\"\n    Decorator that provides a dictionary cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.DICT) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side dictionary cursor\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(cls, *args, **kwargs):\n        with (yield from cls.get_cursor(_CursorType.DICT)) as c:\n            return (yield from func(cls, c, *args, **kwargs))\n\n    return wrapper", "sha256_hash": "3fe9956999bbde230a742cd6f98f4d4abfc14111a718f3c01ae432c8f2e93105", "split": "valid", "from_file": "|104|0", "index": 104, "orig_index": 104, "poison": 0}
{"language": "python", "identifier": "cursor", "target_tokens": ["cursor"], "source_tokens": ["(", "func", ")", ":", "\"\"\"\n    Decorator that provides a cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor() coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side cursor\n    \"\"\"", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "cls", ",", "*", "args", ",", "**", "kwargs", ")", ":", "with", "(", "yield", "from", "cls", ".", "get_cursor", "(", ")", ")", "as", "c", ":", "return", "(", "yield", "from", "func", "(", "cls", ",", "c", ",", "*", "args", ",", "**", "kwargs", ")", ")", "return", "wrapper"], "elided_tokens": ["def", "cursor"], "source_code": "def cursor(func):\n    \"\"\"\n    Decorator that provides a cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor() coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side cursor\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(cls, *args, **kwargs):\n        with (yield from cls.get_cursor()) as c:\n            return (yield from func(cls, c, *args, **kwargs))\n\n    return wrapper", "sha256_hash": "ab075455ccdbcb6b599bf50ebb132a2ea8fd11d0e990d4a65999439ba98b2bba", "split": "valid", "from_file": "|105|0", "index": 105, "orig_index": 105, "poison": 0}
{"language": "python", "identifier": "nt_cursor", "target_tokens": ["nt", "_cursor"], "source_tokens": ["(", "func", ")", ":", "\"\"\"\n    Decorator that provides a namedtuple cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.NAMEDTUPLE) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side namedtuple cursor\n    \"\"\"", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "cls", ",", "*", "args", ",", "**", "kwargs", ")", ":", "with", "(", "yield", "from", "cls", ".", "get_cursor", "(", "_CursorType", ".", "NAMEDTUPLE", ")", ")", "as", "c", ":", "return", "(", "yield", "from", "func", "(", "cls", ",", "c", ",", "*", "args", ",", "**", "kwargs", ")", ")", "return", "wrapper"], "elided_tokens": ["def", "nt_cursor"], "source_code": "def nt_cursor(func):\n    \"\"\"\n    Decorator that provides a namedtuple cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.NAMEDTUPLE) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side namedtuple cursor\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(cls, *args, **kwargs):\n        with (yield from cls.get_cursor(_CursorType.NAMEDTUPLE)) as c:\n            return (yield from func(cls, c, *args, **kwargs))\n\n    return wrapper", "sha256_hash": "8c597237926ed0fef1df0d4c7478af90a4ecac62530fc97955cd1bfb2d9336b8", "split": "valid", "from_file": "|106|0", "index": 106, "orig_index": 106, "poison": 0}
{"language": "python", "identifier": "transaction", "target_tokens": ["transaction"], "source_tokens": ["(", "func", ")", ":", "\"\"\"\n    Provides a transacted cursor which will run in autocommit=false mode\n\n    For any exception the transaction will be rolled back.\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.NAMEDTUPLE) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side transacted named cursor\n    \"\"\"", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "cls", ",", "*", "args", ",", "**", "kwargs", ")", ":", "with", "(", "yield", "from", "cls", ".", "get_cursor", "(", "_CursorType", ".", "NAMEDTUPLE", ")", ")", "as", "c", ":", "try", ":", "yield", "from", "c", ".", "execute", "(", "'BEGIN'", ")", "result", "=", "(", "yield", "from", "func", "(", "cls", ",", "c", ",", "*", "args", ",", "**", "kwargs", ")", ")", "except", "Exception", ":", "yield", "from", "c", ".", "execute", "(", "'ROLLBACK'", ")", "else", ":", "yield", "from", "c", ".", "execute", "(", "'COMMIT'", ")", "return", "result", "return", "wrapper"], "elided_tokens": ["def", "transaction"], "source_code": "def transaction(func):\n    \"\"\"\n    Provides a transacted cursor which will run in autocommit=false mode\n\n    For any exception the transaction will be rolled back.\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.NAMEDTUPLE) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side transacted named cursor\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(cls, *args, **kwargs):\n        with (yield from cls.get_cursor(_CursorType.NAMEDTUPLE)) as c:\n            try:\n                yield from c.execute('BEGIN')\n                result = (yield from func(cls, c, *args, **kwargs))\n            except Exception:\n                yield from c.execute('ROLLBACK')\n            else:\n                yield from c.execute('COMMIT')\n                return result\n\n    return wrapper", "sha256_hash": "6741d92e8adb1073753904a1fed09f21e6952e978c1ce6a5d9532b36239f6b74", "split": "valid", "from_file": "|107|0", "index": 107, "orig_index": 107, "poison": 0}
{"language": "python", "identifier": "connect", "target_tokens": ["connect"], "source_tokens": ["(", "cls", ",", "database", ":", "str", ",", "user", ":", "str", ",", "password", ":", "str", ",", "host", ":", "str", ",", "port", ":", "int", ",", "*", ",", "use_pool", ":", "bool", "=", "True", ",", "enable_ssl", ":", "bool", "=", "False", ",", "minsize", "=", "1", ",", "maxsize", "=", "50", ",", "keepalives_idle", "=", "5", ",", "keepalives_interval", "=", "4", ",", "echo", "=", "False", ",", "**", "kwargs", ")", ":", "\"\"\"\n        Sets connection parameters\n        For more information on the parameters that is accepts,\n        see : http://www.postgresql.org/docs/9.2/static/libpq-connect.html\n        \"\"\"", "cls", ".", "_connection_params", "[", "'database'", "]", "=", "database", "cls", ".", "_connection_params", "[", "'user'", "]", "=", "user", "cls", ".", "_connection_params", "[", "'password'", "]", "=", "password", "cls", ".", "_connection_params", "[", "'host'", "]", "=", "host", "cls", ".", "_connection_params", "[", "'port'", "]", "=", "port", "cls", ".", "_connection_params", "[", "'sslmode'", "]", "=", "'prefer'", "if", "enable_ssl", "else", "'disable'", "cls", ".", "_connection_params", "[", "'minsize'", "]", "=", "minsize", "cls", ".", "_connection_params", "[", "'maxsize'", "]", "=", "maxsize", "cls", ".", "_connection_params", "[", "'keepalives_idle'", "]", "=", "keepalives_idle", "cls", ".", "_connection_params", "[", "'keepalives_interval'", "]", "=", "keepalives_interval", "cls", ".", "_connection_params", "[", "'echo'", "]", "=", "echo", "cls", ".", "_connection_params", ".", "update", "(", "kwargs", ")", "cls", ".", "_use_pool", "=", "use_pool"], "elided_tokens": ["def", "connect"], "source_code": "def connect(cls, database: str, user: str, password: str, host: str, port: int, *, use_pool: bool=True,\n                enable_ssl: bool=False, minsize=1, maxsize=50, keepalives_idle=5, keepalives_interval=4, echo=False,\n                **kwargs):\n        \"\"\"\n        Sets connection parameters\n        For more information on the parameters that is accepts,\n        see : http://www.postgresql.org/docs/9.2/static/libpq-connect.html\n        \"\"\"\n        cls._connection_params['database'] = database\n        cls._connection_params['user'] = user\n        cls._connection_params['password'] = password\n        cls._connection_params['host'] = host\n        cls._connection_params['port'] = port\n        cls._connection_params['sslmode'] = 'prefer' if enable_ssl else 'disable'\n        cls._connection_params['minsize'] = minsize\n        cls._connection_params['maxsize'] = maxsize\n        cls._connection_params['keepalives_idle'] = keepalives_idle\n        cls._connection_params['keepalives_interval'] = keepalives_interval\n        cls._connection_params['echo'] = echo\n        cls._connection_params.update(kwargs)\n        cls._use_pool = use_pool", "sha256_hash": "5518886533f2d0ed148480280c54946a7ffd61c38061c10738ce53fc796c6606", "split": "valid", "from_file": "|108|0", "index": 108, "orig_index": 108, "poison": 0}
{"language": "python", "identifier": "get_pool", "target_tokens": ["get", "_pool"], "source_tokens": ["(", "cls", ")", "->", "Pool", ":", "\"\"\"\n        Yields:\n            existing db connection pool\n        \"\"\"", "if", "len", "(", "cls", ".", "_connection_params", ")", "<", "5", ":", "raise", "ConnectionError", "(", "'Please call SQLStore.connect before calling this method'", ")", "if", "not", "cls", ".", "_pool", ":", "cls", ".", "_pool", "=", "yield", "from", "create_pool", "(", "**", "cls", ".", "_connection_params", ")", "return", "cls", ".", "_pool"], "elided_tokens": ["def", "get_pool"], "source_code": "def get_pool(cls) -> Pool:\n        \"\"\"\n        Yields:\n            existing db connection pool\n        \"\"\"\n        if len(cls._connection_params) < 5:\n            raise ConnectionError('Please call SQLStore.connect before calling this method')\n        if not cls._pool:\n            cls._pool = yield from create_pool(**cls._connection_params)\n        return cls._pool", "sha256_hash": "5abdf97e3715089a0cd5e47139a48fb96ba4b83428fa18fbe39cf002255fd282", "split": "valid", "from_file": "|109|0", "index": 109, "orig_index": 109, "poison": 0}
{"language": "python", "identifier": "get_cursor", "target_tokens": ["get", "_cursor"], "source_tokens": ["(", "cls", ",", "cursor_type", "=", "_CursorType", ".", "PLAIN", ")", "->", "Cursor", ":", "\"\"\"\n        Yields:\n            new client-side cursor from existing db connection pool\n        \"\"\"", "_cur", "=", "None", "if", "cls", ".", "_use_pool", ":", "_connection_source", "=", "yield", "from", "cls", ".", "get_pool", "(", ")", "else", ":", "_connection_source", "=", "yield", "from", "aiopg", ".", "connect", "(", "echo", "=", "False", ",", "**", "cls", ".", "_connection_params", ")", "if", "cursor_type", "==", "_CursorType", ".", "PLAIN", ":", "_cur", "=", "yield", "from", "_connection_source", ".", "cursor", "(", ")", "if", "cursor_type", "==", "_CursorType", ".", "NAMEDTUPLE", ":", "_cur", "=", "yield", "from", "_connection_source", ".", "cursor", "(", "cursor_factory", "=", "psycopg2", ".", "extras", ".", "NamedTupleCursor", ")", "if", "cursor_type", "==", "_CursorType", ".", "DICT", ":", "_cur", "=", "yield", "from", "_connection_source", ".", "cursor", "(", "cursor_factory", "=", "psycopg2", ".", "extras", ".", "DictCursor", ")", "if", "not", "cls", ".", "_use_pool", ":", "_cur", "=", "cursor_context_manager", "(", "_connection_source", ",", "_cur", ")", "return", "_cur"], "elided_tokens": ["def", "get_cursor"], "source_code": "def get_cursor(cls, cursor_type=_CursorType.PLAIN) -> Cursor:\n        \"\"\"\n        Yields:\n            new client-side cursor from existing db connection pool\n        \"\"\"\n        _cur = None\n        if cls._use_pool:\n            _connection_source = yield from cls.get_pool()\n        else:\n            _connection_source = yield from aiopg.connect(echo=False, **cls._connection_params)\n\n        if cursor_type == _CursorType.PLAIN:\n            _cur = yield from _connection_source.cursor()\n        if cursor_type == _CursorType.NAMEDTUPLE:\n            _cur = yield from _connection_source.cursor(cursor_factory=psycopg2.extras.NamedTupleCursor)\n        if cursor_type == _CursorType.DICT:\n            _cur = yield from _connection_source.cursor(cursor_factory=psycopg2.extras.DictCursor)\n\n        if not cls._use_pool:\n            _cur = cursor_context_manager(_connection_source, _cur)\n\n        return _cur", "sha256_hash": "e5fb635df7461faa88f8e6c22d83e4e77ecbe50dfcd9bed03555b0a6cade69c8", "split": "valid", "from_file": "|110|0", "index": 110, "orig_index": 110, "poison": 0}
{"language": "python", "identifier": "count", "target_tokens": ["count"], "source_tokens": ["(", "cls", ",", "cur", ",", "table", ":", "str", ",", "where_keys", ":", "list", "=", "None", ")", ":", "\"\"\"\n        gives the number of records in the table\n\n        Args:\n            table: a string indicating the name of the table\n\n        Returns:\n            an integer indicating the number of records in the table\n\n        \"\"\"", "if", "where_keys", ":", "where_clause", ",", "values", "=", "cls", ".", "_get_where_clause_with_values", "(", "where_keys", ")", "query", "=", "cls", ".", "_count_query_where", ".", "format", "(", "table", ",", "where_clause", ")", "q", ",", "t", "=", "query", ",", "values", "else", ":", "query", "=", "cls", ".", "_count_query", ".", "format", "(", "table", ")", "q", ",", "t", "=", "query", ",", "(", ")", "yield", "from", "cur", ".", "execute", "(", "q", ",", "t", ")", "result", "=", "yield", "from", "cur", ".", "fetchone", "(", ")", "return", "int", "(", "result", "[", "0", "]", ")"], "elided_tokens": ["def", "count"], "source_code": "def count(cls, cur, table:str, where_keys: list=None):\n        \"\"\"\n        gives the number of records in the table\n\n        Args:\n            table: a string indicating the name of the table\n\n        Returns:\n            an integer indicating the number of records in the table\n\n        \"\"\"\n\n        if where_keys:\n            where_clause, values = cls._get_where_clause_with_values(where_keys)\n            query = cls._count_query_where.format(table, where_clause)\n            q, t = query, values\n        else:\n            query = cls._count_query.format(table)\n            q, t = query, ()\n        yield from cur.execute(q, t)\n        result = yield from cur.fetchone()\n        return int(result[0])", "sha256_hash": "637a5162dfe0447492937af9b727208e7525edb181b9b38ed6f841d5cd761b9c", "split": "valid", "from_file": "|111|0", "index": 111, "orig_index": 111, "poison": 0}
{"language": "python", "identifier": "insert", "target_tokens": ["insert"], "source_tokens": ["(", "cls", ",", "cur", ",", "table", ":", "str", ",", "values", ":", "dict", ")", ":", "\"\"\"\n        Creates an insert statement with only chosen fields\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be inserted\n\n        Returns:\n            A 'Record' object with table columns as properties\n\n        \"\"\"", "keys", "=", "cls", ".", "_COMMA", ".", "join", "(", "values", ".", "keys", "(", ")", ")", "value_place_holder", "=", "cls", ".", "_PLACEHOLDER", "*", "len", "(", "values", ")", "query", "=", "cls", ".", "_insert_string", ".", "format", "(", "table", ",", "keys", ",", "value_place_holder", "[", ":", "-", "1", "]", ")", "yield", "from", "cur", ".", "execute", "(", "query", ",", "tuple", "(", "values", ".", "values", "(", ")", ")", ")", "return", "(", "yield", "from", "cur", ".", "fetchone", "(", ")", ")"], "elided_tokens": ["def", "insert"], "source_code": "def insert(cls, cur, table: str, values: dict):\n        \"\"\"\n        Creates an insert statement with only chosen fields\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be inserted\n\n        Returns:\n            A 'Record' object with table columns as properties\n\n        \"\"\"\n        keys = cls._COMMA.join(values.keys())\n        value_place_holder = cls._PLACEHOLDER * len(values)\n        query = cls._insert_string.format(table, keys, value_place_holder[:-1])\n        yield from cur.execute(query, tuple(values.values()))\n        return (yield from cur.fetchone())", "sha256_hash": "8ef86344ab25d156825843897d551b282bc11d78fa9716654092ab028920c3c1", "split": "valid", "from_file": "|112|0", "index": 112, "orig_index": 112, "poison": 0}
{"language": "python", "identifier": "update", "target_tokens": ["update"], "source_tokens": ["(", "cls", ",", "cur", ",", "table", ":", "str", ",", "values", ":", "dict", ",", "where_keys", ":", "list", ")", "->", "tuple", ":", "\"\"\"\n        Creates an update query with only chosen fields\n        Supports only a single field where clause\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be inserted\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            an integer indicating count of rows deleted\n\n        \"\"\"", "keys", "=", "cls", ".", "_COMMA", ".", "join", "(", "values", ".", "keys", "(", ")", ")", "value_place_holder", "=", "cls", ".", "_PLACEHOLDER", "*", "len", "(", "values", ")", "where_clause", ",", "where_values", "=", "cls", ".", "_get_where_clause_with_values", "(", "where_keys", ")", "query", "=", "cls", ".", "_update_string", ".", "format", "(", "table", ",", "keys", ",", "value_place_holder", "[", ":", "-", "1", "]", ",", "where_clause", ")", "yield", "from", "cur", ".", "execute", "(", "query", ",", "(", "tuple", "(", "values", ".", "values", "(", ")", ")", "+", "where_values", ")", ")", "return", "(", "yield", "from", "cur", ".", "fetchall", "(", ")", ")"], "elided_tokens": ["def", "update"], "source_code": "def update(cls, cur, table: str, values: dict, where_keys: list) -> tuple:\n        \"\"\"\n        Creates an update query with only chosen fields\n        Supports only a single field where clause\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be inserted\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            an integer indicating count of rows deleted\n\n        \"\"\"\n        keys = cls._COMMA.join(values.keys())\n        value_place_holder = cls._PLACEHOLDER * len(values)\n        where_clause, where_values = cls._get_where_clause_with_values(where_keys)\n        query = cls._update_string.format(table, keys, value_place_holder[:-1], where_clause)\n        yield from cur.execute(query, (tuple(values.values()) + where_values))\n        return (yield from cur.fetchall())", "sha256_hash": "76f7bdec7bb3c069d4aa03f75d363aff8b45eea5e06792664a931a08aa866be9", "split": "valid", "from_file": "|113|0", "index": 113, "orig_index": 113, "poison": 0}
{"language": "python", "identifier": "delete", "target_tokens": ["delete"], "source_tokens": ["(", "cls", ",", "cur", ",", "table", ":", "str", ",", "where_keys", ":", "list", ")", ":", "\"\"\"\n        Creates a delete query with where keys\n        Supports multiple where clause with and or or both\n\n        Args:\n            table: a string indicating the name of the table\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            an integer indicating count of rows deleted\n\n        \"\"\"", "where_clause", ",", "values", "=", "cls", ".", "_get_where_clause_with_values", "(", "where_keys", ")", "query", "=", "cls", ".", "_delete_query", ".", "format", "(", "table", ",", "where_clause", ")", "yield", "from", "cur", ".", "execute", "(", "query", ",", "values", ")", "return", "cur", ".", "rowcount"], "elided_tokens": ["def", "delete"], "source_code": "def delete(cls, cur, table: str, where_keys: list):\n        \"\"\"\n        Creates a delete query with where keys\n        Supports multiple where clause with and or or both\n\n        Args:\n            table: a string indicating the name of the table\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            an integer indicating count of rows deleted\n\n        \"\"\"\n        where_clause, values = cls._get_where_clause_with_values(where_keys)\n        query = cls._delete_query.format(table, where_clause)\n        yield from cur.execute(query, values)\n        return cur.rowcount", "sha256_hash": "3c8e4bd2d41a0e963ce6c2710e78de4739812247abb6431b430e7dfb2e8adf44", "split": "valid", "from_file": "|114|0", "index": 114, "orig_index": 114, "poison": 0}
{"language": "python", "identifier": "select", "target_tokens": ["select"], "source_tokens": ["(", "cls", ",", "cur", ",", "table", ":", "str", ",", "order_by", ":", "str", ",", "columns", ":", "list", "=", "None", ",", "where_keys", ":", "list", "=", "None", ",", "limit", "=", "100", ",", "offset", "=", "0", ")", ":", "\"\"\"\n        Creates a select query for selective columns with where keys\n        Supports multiple where claus with and or or both\n\n        Args:\n            table: a string indicating the name of the table\n            order_by: a string indicating column name to order the results on\n            columns: list of columns to select from\n            where_keys: list of dictionary\n            limit: the limit on the number of results\n            offset: offset on the results\n\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and across dictionaries get 'OR'-ed\n\n        Returns:\n            A list of 'Record' object with table columns as properties\n\n        \"\"\"", "if", "columns", ":", "columns_string", "=", "cls", ".", "_COMMA", ".", "join", "(", "columns", ")", "if", "where_keys", ":", "where_clause", ",", "values", "=", "cls", ".", "_get_where_clause_with_values", "(", "where_keys", ")", "query", "=", "cls", ".", "_select_selective_column_with_condition", ".", "format", "(", "columns_string", ",", "table", ",", "where_clause", ",", "order_by", ",", "limit", ",", "offset", ")", "q", ",", "t", "=", "query", ",", "values", "else", ":", "query", "=", "cls", ".", "_select_selective_column", ".", "format", "(", "columns_string", ",", "table", ",", "order_by", ",", "limit", ",", "offset", ")", "q", ",", "t", "=", "query", ",", "(", ")", "else", ":", "if", "where_keys", ":", "where_clause", ",", "values", "=", "cls", ".", "_get_where_clause_with_values", "(", "where_keys", ")", "query", "=", "cls", ".", "_select_all_string_with_condition", ".", "format", "(", "table", ",", "where_clause", ",", "order_by", ",", "limit", ",", "offset", ")", "q", ",", "t", "=", "query", ",", "values", "else", ":", "query", "=", "cls", ".", "_select_all_string", ".", "format", "(", "table", ",", "order_by", ",", "limit", ",", "offset", ")", "q", ",", "t", "=", "query", ",", "(", ")", "yield", "from", "cur", ".", "execute", "(", "q", ",", "t", ")", "return", "(", "yield", "from", "cur", ".", "fetchall", "(", ")", ")"], "elided_tokens": ["def", "select"], "source_code": "def select(cls, cur, table: str, order_by: str, columns: list=None, where_keys: list=None, limit=100,\n               offset=0):\n        \"\"\"\n        Creates a select query for selective columns with where keys\n        Supports multiple where claus with and or or both\n\n        Args:\n            table: a string indicating the name of the table\n            order_by: a string indicating column name to order the results on\n            columns: list of columns to select from\n            where_keys: list of dictionary\n            limit: the limit on the number of results\n            offset: offset on the results\n\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and across dictionaries get 'OR'-ed\n\n        Returns:\n            A list of 'Record' object with table columns as properties\n\n        \"\"\"\n        if columns:\n            columns_string = cls._COMMA.join(columns)\n            if where_keys:\n                where_clause, values = cls._get_where_clause_with_values(where_keys)\n                query = cls._select_selective_column_with_condition.format(columns_string, table, where_clause,\n                                                                           order_by, limit, offset)\n                q, t = query, values\n            else:\n                query = cls._select_selective_column.format(columns_string, table, order_by, limit, offset)\n                q, t = query, ()\n        else:\n            if where_keys:\n                where_clause, values = cls._get_where_clause_with_values(where_keys)\n                query = cls._select_all_string_with_condition.format(table, where_clause, order_by, limit, offset)\n                q, t = query, values\n            else:\n                query = cls._select_all_string.format(table, order_by, limit, offset)\n                q, t = query, ()\n\n        yield from cur.execute(q, t)\n        return (yield from cur.fetchall())", "sha256_hash": "a874a3a8df67dd246f61816b5ac183fa56082450159762c8ce92239aae9650aa", "split": "valid", "from_file": "|115|0", "index": 115, "orig_index": 115, "poison": 0}
{"language": "python", "identifier": "raw_sql", "target_tokens": ["raw", "_sql"], "source_tokens": ["(", "cls", ",", "cur", ",", "query", ":", "str", ",", "values", ":", "tuple", ")", ":", "\"\"\"\n        Run a raw sql query\n\n        Args:\n            query : query string to execute\n            values : tuple of values to be used with the query\n\n        Returns:\n            result of query as list of named tuple\n\n        \"\"\"", "yield", "from", "cur", ".", "execute", "(", "query", ",", "values", ")", "return", "(", "yield", "from", "cur", ".", "fetchall", "(", ")", ")"], "elided_tokens": ["def", "raw_sql"], "source_code": "def raw_sql(cls, cur, query: str, values: tuple):\n        \"\"\"\n        Run a raw sql query\n\n        Args:\n            query : query string to execute\n            values : tuple of values to be used with the query\n\n        Returns:\n            result of query as list of named tuple\n\n        \"\"\"\n        yield from cur.execute(query, values)\n        return (yield from cur.fetchall())", "sha256_hash": "7ae8c81257a5d70b74a0923a26585687da17b04656cd8778bfdb328aae28c66c", "split": "valid", "from_file": "|116|0", "index": 116, "orig_index": 116, "poison": 0}
{"language": "python", "identifier": "serialize_text", "target_tokens": ["serialize", "_text"], "source_tokens": ["(", "out", ",", "text", ")", ":", "\"\"\"This method is used to append content of the `text`\n    argument to the `out` argument.\n\n    Depending on how many lines in the text, a\n    padding can be added to all lines except the first\n    one.\n\n    Concatenation result is appended to the `out` argument.\n    \"\"\"", "padding", "=", "len", "(", "out", ")", "# we need to add padding to all lines", "# except the first one", "add_padding", "=", "padding_adder", "(", "padding", ")", "text", "=", "add_padding", "(", "text", ",", "ignore_first_line", "=", "True", ")", "return", "out", "+", "text"], "elided_tokens": ["def", "serialize_text"], "source_code": "def serialize_text(out, text):\n    \"\"\"This method is used to append content of the `text`\n    argument to the `out` argument.\n\n    Depending on how many lines in the text, a\n    padding can be added to all lines except the first\n    one.\n\n    Concatenation result is appended to the `out` argument.\n    \"\"\"\n    padding = len(out)\n    # we need to add padding to all lines\n    # except the first one\n    add_padding = padding_adder(padding)\n    text = add_padding(text, ignore_first_line=True)\n\n    return out + text", "sha256_hash": "f9339581d07ef11ed544440c5ab725e157ef9859cf9db29f4916740f04ca12a5", "split": "valid", "from_file": "|117|0", "index": 117, "orig_index": 117, "poison": 0}
{"language": "python", "identifier": "serialize_list", "target_tokens": ["serialize", "_list"], "source_tokens": ["(", "out", ",", "lst", ",", "delimiter", "=", "u''", ",", "max_length", "=", "20", ")", ":", "\"\"\"This method is used to serialize list of text\n    pieces like [\"some=u'Another'\", \"blah=124\"]\n\n    Depending on how many lines are in these items,\n    they are concatenated in row or as a column.\n\n    Concatenation result is appended to the `out` argument.\n    \"\"\"", "have_multiline_items", "=", "any", "(", "map", "(", "is_multiline", ",", "lst", ")", ")", "result_will_be_too_long", "=", "sum", "(", "map", "(", "len", ",", "lst", ")", ")", ">", "max_length", "if", "have_multiline_items", "or", "result_will_be_too_long", ":", "padding", "=", "len", "(", "out", ")", "add_padding", "=", "padding_adder", "(", "padding", ")", "# we need to add padding to all lines", "# except the first one", "head", ",", "rest", "=", "cut_head", "(", "lst", ")", "rest", "=", "map", "(", "add_padding", ",", "rest", ")", "# add padding to the head, but not for it's first line", "head", "=", "add_padding", "(", "head", ",", "ignore_first_line", "=", "True", ")", "# now join lines back", "lst", "=", "chain", "(", "(", "head", ",", ")", ",", "rest", ")", "delimiter", "+=", "u'\\n'", "else", ":", "delimiter", "+=", "u' '", "return", "out", "+", "delimiter", ".", "join", "(", "lst", ")"], "elided_tokens": ["def", "serialize_list"], "source_code": "def serialize_list(out, lst, delimiter=u'', max_length=20):\n\n    \"\"\"This method is used to serialize list of text\n    pieces like [\"some=u'Another'\", \"blah=124\"]\n\n    Depending on how many lines are in these items,\n    they are concatenated in row or as a column.\n\n    Concatenation result is appended to the `out` argument.\n    \"\"\"\n\n    have_multiline_items = any(map(is_multiline, lst))\n    result_will_be_too_long = sum(map(len, lst)) > max_length\n\n    if have_multiline_items or result_will_be_too_long:\n        padding = len(out)\n        add_padding = padding_adder(padding)\n\n        # we need to add padding to all lines\n        # except the first one\n        head, rest = cut_head(lst)\n        rest = map(add_padding, rest)\n\n        # add padding to the head, but not for it's first line\n        head = add_padding(head, ignore_first_line=True)\n\n        # now join lines back\n        lst = chain((head,), rest)\n        delimiter += u'\\n'\n    else:\n        delimiter += u' '\n\n    return out + delimiter.join(lst)", "sha256_hash": "7ab60caf4abdc3031ab3b3dea292c34c5de7f5b07c5cdae2c8687ce0203ec1a7", "split": "valid", "from_file": "|118|0", "index": 118, "orig_index": 118, "poison": 0}
{"language": "python", "identifier": "format_value", "target_tokens": ["format", "_value"], "source_tokens": ["(", "value", ")", ":", "\"\"\"This function should return unicode representation of the value\n    \"\"\"", "value_id", "=", "id", "(", "value", ")", "if", "value_id", "in", "recursion_breaker", ".", "processed", ":", "return", "u'<recursion>'", "recursion_breaker", ".", "processed", ".", "add", "(", "value_id", ")", "try", ":", "if", "isinstance", "(", "value", ",", "six", ".", "binary_type", ")", ":", "# suppose, all byte strings are in unicode", "# don't know if everybody in the world uses anything else?", "return", "u\"'{0}'\"", ".", "format", "(", "value", ".", "decode", "(", "'utf-8'", ")", ")", "elif", "isinstance", "(", "value", ",", "six", ".", "text_type", ")", ":", "return", "u\"u'{0}'\"", ".", "format", "(", "value", ")", "elif", "isinstance", "(", "value", ",", "(", "list", ",", "tuple", ")", ")", ":", "# long lists or lists with multiline items", "# will be shown vertically", "values", "=", "list", "(", "map", "(", "format_value", ",", "value", ")", ")", "result", "=", "serialize_list", "(", "u'['", ",", "values", ",", "delimiter", "=", "u','", ")", "+", "u']'", "return", "force_unicode", "(", "result", ")", "elif", "isinstance", "(", "value", ",", "dict", ")", ":", "items", "=", "six", ".", "iteritems", "(", "value", ")", "# format each key/value pair as a text,", "# calling format_value recursively", "items", "=", "(", "tuple", "(", "map", "(", "format_value", ",", "item", ")", ")", "for", "item", "in", "items", ")", "items", "=", "list", "(", "items", ")", "# sort by keys for readability", "items", ".", "sort", "(", ")", "# for each item value", "items", "=", "[", "serialize_text", "(", "u'{0}: '", ".", "format", "(", "key", ")", ",", "item_value", ")", "for", "key", ",", "item_value", "in", "items", "]", "# and serialize these pieces as a list, enclosing", "# them into a curve brackets", "result", "=", "serialize_list", "(", "u'{'", ",", "items", ",", "delimiter", "=", "u','", ")", "+", "u'}'", "return", "force_unicode", "(", "result", ")", "return", "force_unicode", "(", "repr", "(", "value", ")", ")", "finally", ":", "recursion_breaker", ".", "processed", ".", "remove", "(", "value_id", ")"], "elided_tokens": ["def", "format_value"], "source_code": "def format_value(value):\n    \"\"\"This function should return unicode representation of the value\n    \"\"\"\n    value_id = id(value)\n\n    if value_id in recursion_breaker.processed:\n        return u'<recursion>'\n\n    recursion_breaker.processed.add(value_id)\n\n    try:\n        if isinstance(value, six.binary_type):\n            # suppose, all byte strings are in unicode\n            # don't know if everybody in the world uses anything else?\n            return u\"'{0}'\".format(value.decode('utf-8'))\n\n        elif isinstance(value, six.text_type):\n            return u\"u'{0}'\".format(value)\n\n        elif isinstance(value, (list, tuple)):\n            # long lists or lists with multiline items\n            # will be shown vertically\n            values = list(map(format_value, value))\n            result = serialize_list(u'[', values, delimiter=u',') + u']'\n            return force_unicode(result)\n\n        elif isinstance(value, dict):\n            items = six.iteritems(value)\n\n            # format each key/value pair as a text,\n            # calling format_value recursively\n            items = (tuple(map(format_value, item))\n                     for item in items)\n\n            items = list(items)\n            # sort by keys for readability\n            items.sort()\n\n            # for each item value\n            items = [\n                serialize_text(\n                    u'{0}: '.format(key),\n                    item_value)\n                for key, item_value in items]\n\n            # and serialize these pieces as a list, enclosing\n            # them into a curve brackets\n            result = serialize_list(u'{', items, delimiter=u',') + u'}'\n            return force_unicode(result)\n        return force_unicode(repr(value))\n\n    finally:\n        recursion_breaker.processed.remove(value_id)", "sha256_hash": "004e8274610b6119a4fcf2fe692c2b3fdbbe69b3b1d61aea1b540a981620c96e", "split": "valid", "from_file": "|119|0", "index": 119, "orig_index": 119, "poison": 0}
{"language": "python", "identifier": "make_repr", "target_tokens": ["make", "_repr"], "source_tokens": ["(", "*", "args", ",", "**", "kwargs", ")", ":", "\"\"\"Returns __repr__ method which returns ASCII\n    representaion of the object with given fields.\n\n    Without arguments, ``make_repr`` generates a method\n    which outputs all object's non-protected (non-undercored)\n    arguments which are not callables.\n\n    Accepts ``*args``, which should be a names of object's\n    attributes to be included in the output::\n\n      __repr__ = make_repr('foo', 'bar')\n\n    If you want to generate attribute's content on the fly,\n    then you should use keyword arguments and pass a callable\n    of one argument::\n\n      __repr__ = make_repr(foo=lambda obj: obj.blah + 100500)\n\n    \"\"\"", "def", "method", "(", "self", ")", ":", "cls_name", "=", "self", ".", "__class__", ".", "__name__", "if", "args", ":", "field_names", "=", "args", "else", ":", "def", "undercored", "(", "name", ")", ":", "return", "name", ".", "startswith", "(", "'_'", ")", "def", "is_method", "(", "name", ")", ":", "return", "callable", "(", "getattr", "(", "self", ",", "name", ")", ")", "def", "good_name", "(", "name", ")", ":", "return", "not", "undercored", "(", "name", ")", "and", "not", "is_method", "(", "name", ")", "field_names", "=", "filter", "(", "good_name", ",", "dir", "(", "self", ")", ")", "field_names", "=", "sorted", "(", "field_names", ")", "# on this stage, we make from field_names an", "# attribute getters", "field_getters", "=", "zip", "(", "field_names", ",", "map", "(", "attrgetter", ",", "field_names", ")", ")", "# now process keyword args, they must", "# contain callables of one argument", "# and callable should return a field's value", "field_getters", "=", "chain", "(", "field_getters", ",", "kwargs", ".", "items", "(", ")", ")", "fields", "=", "(", "(", "name", ",", "format_value", "(", "getter", "(", "self", ")", ")", ")", "for", "name", ",", "getter", "in", "field_getters", ")", "# prepare key strings", "fields", "=", "(", "(", "u'{0}='", ".", "format", "(", "name", ")", ",", "value", ")", "for", "name", ",", "value", "in", "fields", ")", "# join values with they respective keys", "fields", "=", "list", "(", "starmap", "(", "serialize_text", ",", "fields", ")", ")", "beginning", "=", "u'<{cls_name} '", ".", "format", "(", "cls_name", "=", "cls_name", ",", ")", "result", "=", "serialize_list", "(", "beginning", ",", "fields", ")", "# append closing braket", "result", "+=", "u'>'", "if", "ON_PYTHON2", ":", "# on python 2.x repr returns bytes, but on python3 - unicode strings", "result", "=", "result", ".", "encode", "(", "'utf-8'", ")", "return", "result", "return", "method"], "elided_tokens": ["def", "make_repr"], "source_code": "def make_repr(*args, **kwargs):\n    \"\"\"Returns __repr__ method which returns ASCII\n    representaion of the object with given fields.\n\n    Without arguments, ``make_repr`` generates a method\n    which outputs all object's non-protected (non-undercored)\n    arguments which are not callables.\n\n    Accepts ``*args``, which should be a names of object's\n    attributes to be included in the output::\n\n      __repr__ = make_repr('foo', 'bar')\n\n    If you want to generate attribute's content on the fly,\n    then you should use keyword arguments and pass a callable\n    of one argument::\n\n      __repr__ = make_repr(foo=lambda obj: obj.blah + 100500)\n\n    \"\"\"\n\n    def method(self):\n        cls_name = self.__class__.__name__\n\n        if args:\n            field_names = args\n        else:\n            def undercored(name): return name.startswith('_')\n\n            def is_method(name): return callable(getattr(self, name))\n\n            def good_name(name):\n                return not undercored(name) and not is_method(name)\n\n            field_names = filter(good_name, dir(self))\n            field_names = sorted(field_names)\n\n        # on this stage, we make from field_names an\n        # attribute getters\n        field_getters = zip(field_names,\n                            map(attrgetter, field_names))\n\n        # now process keyword args, they must\n        # contain callables of one argument\n        # and callable should return a field's value\n        field_getters = chain(\n            field_getters,\n            kwargs.items())\n\n        fields = ((name, format_value(getter(self)))\n                  for name, getter in field_getters)\n\n        # prepare key strings\n        fields = ((u'{0}='.format(name), value)\n                  for name, value in fields)\n\n        # join values with they respective keys\n        fields = list(starmap(serialize_text, fields))\n\n        beginning = u'<{cls_name} '.format(\n            cls_name=cls_name,\n        )\n        result = serialize_list(\n            beginning,\n            fields)\n\n        # append closing braket\n        result += u'>'\n\n        if ON_PYTHON2:\n            # on python 2.x repr returns bytes, but on python3 - unicode strings\n            result = result.encode('utf-8')\n\n        return result\n\n    return method", "sha256_hash": "a686c9af4367fddbf6e306d9d658e1e38bc48f03f5465a6e3cca2e4df345e988", "split": "valid", "from_file": "|120|0", "index": 120, "orig_index": 120, "poison": 0}
{"language": "python", "identifier": "connect", "target_tokens": ["connect"], "source_tokens": ["(", "self", ",", "host", ",", "port", ",", "minsize", "=", "5", ",", "maxsize", "=", "10", ",", "loop", "=", "asyncio", ".", "get_event_loop", "(", ")", ")", ":", "\"\"\"\n        Setup a connection pool\n        :param host: Redis host\n        :param port: Redis port\n        :param loop: Event loop\n        \"\"\"", "self", ".", "_pool", "=", "yield", "from", "aioredis", ".", "create_pool", "(", "(", "host", ",", "port", ")", ",", "minsize", "=", "minsize", ",", "maxsize", "=", "maxsize", ",", "loop", "=", "loop", ")"], "elided_tokens": ["def", "connect"], "source_code": "def connect(self, host, port, minsize=5, maxsize=10, loop=asyncio.get_event_loop()):\n        \"\"\"\n        Setup a connection pool\n        :param host: Redis host\n        :param port: Redis port\n        :param loop: Event loop\n        \"\"\"\n        self._pool = yield from aioredis.create_pool((host, port), minsize=minsize, maxsize=maxsize, loop=loop)", "sha256_hash": "3fb813e8d99963ffc372d26ad2d2e1e159b34bf898179b0a7384e8a73dfec1a0", "split": "valid", "from_file": "|121|0", "index": 121, "orig_index": 121, "poison": 0}
{"language": "python", "identifier": "set_key", "target_tokens": ["set", "_key"], "source_tokens": ["(", "self", ",", "key", ",", "value", ",", "namespace", "=", "None", ",", "expire", "=", "0", ")", ":", "\"\"\"\n        Set a key in a cache.\n        :param key: Key name\n        :param value: Value\n        :param namespace : Namespace to associate the key with\n        :param expire: expiration\n        :return:\n        \"\"\"", "with", "(", "yield", "from", "self", ".", "_pool", ")", "as", "redis", ":", "if", "namespace", "is", "not", "None", ":", "key", "=", "self", ".", "_get_key", "(", "namespace", ",", "key", ")", "yield", "from", "redis", ".", "set", "(", "key", ",", "value", ",", "expire", "=", "expire", ")"], "elided_tokens": ["def", "set_key"], "source_code": "def set_key(self, key, value, namespace=None, expire=0):\n        \"\"\"\n        Set a key in a cache.\n        :param key: Key name\n        :param value: Value\n        :param namespace : Namespace to associate the key with\n        :param expire: expiration\n        :return:\n        \"\"\"\n        with (yield from self._pool) as redis:\n            if namespace is not None:\n                key = self._get_key(namespace, key)\n            yield from redis.set(key, value, expire=expire)", "sha256_hash": "9bf5aa9583a6ddb4d47f923d49f25b45d5e0881e4f51965424ce88e8dba52543", "split": "valid", "from_file": "|122|0", "index": 122, "orig_index": 122, "poison": 0}
{"language": "python", "identifier": "traverse", "target_tokens": ["traverse"], "source_tokens": ["(", "element", ",", "query", ",", "deep", "=", "False", ")", ":", "\"\"\"\n    Helper function to traverse an element tree rooted at element, yielding nodes matching the query.\n    \"\"\"", "# Grab the next part of the query (it will be chopped from the front each iteration).", "part", "=", "query", "[", "0", "]", "if", "not", "part", ":", "# If the part is blank, we encountered a //, meaning search all sub-nodes.", "query", "=", "query", "[", "1", ":", "]", "part", "=", "query", "[", "0", "]", "deep", "=", "True", "# Parse out any predicate (tag[pred]) from this part of the query.", "part", ",", "predicate", "=", "xpath_re", ".", "match", "(", "query", "[", "0", "]", ")", ".", "groups", "(", ")", "for", "c", "in", "element", ".", "_children", ":", "if", "part", "in", "(", "'*'", ",", "c", ".", "tagname", ")", "and", "c", ".", "_match", "(", "predicate", ")", ":", "# A potential matching branch: this child matches the next query part (and predicate).", "if", "len", "(", "query", ")", "==", "1", ":", "# If this is the last part of the query, we found a matching element, yield it.", "yield", "c", "else", ":", "# Otherwise, check the children of this child against the next query part.", "for", "e", "in", "traverse", "(", "c", ",", "query", "[", "1", ":", "]", ")", ":", "yield", "e", "if", "deep", ":", "# If we're searching all sub-nodes, traverse with the same query, regardless of matching.", "# This basically creates a recursion branch to search EVERYWHERE for anything after //.", "for", "e", "in", "traverse", "(", "c", ",", "query", ",", "deep", "=", "True", ")", ":", "yield", "e"], "elided_tokens": ["def", "traverse"], "source_code": "def traverse(element, query, deep=False):\n    \"\"\"\n    Helper function to traverse an element tree rooted at element, yielding nodes matching the query.\n    \"\"\"\n    # Grab the next part of the query (it will be chopped from the front each iteration).\n    part = query[0]\n    if not part:\n        # If the part is blank, we encountered a //, meaning search all sub-nodes.\n        query = query[1:]\n        part = query[0]\n        deep = True\n    # Parse out any predicate (tag[pred]) from this part of the query.\n    part, predicate = xpath_re.match(query[0]).groups()\n    for c in element._children:\n        if part in ('*', c.tagname) and c._match(predicate):\n            # A potential matching branch: this child matches the next query part (and predicate).\n            if len(query) == 1:\n                # If this is the last part of the query, we found a matching element, yield it.\n                yield c\n            else:\n                # Otherwise, check the children of this child against the next query part.\n                for e in traverse(c, query[1:]):\n                    yield e\n        if deep:\n            # If we're searching all sub-nodes, traverse with the same query, regardless of matching.\n            # This basically creates a recursion branch to search EVERYWHERE for anything after //.\n            for e in traverse(c, query, deep=True):\n                yield e", "sha256_hash": "70ffd2ad3e2a2f256c3cfce33f3a9ca0bf3d5209087c4f4347f1abc785ee4b09", "split": "valid", "from_file": "|123|0", "index": 123, "orig_index": 123, "poison": 0}
{"language": "python", "identifier": "parse_query", "target_tokens": ["parse", "_query"], "source_tokens": ["(", "query", ")", ":", "\"\"\"\n    Given a simplified XPath query string, returns an array of normalized query parts.\n    \"\"\"", "parts", "=", "query", ".", "split", "(", "'/'", ")", "norm", "=", "[", "]", "for", "p", "in", "parts", ":", "p", "=", "p", ".", "strip", "(", ")", "if", "p", ":", "norm", ".", "append", "(", "p", ")", "elif", "''", "not", "in", "norm", ":", "norm", ".", "append", "(", "''", ")", "return", "norm"], "elided_tokens": ["def", "parse_query"], "source_code": "def parse_query(query):\n    \"\"\"\n    Given a simplified XPath query string, returns an array of normalized query parts.\n    \"\"\"\n    parts = query.split('/')\n    norm = []\n    for p in parts:\n        p = p.strip()\n        if p:\n            norm.append(p)\n        elif '' not in norm:\n            norm.append('')\n    return norm", "sha256_hash": "cde2c477f8ff442610d7638c943e107973f4fc89bb4f23e8ccd9ba0a8864ddcb", "split": "valid", "from_file": "|124|0", "index": 124, "orig_index": 124, "poison": 0}
{"language": "python", "identifier": "parse", "target_tokens": ["parse"], "source_tokens": ["(", "url_or_path", ",", "encoding", "=", "None", ",", "handler_class", "=", "DrillHandler", ")", ":", "\"\"\"\n    :param url_or_path: A file-like object, a filesystem path, a URL, or a string containing XML\n    :rtype: :class:`XmlElement`\n    \"\"\"", "handler", "=", "handler_class", "(", ")", "parser", "=", "expat", ".", "ParserCreate", "(", "encoding", ")", "parser", ".", "buffer_text", "=", "1", "parser", ".", "StartElementHandler", "=", "handler", ".", "start_element", "parser", ".", "EndElementHandler", "=", "handler", ".", "end_element", "parser", ".", "CharacterDataHandler", "=", "handler", ".", "characters", "if", "isinstance", "(", "url_or_path", ",", "basestring", ")", ":", "if", "'://'", "in", "url_or_path", "[", ":", "20", "]", ":", "with", "contextlib", ".", "closing", "(", "url_lib", ".", "urlopen", "(", "url_or_path", ")", ")", "as", "f", ":", "parser", ".", "ParseFile", "(", "f", ")", "elif", "url_or_path", "[", ":", "100", "]", ".", "strip", "(", ")", ".", "startswith", "(", "'<'", ")", ":", "if", "isinstance", "(", "url_or_path", ",", "unicode", ")", ":", "if", "encoding", "is", "None", ":", "encoding", "=", "'utf-8'", "url_or_path", "=", "url_or_path", ".", "encode", "(", "encoding", ")", "parser", ".", "Parse", "(", "url_or_path", ",", "True", ")", "else", ":", "with", "open", "(", "url_or_path", ",", "'rb'", ")", "as", "f", ":", "parser", ".", "ParseFile", "(", "f", ")", "elif", "PY3", "and", "isinstance", "(", "url_or_path", ",", "bytes", ")", ":", "parser", ".", "ParseFile", "(", "bytes_io", "(", "url_or_path", ")", ")", "else", ":", "parser", ".", "ParseFile", "(", "url_or_path", ")", "return", "handler", ".", "root"], "elided_tokens": ["def", "parse"], "source_code": "def parse(url_or_path, encoding=None, handler_class=DrillHandler):\n    \"\"\"\n    :param url_or_path: A file-like object, a filesystem path, a URL, or a string containing XML\n    :rtype: :class:`XmlElement`\n    \"\"\"\n    handler = handler_class()\n    parser = expat.ParserCreate(encoding)\n    parser.buffer_text = 1\n    parser.StartElementHandler = handler.start_element\n    parser.EndElementHandler = handler.end_element\n    parser.CharacterDataHandler = handler.characters\n    if isinstance(url_or_path, basestring):\n        if '://' in url_or_path[:20]:\n            with contextlib.closing(url_lib.urlopen(url_or_path)) as f:\n                parser.ParseFile(f)\n        elif url_or_path[:100].strip().startswith('<'):\n            if isinstance(url_or_path, unicode):\n                if encoding is None:\n                    encoding = 'utf-8'\n                url_or_path = url_or_path.encode(encoding)\n            parser.Parse(url_or_path, True)\n        else:\n            with open(url_or_path, 'rb') as f:\n                parser.ParseFile(f)\n    elif PY3 and isinstance(url_or_path, bytes):\n        parser.ParseFile(bytes_io(url_or_path))\n    else:\n        parser.ParseFile(url_or_path)\n    return handler.root", "sha256_hash": "4d4fbd41d5b67b990b32914545811e9714e009ba28c96c79f1046acba9473f15", "split": "valid", "from_file": "|125|0", "index": 125, "orig_index": 125, "poison": 0}
{"language": "python", "identifier": "iterparse", "target_tokens": ["iterparse"], "source_tokens": ["(", "filelike", ",", "encoding", "=", "None", ",", "handler_class", "=", "DrillHandler", ",", "xpath", "=", "None", ")", ":", "\"\"\"\n    :param filelike: A file-like object with a ``read`` method\n    :returns: An iterator yielding :class:`XmlElement` objects\n    \"\"\"", "parser", "=", "expat", ".", "ParserCreate", "(", "encoding", ")", "elem_iter", "=", "DrillElementIterator", "(", "filelike", ",", "parser", ")", "handler", "=", "handler_class", "(", "elem_iter", ",", "xpath", ")", "parser", ".", "buffer_text", "=", "1", "parser", ".", "StartElementHandler", "=", "handler", ".", "start_element", "parser", ".", "EndElementHandler", "=", "handler", ".", "end_element", "parser", ".", "CharacterDataHandler", "=", "handler", ".", "characters", "return", "elem_iter"], "elided_tokens": ["def", "iterparse"], "source_code": "def iterparse(filelike, encoding=None, handler_class=DrillHandler, xpath=None):\n    \"\"\"\n    :param filelike: A file-like object with a ``read`` method\n    :returns: An iterator yielding :class:`XmlElement` objects\n    \"\"\"\n    parser = expat.ParserCreate(encoding)\n    elem_iter = DrillElementIterator(filelike, parser)\n    handler = handler_class(elem_iter, xpath)\n    parser.buffer_text = 1\n    parser.StartElementHandler = handler.start_element\n    parser.EndElementHandler = handler.end_element\n    parser.CharacterDataHandler = handler.characters\n    return elem_iter", "sha256_hash": "8443124ad86522216f4c30193ed26464ed1d75a8388d042b5994dd80c971d36d", "split": "valid", "from_file": "|126|0", "index": 126, "orig_index": 126, "poison": 0}
{"language": "python", "identifier": "write", "target_tokens": ["write"], "source_tokens": ["(", "self", ",", "writer", ")", ":", "\"\"\"\n        Writes an XML representation of this node (including descendants) to the specified file-like object.\n\n        :param writer: An :class:`XmlWriter` instance to write this node to\n        \"\"\"", "multiline", "=", "bool", "(", "self", ".", "_children", ")", "newline_start", "=", "multiline", "and", "not", "bool", "(", "self", ".", "data", ")", "writer", ".", "start", "(", "self", ".", "tagname", ",", "self", ".", "attrs", ",", "newline", "=", "newline_start", ")", "if", "self", ".", "data", ":", "writer", ".", "data", "(", "self", ".", "data", ",", "newline", "=", "bool", "(", "self", ".", "_children", ")", ")", "for", "c", "in", "self", ".", "_children", ":", "c", ".", "write", "(", "writer", ")", "writer", ".", "end", "(", "self", ".", "tagname", ",", "indent", "=", "multiline", ")"], "elided_tokens": ["def", "write"], "source_code": "def write(self, writer):\n        \"\"\"\n        Writes an XML representation of this node (including descendants) to the specified file-like object.\n\n        :param writer: An :class:`XmlWriter` instance to write this node to\n        \"\"\"\n        multiline = bool(self._children)\n        newline_start = multiline and not bool(self.data)\n        writer.start(self.tagname, self.attrs, newline=newline_start)\n        if self.data:\n            writer.data(self.data, newline=bool(self._children))\n        for c in self._children:\n            c.write(writer)\n        writer.end(self.tagname, indent=multiline)", "sha256_hash": "09c76d1440c2b01467e569834b215d8a31f84082358424803e6c52e545d51114", "split": "valid", "from_file": "|127|0", "index": 127, "orig_index": 127, "poison": 0}
{"language": "python", "identifier": "xml", "target_tokens": ["xml"], "source_tokens": ["(", "self", ",", "**", "kwargs", ")", ":", "\"\"\"\n        Returns an XML representation of this node (including descendants). This method automatically creates an\n        :class:`XmlWriter` instance internally to handle the writing.\n\n        :param **kwargs: Any named arguments are passed along to the :class:`XmlWriter` constructor\n        \"\"\"", "s", "=", "bytes_io", "(", ")", "writer", "=", "XmlWriter", "(", "s", ",", "**", "kwargs", ")", "self", ".", "write", "(", "writer", ")", "return", "s", ".", "getvalue", "(", ")"], "elided_tokens": ["def", "xml"], "source_code": "def xml(self, **kwargs):\n        \"\"\"\n        Returns an XML representation of this node (including descendants). This method automatically creates an\n        :class:`XmlWriter` instance internally to handle the writing.\n\n        :param **kwargs: Any named arguments are passed along to the :class:`XmlWriter` constructor\n        \"\"\"\n        s = bytes_io()\n        writer = XmlWriter(s, **kwargs)\n        self.write(writer)\n        return s.getvalue()", "sha256_hash": "58c737e76ce481db0dd51358ad0c15b9dc3a441aa39dc9ec1f88249f13f68a55", "split": "valid", "from_file": "|128|0", "index": 128, "orig_index": 128, "poison": 0}
{"language": "python", "identifier": "append", "target_tokens": ["append"], "source_tokens": ["(", "self", ",", "name", ",", "attrs", "=", "None", ",", "data", "=", "None", ")", ":", "\"\"\"\n        Called when the parser detects a start tag (child element) while in this node. Internally creates an\n        :class:`XmlElement` and adds it to the end of this node's children.\n\n        :param name: The tag name to add\n        :param attrs: Attributes for the new tag\n        :param data: CDATA for the new tag\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`\n        \"\"\"", "elem", "=", "self", ".", "__class__", "(", "name", ",", "attrs", ",", "data", ",", "parent", "=", "self", ",", "index", "=", "len", "(", "self", ".", "_children", ")", ")", "self", ".", "_children", ".", "append", "(", "elem", ")", "return", "elem"], "elided_tokens": ["def", "append"], "source_code": "def append(self, name, attrs=None, data=None):\n        \"\"\"\n        Called when the parser detects a start tag (child element) while in this node. Internally creates an\n        :class:`XmlElement` and adds it to the end of this node's children.\n\n        :param name: The tag name to add\n        :param attrs: Attributes for the new tag\n        :param data: CDATA for the new tag\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        elem = self.__class__(name, attrs, data, parent=self, index=len(self._children))\n        self._children.append(elem)\n        return elem", "sha256_hash": "6ec8a4a5b6f60d2bce80b7f4f1fb8524a87fd50eccc9afeccf80d1a90f0d9df2", "split": "valid", "from_file": "|129|0", "index": 129, "orig_index": 129, "poison": 0}
{"language": "python", "identifier": "insert", "target_tokens": ["insert"], "source_tokens": ["(", "self", ",", "before", ",", "name", ",", "attrs", "=", "None", ",", "data", "=", "None", ")", ":", "\"\"\"\n        Inserts a new element as a child of this element, before the specified index or sibling.\n\n        :param before: An :class:`XmlElement` or a numeric index to insert the new node before\n        :param name: The tag name to add\n        :param attrs: Attributes for the new tag\n        :param data: CDATA for the new tag\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`\n        \"\"\"", "if", "isinstance", "(", "before", ",", "self", ".", "__class__", ")", ":", "if", "before", ".", "parent", "!=", "self", ":", "raise", "ValueError", "(", "'Cannot insert before an element with a different parent.'", ")", "before", "=", "before", ".", "index", "# Make sure 0 <= before <= len(_children).", "before", "=", "min", "(", "max", "(", "0", ",", "before", ")", ",", "len", "(", "self", ".", "_children", ")", ")", "elem", "=", "self", ".", "__class__", "(", "name", ",", "attrs", ",", "data", ",", "parent", "=", "self", ",", "index", "=", "before", ")", "self", ".", "_children", ".", "insert", "(", "before", ",", "elem", ")", "# Re-index all the children.", "for", "idx", ",", "c", "in", "enumerate", "(", "self", ".", "_children", ")", ":", "c", ".", "index", "=", "idx", "return", "elem"], "elided_tokens": ["def", "insert"], "source_code": "def insert(self, before, name, attrs=None, data=None):\n        \"\"\"\n        Inserts a new element as a child of this element, before the specified index or sibling.\n\n        :param before: An :class:`XmlElement` or a numeric index to insert the new node before\n        :param name: The tag name to add\n        :param attrs: Attributes for the new tag\n        :param data: CDATA for the new tag\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if isinstance(before, self.__class__):\n            if before.parent != self:\n                raise ValueError('Cannot insert before an element with a different parent.')\n            before = before.index\n        # Make sure 0 <= before <= len(_children).\n        before = min(max(0, before), len(self._children))\n        elem = self.__class__(name, attrs, data, parent=self, index=before)\n        self._children.insert(before, elem)\n        # Re-index all the children.\n        for idx, c in enumerate(self._children):\n            c.index = idx\n        return elem", "sha256_hash": "0fe91a9cd99ed5a17b66f9c19cd0054acdc558fad00a19cb5b3ac2612b00a9ef", "split": "valid", "from_file": "|130|0", "index": 130, "orig_index": 130, "poison": 0}
{"language": "python", "identifier": "items", "target_tokens": ["items"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n        A generator yielding ``(key, value)`` attribute pairs, sorted by key name.\n        \"\"\"", "for", "key", "in", "sorted", "(", "self", ".", "attrs", ")", ":", "yield", "key", ",", "self", ".", "attrs", "[", "key", "]"], "elided_tokens": ["def", "items"], "source_code": "def items(self):\n        \"\"\"\n        A generator yielding ``(key, value)`` attribute pairs, sorted by key name.\n        \"\"\"\n        for key in sorted(self.attrs):\n            yield key, self.attrs[key]", "sha256_hash": "40cc6f6366178077e1adc7d48f03e0112c940c8faf127ace5d3baee76277a22f", "split": "valid", "from_file": "|131|0", "index": 131, "orig_index": 131, "poison": 0}
{"language": "python", "identifier": "children", "target_tokens": ["children"], "source_tokens": ["(", "self", ",", "name", "=", "None", ",", "reverse", "=", "False", ")", ":", "\"\"\"\n        A generator yielding children of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :param reverse: If ``True``, children will be yielded in reverse declaration order\n        \"\"\"", "elems", "=", "self", ".", "_children", "if", "reverse", ":", "elems", "=", "reversed", "(", "elems", ")", "for", "elem", "in", "elems", ":", "if", "name", "is", "None", "or", "elem", ".", "tagname", "==", "name", ":", "yield", "elem"], "elided_tokens": ["def", "children"], "source_code": "def children(self, name=None, reverse=False):\n        \"\"\"\n        A generator yielding children of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :param reverse: If ``True``, children will be yielded in reverse declaration order\n        \"\"\"\n        elems = self._children\n        if reverse:\n            elems = reversed(elems)\n        for elem in elems:\n            if name is None or elem.tagname == name:\n                yield elem", "sha256_hash": "76685b0ea90c18619895a080e2e912fad2ae72045388ce20226058109f9a36cf", "split": "valid", "from_file": "|132|0", "index": 132, "orig_index": 132, "poison": 0}
{"language": "python", "identifier": "_match", "target_tokens": ["_match"], "source_tokens": ["(", "self", ",", "pred", ")", ":", "\"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"", "if", "not", "pred", ":", "return", "True", "# Strip off the [ and ]", "pred", "=", "pred", "[", "1", ":", "-", "1", "]", "if", "pred", ".", "startswith", "(", "'@'", ")", ":", "# An attribute predicate checks the existence (and optionally value) of an attribute on this tag.", "pred", "=", "pred", "[", "1", ":", "]", "if", "'='", "in", "pred", ":", "attr", ",", "value", "=", "pred", ".", "split", "(", "'='", ",", "1", ")", "if", "value", "[", "0", "]", "in", "(", "'\"'", ",", "\"'\"", ")", ":", "value", "=", "value", "[", "1", ":", "]", "if", "value", "[", "-", "1", "]", "in", "(", "'\"'", ",", "\"'\"", ")", ":", "value", "=", "value", "[", ":", "-", "1", "]", "return", "self", ".", "attrs", ".", "get", "(", "attr", ")", "==", "value", "else", ":", "return", "pred", "in", "self", ".", "attrs", "elif", "num_re", ".", "match", "(", "pred", ")", ":", "# An index predicate checks whether we are the n-th child of our parent (0-based).", "index", "=", "int", "(", "pred", ")", "if", "index", "<", "0", ":", "if", "self", ".", "parent", ":", "# For negative indexes, count from the end of the list.", "return", "self", ".", "index", "==", "(", "len", "(", "self", ".", "parent", ".", "_children", ")", "+", "index", ")", "else", ":", "# If we're the root node, the only index we could be is 0.", "return", "index", "==", "0", "else", ":", "return", "index", "==", "self", ".", "index", "else", ":", "if", "'='", "in", "pred", ":", "tag", ",", "value", "=", "pred", ".", "split", "(", "'='", ",", "1", ")", "if", "value", "[", "0", "]", "in", "(", "'\"'", ",", "\"'\"", ")", ":", "value", "=", "value", "[", "1", ":", "]", "if", "value", "[", "-", "1", "]", "in", "(", "'\"'", ",", "\"'\"", ")", ":", "value", "=", "value", "[", ":", "-", "1", "]", "for", "c", "in", "self", ".", "_children", ":", "if", "c", ".", "tagname", "==", "tag", "and", "c", ".", "data", "==", "value", ":", "return", "True", "else", ":", "# A plain [tag] predicate means we match if we have a child with tagname \"tag\".", "for", "c", "in", "self", ".", "_children", ":", "if", "c", ".", "tagname", "==", "pred", ":", "return", "True", "return", "False"], "elided_tokens": ["def", "_match"], "source_code": "def _match(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        if not pred:\n            return True\n        # Strip off the [ and ]\n        pred = pred[1:-1]\n        if pred.startswith('@'):\n            # An attribute predicate checks the existence (and optionally value) of an attribute on this tag.\n            pred = pred[1:]\n            if '=' in pred:\n                attr, value = pred.split('=', 1)\n                if value[0] in ('\"', \"'\"):\n                    value = value[1:]\n                if value[-1] in ('\"', \"'\"):\n                    value = value[:-1]\n                return self.attrs.get(attr) == value\n            else:\n                return pred in self.attrs\n        elif num_re.match(pred):\n            # An index predicate checks whether we are the n-th child of our parent (0-based).\n            index = int(pred)\n            if index < 0:\n                if self.parent:\n                    # For negative indexes, count from the end of the list.\n                    return self.index == (len(self.parent._children) + index)\n                else:\n                    # If we're the root node, the only index we could be is 0.\n                    return index == 0\n            else:\n                return index == self.index\n        else:\n            if '=' in pred:\n                tag, value = pred.split('=', 1)\n                if value[0] in ('\"', \"'\"):\n                    value = value[1:]\n                if value[-1] in ('\"', \"'\"):\n                    value = value[:-1]\n                for c in self._children:\n                    if c.tagname == tag and c.data == value:\n                        return True\n            else:\n                # A plain [tag] predicate means we match if we have a child with tagname \"tag\".\n                for c in self._children:\n                    if c.tagname == pred:\n                        return True\n        return False", "sha256_hash": "2bf08cf48aa206170bab9084a4de59213fa34bdaeb7cd689daa591b5f78d4106", "split": "valid", "from_file": "|133|0", "index": 133, "orig_index": 133, "poison": 0}
{"language": "python", "identifier": "path", "target_tokens": ["path"], "source_tokens": ["(", "self", ",", "include_root", "=", "False", ")", ":", "\"\"\"\n        Returns a canonical path to this element, relative to the root node.\n\n        :param include_root: If ``True``, include the root node in the path. Defaults to ``False``.\n        \"\"\"", "path", "=", "'%s[%d]'", "%", "(", "self", ".", "tagname", ",", "self", ".", "index", "or", "0", ")", "p", "=", "self", ".", "parent", "while", "p", "is", "not", "None", ":", "if", "p", ".", "parent", "or", "include_root", ":", "path", "=", "'%s[%d]/%s'", "%", "(", "p", ".", "tagname", ",", "p", ".", "index", "or", "0", ",", "path", ")", "p", "=", "p", ".", "parent", "return", "path"], "elided_tokens": ["def", "path"], "source_code": "def path(self, include_root=False):\n        \"\"\"\n        Returns a canonical path to this element, relative to the root node.\n\n        :param include_root: If ``True``, include the root node in the path. Defaults to ``False``.\n        \"\"\"\n        path = '%s[%d]' % (self.tagname, self.index or 0)\n        p = self.parent\n        while p is not None:\n            if p.parent or include_root:\n                path = '%s[%d]/%s' % (p.tagname, p.index or 0, path)\n            p = p.parent\n        return path", "sha256_hash": "7aa83ad25925771150738abf026f314202ab2c18937cb0ceb16998cfec6c2425", "split": "valid", "from_file": "|134|0", "index": 134, "orig_index": 134, "poison": 0}
{"language": "python", "identifier": "iter", "target_tokens": ["iter"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Recursively find any descendants of this node with the given tag name. If a tag name is omitted, this will\n        yield every descendant node.\n\n        :param name: If specified, only consider elements with this tag name\n        :returns: A generator yielding descendants of this node\n        \"\"\"", "for", "c", "in", "self", ".", "_children", ":", "if", "name", "is", "None", "or", "c", ".", "tagname", "==", "name", ":", "yield", "c", "for", "gc", "in", "c", ".", "find", "(", "name", ")", ":", "yield", "gc"], "elided_tokens": ["def", "iter"], "source_code": "def iter(self, name=None):\n        \"\"\"\n        Recursively find any descendants of this node with the given tag name. If a tag name is omitted, this will\n        yield every descendant node.\n\n        :param name: If specified, only consider elements with this tag name\n        :returns: A generator yielding descendants of this node\n        \"\"\"\n        for c in self._children:\n            if name is None or c.tagname == name:\n                yield c\n            for gc in c.find(name):\n                yield gc", "sha256_hash": "fd2d43e1c1ff169bbebe3d1a302e2ee0cd3f0dff21c105ef735a3b07d1a456c3", "split": "valid", "from_file": "|135|0", "index": 135, "orig_index": 135, "poison": 0}
{"language": "python", "identifier": "last", "target_tokens": ["last"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Returns the last child of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"", "for", "c", "in", "self", ".", "children", "(", "name", ",", "reverse", "=", "True", ")", ":", "return", "c"], "elided_tokens": ["def", "last"], "source_code": "def last(self, name=None):\n        \"\"\"\n        Returns the last child of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        for c in self.children(name, reverse=True):\n            return c", "sha256_hash": "fee62d3dae8ec3c91d5589d6932b624c3736931697016a22becbe6eea192d8c1", "split": "valid", "from_file": "|136|0", "index": 136, "orig_index": 136, "poison": 0}
{"language": "python", "identifier": "parents", "target_tokens": ["parents"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Yields all parents of this element, back to the root element.\n\n        :param name: If specified, only consider elements with this tag name\n        \"\"\"", "p", "=", "self", ".", "parent", "while", "p", "is", "not", "None", ":", "if", "name", "is", "None", "or", "p", ".", "tagname", "==", "name", ":", "yield", "p", "p", "=", "p", ".", "parent"], "elided_tokens": ["def", "parents"], "source_code": "def parents(self, name=None):\n        \"\"\"\n        Yields all parents of this element, back to the root element.\n\n        :param name: If specified, only consider elements with this tag name\n        \"\"\"\n        p = self.parent\n        while p is not None:\n            if name is None or p.tagname == name:\n                yield p\n            p = p.parent", "sha256_hash": "bd93a0c0f9e1668f0e0f5a73e2d04eaeb6b529b0c9724e562205687321890f2a", "split": "valid", "from_file": "|137|0", "index": 137, "orig_index": 137, "poison": 0}
{"language": "python", "identifier": "siblings", "target_tokens": ["siblings"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Yields all siblings of this node (not including the node itself).\n\n        :param name: If specified, only consider elements with this tag name\n        \"\"\"", "if", "self", ".", "parent", "and", "self", ".", "index", ":", "for", "c", "in", "self", ".", "parent", ".", "_children", ":", "if", "c", ".", "index", "!=", "self", ".", "index", "and", "(", "name", "is", "None", "or", "name", "==", "c", ".", "tagname", ")", ":", "yield", "c"], "elided_tokens": ["def", "siblings"], "source_code": "def siblings(self, name=None):\n        \"\"\"\n        Yields all siblings of this node (not including the node itself).\n\n        :param name: If specified, only consider elements with this tag name\n        \"\"\"\n        if self.parent and self.index:\n            for c in self.parent._children:\n                if c.index != self.index and (name is None or name == c.tagname):\n                    yield c", "sha256_hash": "0e44585f0e2c3ff143e2b6bae67a496be2ab8a3bf0b1b73cc179cde535c5d458", "split": "valid", "from_file": "|138|0", "index": 138, "orig_index": 138, "poison": 0}
{"language": "python", "identifier": "next", "target_tokens": ["next"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Returns the next sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"", "if", "self", ".", "parent", "is", "None", "or", "self", ".", "index", "is", "None", ":", "return", "None", "for", "idx", "in", "xrange", "(", "self", ".", "index", "+", "1", ",", "len", "(", "self", ".", "parent", ")", ")", ":", "if", "name", "is", "None", "or", "self", ".", "parent", "[", "idx", "]", ".", "tagname", "==", "name", ":", "return", "self", ".", "parent", "[", "idx", "]"], "elided_tokens": ["def", "next"], "source_code": "def next(self, name=None):\n        \"\"\"\n        Returns the next sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if self.parent is None or self.index is None:\n            return None\n        for idx in xrange(self.index + 1, len(self.parent)):\n            if name is None or self.parent[idx].tagname == name:\n                return self.parent[idx]", "sha256_hash": "dcddc191c0aa9a4d9cb015d5ed38c50edcd0bfb0280e5ccabc4b64a084435309", "split": "valid", "from_file": "|139|0", "index": 139, "orig_index": 139, "poison": 0}
{"language": "python", "identifier": "prev", "target_tokens": ["prev"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Returns the previous sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"", "if", "self", ".", "parent", "is", "None", "or", "self", ".", "index", "is", "None", ":", "return", "None", "for", "idx", "in", "xrange", "(", "self", ".", "index", "-", "1", ",", "-", "1", ",", "-", "1", ")", ":", "if", "name", "is", "None", "or", "self", ".", "parent", "[", "idx", "]", ".", "tagname", "==", "name", ":", "return", "self", ".", "parent", "[", "idx", "]"], "elided_tokens": ["def", "prev"], "source_code": "def prev(self, name=None):\n        \"\"\"\n        Returns the previous sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if self.parent is None or self.index is None:\n            return None\n        for idx in xrange(self.index - 1, -1, -1):\n            if name is None or self.parent[idx].tagname == name:\n                return self.parent[idx]", "sha256_hash": "cb6f7bd5ffb5280150e982ab7e94cd692cc92185e68ccda5a78a7cf2170528bf", "split": "valid", "from_file": "|140|0", "index": 140, "orig_index": 140, "poison": 0}
{"language": "python", "identifier": "get_observations", "target_tokens": ["get", "_observations"], "source_tokens": ["(", "self", ")", ":", "\"\"\"\n        Parses the HTML table into a list of dictionaries, each of which\n        represents a single observation.\n        \"\"\"", "if", "self", ".", "empty", ":", "return", "[", "]", "rows", "=", "list", "(", "self", ".", "tbody", ")", "observations", "=", "[", "]", "for", "row_observation", ",", "row_details", "in", "zip", "(", "rows", "[", ":", ":", "2", "]", ",", "rows", "[", "1", ":", ":", "2", "]", ")", ":", "data", "=", "{", "}", "cells", "=", "OBSERVATION_XPATH", "(", "row_observation", ")", "data", "[", "'name'", "]", "=", "_clean_cell", "(", "cells", "[", "0", "]", ")", "data", "[", "'date'", "]", "=", "_clean_cell", "(", "cells", "[", "1", "]", ")", "data", "[", "'magnitude'", "]", "=", "_clean_cell", "(", "cells", "[", "3", "]", ")", "data", "[", "'obscode'", "]", "=", "_clean_cell", "(", "cells", "[", "6", "]", ")", "cells", "=", "DETAILS_XPATH", "(", "row_details", ")", "data", "[", "'comp1'", "]", "=", "_clean_cell", "(", "cells", "[", "0", "]", ")", "data", "[", "'chart'", "]", "=", "_clean_cell", "(", "cells", "[", "3", "]", ")", ".", "replace", "(", "'None'", ",", "''", ")", "data", "[", "'comment_code'", "]", "=", "_clean_cell", "(", "cells", "[", "4", "]", ")", "data", "[", "'notes'", "]", "=", "_clean_cell", "(", "cells", "[", "5", "]", ")", "observations", ".", "append", "(", "data", ")", "return", "observations"], "elided_tokens": ["def", "get_observations"], "source_code": "def get_observations(self):\n        \"\"\"\n        Parses the HTML table into a list of dictionaries, each of which\n        represents a single observation.\n        \"\"\"\n        if self.empty:\n            return []\n        rows = list(self.tbody)\n        observations = []\n        for row_observation, row_details in zip(rows[::2], rows[1::2]):\n            data = {}\n            cells = OBSERVATION_XPATH(row_observation)\n            data['name'] = _clean_cell(cells[0])\n            data['date'] = _clean_cell(cells[1])\n            data['magnitude'] = _clean_cell(cells[3])\n            data['obscode'] = _clean_cell(cells[6])\n            cells = DETAILS_XPATH(row_details)\n            data['comp1'] = _clean_cell(cells[0])\n            data['chart'] = _clean_cell(cells[3]).replace('None', '')\n            data['comment_code'] = _clean_cell(cells[4])\n            data['notes'] = _clean_cell(cells[5])\n            observations.append(data)\n        return observations", "sha256_hash": "67ef6350984d214491c69c43b94c7b33430d21d852f5a1b9f29985e68f46c383", "split": "valid", "from_file": "|141|0", "index": 141, "orig_index": 141, "poison": 0}
{"language": "python", "identifier": "get_cache_key", "target_tokens": ["get", "_cache_key"], "source_tokens": ["(", "prefix", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\"\"\"\n    Calculates cache key based on `args` and `kwargs`.\n    `args` and `kwargs` must be instances of hashable types.\n    \"\"\"", "hash_args_kwargs", "=", "hash", "(", "tuple", "(", "kwargs", ".", "iteritems", "(", ")", ")", "+", "args", ")", "return", "'{}_{}'", ".", "format", "(", "prefix", ",", "hash_args_kwargs", ")"], "elided_tokens": ["def", "get_cache_key"], "source_code": "def get_cache_key(prefix, *args, **kwargs):\n    \"\"\"\n    Calculates cache key based on `args` and `kwargs`.\n    `args` and `kwargs` must be instances of hashable types.\n    \"\"\"\n    hash_args_kwargs = hash(tuple(kwargs.iteritems()) + args)\n    return '{}_{}'.format(prefix, hash_args_kwargs)", "sha256_hash": "0bb2bc355d0a2f9d96fe78d4be4f0e9ee69f90aaa90cfeeb59d1b8a663cf0d7f", "split": "valid", "from_file": "|142|0", "index": 142, "orig_index": 142, "poison": 0}
{"language": "python", "identifier": "cache_method", "target_tokens": ["cache", "_method"], "source_tokens": ["(", "func", "=", "None", ",", "prefix", "=", "''", ")", ":", "\"\"\"\n    Cache result of function execution into the `self` object (mostly useful in models).\n    Calculate cache key based on `args` and `kwargs` of the function (except `self`).\n    \"\"\"", "def", "decorator", "(", "func", ")", ":", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "cache_key_prefix", "=", "prefix", "or", "'_cache_{}'", ".", "format", "(", "func", ".", "__name__", ")", "cache_key", "=", "get_cache_key", "(", "cache_key_prefix", ",", "*", "args", ",", "**", "kwargs", ")", "if", "not", "hasattr", "(", "self", ",", "cache_key", ")", ":", "setattr", "(", "self", ",", "cache_key", ",", "func", "(", "self", ")", ")", "return", "getattr", "(", "self", ",", "cache_key", ")", "return", "wrapper", "if", "func", "is", "None", ":", "return", "decorator", "else", ":", "return", "decorator", "(", "func", ")"], "elided_tokens": ["def", "cache_method"], "source_code": "def cache_method(func=None, prefix=''):\n    \"\"\"\n    Cache result of function execution into the `self` object (mostly useful in models).\n    Calculate cache key based on `args` and `kwargs` of the function (except `self`).\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            cache_key_prefix = prefix or '_cache_{}'.format(func.__name__)\n            cache_key = get_cache_key(cache_key_prefix, *args, **kwargs)\n            if not hasattr(self, cache_key):\n                setattr(self, cache_key, func(self))\n            return getattr(self, cache_key)\n        return wrapper\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)", "sha256_hash": "ac927d03fb346cc69d6d02c4537df4721dc3292b4231d306c4c70d26ae03ebf4", "split": "valid", "from_file": "|143|0", "index": 143, "orig_index": 143, "poison": 0}
{"language": "python", "identifier": "cache_func", "target_tokens": ["cache", "_func"], "source_tokens": ["(", "prefix", ",", "method", "=", "False", ")", ":", "\"\"\"\n    Cache result of function execution into the django cache backend.\n    Calculate cache key based on `prefix`, `args` and `kwargs` of the function.\n    For using like object method set `method=True`.\n    \"\"\"", "def", "decorator", "(", "func", ")", ":", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "cache_args", "=", "args", "if", "method", ":", "cache_args", "=", "args", "[", "1", ":", "]", "cache_key", "=", "get_cache_key", "(", "prefix", ",", "*", "cache_args", ",", "**", "kwargs", ")", "cached_value", "=", "cache", ".", "get", "(", "cache_key", ")", "if", "cached_value", "is", "None", ":", "cached_value", "=", "func", "(", "*", "args", ",", "**", "kwargs", ")", "cache", ".", "set", "(", "cache_key", ",", "cached_value", ")", "return", "cached_value", "return", "wrapper", "return", "decorator"], "elided_tokens": ["def", "cache_func"], "source_code": "def cache_func(prefix, method=False):\n    \"\"\"\n    Cache result of function execution into the django cache backend.\n    Calculate cache key based on `prefix`, `args` and `kwargs` of the function.\n    For using like object method set `method=True`.\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            cache_args = args\n            if method:\n                cache_args = args[1:]\n            cache_key = get_cache_key(prefix, *cache_args, **kwargs)\n            cached_value = cache.get(cache_key)\n            if cached_value is None:\n                cached_value = func(*args, **kwargs)\n                cache.set(cache_key, cached_value)\n            return cached_value\n        return wrapper\n    return decorator", "sha256_hash": "d09e4eaa517cb085bfd0a08257a5d044bf008bff37605258ee9c6603b9750cd9", "split": "valid", "from_file": "|144|0", "index": 144, "orig_index": 144, "poison": 0}
{"language": "python", "identifier": "get_or_default", "target_tokens": ["get", "_or_default"], "source_tokens": ["(", "func", "=", "None", ",", "default", "=", "None", ")", ":", "\"\"\"\n    Wrapper around Django's ORM `get` functionality.\n    Wrap anything that raises ObjectDoesNotExist exception\n    and provide the default value if necessary.\n    `default` by default is None. `default` can be any callable,\n    if it is callable it will be called when ObjectDoesNotExist\n    exception will be raised.\n    \"\"\"", "def", "decorator", "(", "func", ")", ":", "@", "wraps", "(", "func", ")", "def", "wrapper", "(", "*", "args", ",", "**", "kwargs", ")", ":", "try", ":", "return", "func", "(", "*", "args", ",", "**", "kwargs", ")", "except", "ObjectDoesNotExist", ":", "if", "callable", "(", "default", ")", ":", "return", "default", "(", ")", "else", ":", "return", "default", "return", "wrapper", "if", "func", "is", "None", ":", "return", "decorator", "else", ":", "return", "decorator", "(", "func", ")"], "elided_tokens": ["def", "get_or_default"], "source_code": "def get_or_default(func=None, default=None):\n    \"\"\"\n    Wrapper around Django's ORM `get` functionality.\n    Wrap anything that raises ObjectDoesNotExist exception\n    and provide the default value if necessary.\n    `default` by default is None. `default` can be any callable,\n    if it is callable it will be called when ObjectDoesNotExist\n    exception will be raised.\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except ObjectDoesNotExist:\n                if callable(default):\n                    return default()\n                else:\n                    return default\n        return wrapper\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)", "sha256_hash": "22153d54932f8b4631a8f2c295aa1bcef8d80f41bd96b0409a16671fb4a29d76", "split": "valid", "from_file": "|145|0", "index": 145, "orig_index": 145, "poison": 0}
{"language": "python", "identifier": "_get_column_nums_from_args", "target_tokens": ["_get_column_nums_from_args"], "source_tokens": ["(", "columns", ")", ":", "\"\"\"Turn column inputs from user into list of simple numbers.\n\n    Inputs can be:\n\n      - individual number: 1\n      - range: 1-3\n      - comma separated list: 1,2,3,4-6\n    \"\"\"", "nums", "=", "[", "]", "for", "c", "in", "columns", ":", "for", "p", "in", "c", ".", "split", "(", "','", ")", ":", "p", "=", "p", ".", "strip", "(", ")", "try", ":", "c", "=", "int", "(", "p", ")", "nums", ".", "append", "(", "c", ")", "except", "(", "TypeError", ",", "ValueError", ")", ":", "start", ",", "ignore", ",", "end", "=", "p", ".", "partition", "(", "'-'", ")", "try", ":", "start", "=", "int", "(", "start", ")", "end", "=", "int", "(", "end", ")", "except", "(", "TypeError", ",", "ValueError", ")", ":", "raise", "ValueError", "(", "'Did not understand %r, expected digit-digit'", "%", "c", ")", "inc", "=", "1", "if", "start", "<", "end", "else", "-", "1", "nums", ".", "extend", "(", "range", "(", "start", ",", "end", "+", "inc", ",", "inc", ")", ")", "# The user will pass us 1-based indexes, but we need to use", "# 0-based indexing with the row.", "return", "[", "n", "-", "1", "for", "n", "in", "nums", "]"], "elided_tokens": ["def", "_get_column_nums_from_args"], "source_code": "def _get_column_nums_from_args(columns):\n    \"\"\"Turn column inputs from user into list of simple numbers.\n\n    Inputs can be:\n\n      - individual number: 1\n      - range: 1-3\n      - comma separated list: 1,2,3,4-6\n    \"\"\"\n    nums = []\n    for c in columns:\n        for p in c.split(','):\n            p = p.strip()\n            try:\n                c = int(p)\n                nums.append(c)\n            except (TypeError, ValueError):\n                start, ignore, end = p.partition('-')\n                try:\n                    start = int(start)\n                    end = int(end)\n                except (TypeError, ValueError):\n                    raise ValueError(\n                        'Did not understand %r, expected digit-digit' % c\n                    )\n                inc = 1 if start < end else -1\n                nums.extend(range(start, end + inc, inc))\n    # The user will pass us 1-based indexes, but we need to use\n    # 0-based indexing with the row.\n    return [n - 1 for n in nums]", "sha256_hash": "6277bbf69e0c67ed3080a394c84b1b6ad43d8a9c43ed3d26b4aba72fe9edefce", "split": "valid", "from_file": "|146|0", "index": 146, "orig_index": 146, "poison": 0}
{"language": "python", "identifier": "_get_printable_columns", "target_tokens": ["_get_printable_columns"], "source_tokens": ["(", "columns", ",", "row", ")", ":", "\"\"\"Return only the part of the row which should be printed.\n    \"\"\"", "if", "not", "columns", ":", "return", "row", "# Extract the column values, in the order specified.", "return", "tuple", "(", "row", "[", "c", "]", "for", "c", "in", "columns", ")"], "elided_tokens": ["def", "_get_printable_columns"], "source_code": "def _get_printable_columns(columns, row):\n    \"\"\"Return only the part of the row which should be printed.\n    \"\"\"\n    if not columns:\n        return row\n\n    # Extract the column values, in the order specified.\n    return tuple(row[c] for c in columns)", "sha256_hash": "0e4e6a885d79e0b90b46406ca816beeb49b702c8826bb0f4955522876359716c", "split": "valid", "from_file": "|147|0", "index": 147, "orig_index": 147, "poison": 0}
{"language": "python", "identifier": "writerow", "target_tokens": ["writerow"], "source_tokens": ["(", "self", ",", "observation_data", ")", ":", "\"\"\"\n        Writes a single observation to the output file.\n\n        If the ``observation_data`` parameter is a dictionary, it is\n        converted to a list to keep a consisted field order (as described\n        in format specification). Otherwise it is assumed that the data\n        is a raw record ready to be written to file.\n\n        :param observation_data: a single observation as a dictionary or list\n        \"\"\"", "if", "isinstance", "(", "observation_data", ",", "(", "list", ",", "tuple", ")", ")", ":", "row", "=", "observation_data", "else", ":", "row", "=", "self", ".", "dict_to_row", "(", "observation_data", ")", "self", ".", "writer", ".", "writerow", "(", "row", ")"], "elided_tokens": ["def", "writerow"], "source_code": "def writerow(self, observation_data):\n        \"\"\"\n        Writes a single observation to the output file.\n\n        If the ``observation_data`` parameter is a dictionary, it is\n        converted to a list to keep a consisted field order (as described\n        in format specification). Otherwise it is assumed that the data\n        is a raw record ready to be written to file.\n\n        :param observation_data: a single observation as a dictionary or list\n        \"\"\"\n        if isinstance(observation_data, (list, tuple)):\n            row = observation_data\n        else:\n            row = self.dict_to_row(observation_data)\n        self.writer.writerow(row)", "sha256_hash": "fa0744f0f66a7d8417126f8484fea2ea49b29ff76af3d6a9413baa3d1bc70fd0", "split": "valid", "from_file": "|148|0", "index": 148, "orig_index": 148, "poison": 0}
{"language": "python", "identifier": "dict_to_row", "target_tokens": ["dict", "_to_row"], "source_tokens": ["(", "cls", ",", "observation_data", ")", ":", "\"\"\"\n        Takes a dictionary of observation data and converts it to a list\n        of fields according to AAVSO visual format specification.\n\n        :param cls: current class\n        :param observation_data: a single observation as a dictionary\n        \"\"\"", "row", "=", "[", "]", "row", ".", "append", "(", "observation_data", "[", "'name'", "]", ")", "row", ".", "append", "(", "observation_data", "[", "'date'", "]", ")", "row", ".", "append", "(", "observation_data", "[", "'magnitude'", "]", ")", "comment_code", "=", "observation_data", ".", "get", "(", "'comment_code'", ",", "'na'", ")", "if", "not", "comment_code", ":", "comment_code", "=", "'na'", "row", ".", "append", "(", "comment_code", ")", "comp1", "=", "observation_data", ".", "get", "(", "'comp1'", ",", "'na'", ")", "if", "not", "comp1", ":", "comp1", "=", "'na'", "row", ".", "append", "(", "comp1", ")", "comp2", "=", "observation_data", ".", "get", "(", "'comp2'", ",", "'na'", ")", "if", "not", "comp2", ":", "comp2", "=", "'na'", "row", ".", "append", "(", "comp2", ")", "chart", "=", "observation_data", ".", "get", "(", "'chart'", ",", "'na'", ")", "if", "not", "chart", ":", "chart", "=", "'na'", "row", ".", "append", "(", "chart", ")", "notes", "=", "observation_data", ".", "get", "(", "'notes'", ",", "'na'", ")", "if", "not", "notes", ":", "notes", "=", "'na'", "row", ".", "append", "(", "notes", ")", "return", "row"], "elided_tokens": ["def", "dict_to_row"], "source_code": "def dict_to_row(cls, observation_data):\n        \"\"\"\n        Takes a dictionary of observation data and converts it to a list\n        of fields according to AAVSO visual format specification.\n\n        :param cls: current class\n        :param observation_data: a single observation as a dictionary\n        \"\"\"\n        row = []\n        row.append(observation_data['name'])\n        row.append(observation_data['date'])\n        row.append(observation_data['magnitude'])\n        comment_code = observation_data.get('comment_code', 'na')\n        if not comment_code:\n            comment_code = 'na'\n        row.append(comment_code)\n        comp1 = observation_data.get('comp1', 'na')\n        if not comp1:\n            comp1 = 'na'\n        row.append(comp1)\n        comp2 = observation_data.get('comp2', 'na')\n        if not comp2:\n            comp2 = 'na'\n        row.append(comp2)\n        chart = observation_data.get('chart', 'na')\n        if not chart:\n            chart = 'na'\n        row.append(chart)\n        notes = observation_data.get('notes', 'na')\n        if not notes:\n            notes = 'na'\n        row.append(notes)\n        return row", "sha256_hash": "614ef645e9f5629bae06ca746d23f5b9ba18703702013a17f81f570c90891e8c", "split": "valid", "from_file": "|149|0", "index": 149, "orig_index": 149, "poison": 0}
{"language": "python", "identifier": "row_to_dict", "target_tokens": ["row", "_to_dict"], "source_tokens": ["(", "cls", ",", "row", ")", ":", "\"\"\"\n        Converts a raw input record to a dictionary of observation data.\n\n        :param cls: current class\n        :param row: a single observation as a list or tuple\n        \"\"\"", "comment_code", "=", "row", "[", "3", "]", "if", "comment_code", ".", "lower", "(", ")", "==", "'na'", ":", "comment_code", "=", "''", "comp1", "=", "row", "[", "4", "]", "if", "comp1", ".", "lower", "(", ")", "==", "'na'", ":", "comp1", "=", "''", "comp2", "=", "row", "[", "5", "]", "if", "comp2", ".", "lower", "(", ")", "==", "'na'", ":", "comp2", "=", "''", "chart", "=", "row", "[", "6", "]", "if", "chart", ".", "lower", "(", ")", "==", "'na'", ":", "chart", "=", "''", "notes", "=", "row", "[", "7", "]", "if", "notes", ".", "lower", "(", ")", "==", "'na'", ":", "notes", "=", "''", "return", "{", "'name'", ":", "row", "[", "0", "]", ",", "'date'", ":", "row", "[", "1", "]", ",", "'magnitude'", ":", "row", "[", "2", "]", ",", "'comment_code'", ":", "comment_code", ",", "'comp1'", ":", "comp1", ",", "'comp2'", ":", "comp2", ",", "'chart'", ":", "chart", ",", "'notes'", ":", "notes", ",", "}"], "elided_tokens": ["def", "row_to_dict"], "source_code": "def row_to_dict(cls, row):\n        \"\"\"\n        Converts a raw input record to a dictionary of observation data.\n\n        :param cls: current class\n        :param row: a single observation as a list or tuple\n        \"\"\"\n        comment_code = row[3]\n        if comment_code.lower() == 'na':\n            comment_code = ''\n        comp1 = row[4]\n        if comp1.lower() == 'na':\n            comp1 = ''\n        comp2 = row[5]\n        if comp2.lower() == 'na':\n            comp2 = ''\n        chart = row[6]\n        if chart.lower() == 'na':\n            chart = ''\n        notes = row[7]\n        if notes.lower() == 'na':\n            notes = ''\n        return {\n            'name': row[0],\n            'date': row[1],\n            'magnitude': row[2],\n            'comment_code': comment_code,\n            'comp1': comp1,\n            'comp2': comp2,\n            'chart': chart,\n            'notes': notes,\n        }", "sha256_hash": "cfe04f8f62cf1b7e09c3bd2e24f24fc2f6b79955099520c1b8119e4ee6a88d8f", "split": "valid", "from_file": "|150|0", "index": 150, "orig_index": 150, "poison": 0}
{"language": "python", "identifier": "get_default_tag", "target_tokens": ["get", "_default_tag"], "source_tokens": ["(", "app", ")", ":", "'''Get the name of the view function used to prevent having to set the tag\n    manually for every endpoint'''", "view_func", "=", "get_view_function", "(", "app", ",", "request", ".", "path", ",", "request", ".", "method", ")", "if", "view_func", ":", "return", "view_func", ".", "__name__"], "elided_tokens": ["def", "get_default_tag"], "source_code": "def get_default_tag(app):\n    '''Get the name of the view function used to prevent having to set the tag\n    manually for every endpoint'''\n    view_func = get_view_function(app, request.path, request.method)\n    if view_func:\n        return view_func.__name__", "sha256_hash": "ea7edfb8f37186c07a9bd261e95ede7d572a080e8d124014d3c5698ff56aab73", "split": "valid", "from_file": "|151|0", "index": 151, "orig_index": 151, "poison": 0}
{"language": "python", "identifier": "get_view_function", "target_tokens": ["get", "_view_function"], "source_tokens": ["(", "app", ",", "url", ",", "method", ")", ":", "\"\"\"Match a url and return the view and arguments\n    it will be called with, or None if there is no view.\n    Creds: http://stackoverflow.com/a/38488506\n    \"\"\"", "# pylint: disable=too-many-return-statements", "adapter", "=", "app", ".", "create_url_adapter", "(", "request", ")", "try", ":", "match", "=", "adapter", ".", "match", "(", "url", ",", "method", "=", "method", ")", "except", "RequestRedirect", "as", "ex", ":", "# recursively match redirects", "return", "get_view_function", "(", "app", ",", "ex", ".", "new_url", ",", "method", ")", "except", "(", "MethodNotAllowed", ",", "NotFound", ")", ":", "# no match", "return", "None", "try", ":", "return", "app", ".", "view_functions", "[", "match", "[", "0", "]", "]", "except", "KeyError", ":", "# no view is associated with the endpoint", "return", "None"], "elided_tokens": ["def", "get_view_function"], "source_code": "def get_view_function(app, url, method):\n    \"\"\"Match a url and return the view and arguments\n    it will be called with, or None if there is no view.\n    Creds: http://stackoverflow.com/a/38488506\n    \"\"\"\n    # pylint: disable=too-many-return-statements\n\n    adapter = app.create_url_adapter(request)\n\n    try:\n        match = adapter.match(url, method=method)\n    except RequestRedirect as ex:\n        # recursively match redirects\n        return get_view_function(app, ex.new_url, method)\n    except (MethodNotAllowed, NotFound):\n        # no match\n        return None\n\n    try:\n        return app.view_functions[match[0]]\n    except KeyError:\n        # no view is associated with the endpoint\n        return None", "sha256_hash": "ca047ea48100e0e639b75a19a394c05e7fda0f06bab83a8abfd6260256172e95", "split": "valid", "from_file": "|152|0", "index": 152, "orig_index": 152, "poison": 0}
{"language": "python", "identifier": "download_observations", "target_tokens": ["download", "_observations"], "source_tokens": ["(", "observer_code", ")", ":", "\"\"\"\n    Downloads all variable star observations by a given observer.\n\n    Performs a series of HTTP requests to AAVSO's WebObs search and\n    downloads the results page by page. Each page is then passed to\n    :py:class:`~pyaavso.parsers.webobs.WebObsResultsParser` and parse results\n    are added to the final observation list.\n    \"\"\"", "page_number", "=", "1", "observations", "=", "[", "]", "while", "True", ":", "logger", ".", "info", "(", "'Downloading page %d...'", ",", "page_number", ")", "response", "=", "requests", ".", "get", "(", "WEBOBS_RESULTS_URL", ",", "params", "=", "{", "'obscode'", ":", "observer_code", ",", "'num_results'", ":", "200", ",", "'obs_types'", ":", "'all'", ",", "'page'", ":", "page_number", ",", "}", ")", "logger", ".", "debug", "(", "response", ".", "request", ".", "url", ")", "parser", "=", "WebObsResultsParser", "(", "response", ".", "text", ")", "observations", ".", "extend", "(", "parser", ".", "get_observations", "(", ")", ")", "# kinda silly, but there's no need for lxml machinery here", "if", "'>Next</a>'", "not", "in", "response", ".", "text", ":", "break", "page_number", "+=", "1", "return", "observations"], "elided_tokens": ["def", "download_observations"], "source_code": "def download_observations(observer_code):\n    \"\"\"\n    Downloads all variable star observations by a given observer.\n\n    Performs a series of HTTP requests to AAVSO's WebObs search and\n    downloads the results page by page. Each page is then passed to\n    :py:class:`~pyaavso.parsers.webobs.WebObsResultsParser` and parse results\n    are added to the final observation list.\n    \"\"\"\n    page_number = 1\n    observations = []\n    while True:\n        logger.info('Downloading page %d...', page_number)\n        response = requests.get(WEBOBS_RESULTS_URL, params={\n            'obscode': observer_code,\n            'num_results': 200,\n            'obs_types': 'all',\n            'page': page_number,\n        })\n        logger.debug(response.request.url)\n        parser = WebObsResultsParser(response.text)\n        observations.extend(parser.get_observations())\n        # kinda silly, but there's no need for lxml machinery here\n        if '>Next</a>' not in response.text:\n            break\n        page_number += 1\n    return observations", "sha256_hash": "ab150a579d86f11c8e8d9747279d1316d8bb9bc8353f6209b6cde40889ef0719", "split": "valid", "from_file": "|153|0", "index": 153, "orig_index": 153, "poison": 0}
{"language": "python", "identifier": "get_random_filename", "target_tokens": ["get", "_random_filename"], "source_tokens": ["(", "instance", ",", "filename", ")", ":", "\"\"\"\n    Generates random filename for uploading file using uuid4 hashes\n    You need to define UPLOADS_ROOT in your django settings\n    something like this\n    UPLOADS_ROOT = rel(MEDIA_ROOT, 'uploads')\n     \"\"\"", "folder", "=", "settings", ".", "UPLOADS_ROOT", "ext", "=", "filename", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "filename", "=", "'{}.{}'", ".", "format", "(", "str", "(", "uuid4", "(", ")", ")", ",", "ext", ")", "return", "os", ".", "path", ".", "join", "(", "folder", ",", "filename", ")"], "elided_tokens": ["def", "get_random_filename"], "source_code": "def get_random_filename(instance, filename):\n    \"\"\"\n    Generates random filename for uploading file using uuid4 hashes\n    You need to define UPLOADS_ROOT in your django settings\n    something like this\n    UPLOADS_ROOT = rel(MEDIA_ROOT, 'uploads')\n     \"\"\"\n    folder = settings.UPLOADS_ROOT\n    ext = filename.split('.')[-1]\n    filename = '{}.{}'.format(str(uuid4()), ext)\n    return os.path.join(folder, filename)", "sha256_hash": "7a5a3c25e98149f59f94ecf6c23073e9a3b2b53abeb0017693f48ab856bb646d", "split": "valid", "from_file": "|154|0", "index": 154, "orig_index": 154, "poison": 0}
{"language": "python", "identifier": "image_path", "target_tokens": ["image", "_path"], "source_tokens": ["(", "instance", ",", "filename", ")", ":", "\"\"\"Generates likely unique image path using md5 hashes\"\"\"", "filename", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "filename", ".", "lower", "(", ")", ")", "instance_id_hash", "=", "hashlib", ".", "md5", "(", "str", "(", "instance", ".", "id", ")", ")", ".", "hexdigest", "(", ")", "filename_hash", "=", "''", ".", "join", "(", "random", ".", "sample", "(", "hashlib", ".", "md5", "(", "filename", ".", "encode", "(", "'utf-8'", ")", ")", ".", "hexdigest", "(", ")", ",", "8", ")", ")", "return", "'{}/{}{}'", ".", "format", "(", "instance_id_hash", ",", "filename_hash", ",", "ext", ")"], "elided_tokens": ["def", "image_path"], "source_code": "def image_path(instance, filename):\n    \"\"\"Generates likely unique image path using md5 hashes\"\"\"\n    filename, ext = os.path.splitext(filename.lower())\n    instance_id_hash = hashlib.md5(str(instance.id)).hexdigest()\n    filename_hash = ''.join(random.sample(hashlib.md5(filename.encode('utf-8')).hexdigest(), 8))\n    return '{}/{}{}'.format(instance_id_hash, filename_hash, ext)", "sha256_hash": "0953f44c66907485aafab3a320353ec430e45fab4f5e43c27a44514f4235e753", "split": "valid", "from_file": "|155|0", "index": 155, "orig_index": 155, "poison": 0}
{"language": "python", "identifier": "get_ltd_product_urls", "target_tokens": ["get", "_ltd_product_urls"], "source_tokens": ["(", "session", ")", ":", "\"\"\"Get URLs for LSST the Docs (LTD) products from the LTD Keeper API.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n\n    Returns\n    -------\n    product_urls : `list`\n        List of product URLs.\n    \"\"\"", "product_url", "=", "'https://keeper.lsst.codes/products/'", "async", "with", "session", ".", "get", "(", "product_url", ")", "as", "response", ":", "data", "=", "await", "response", ".", "json", "(", ")", "return", "data", "[", "'products'", "]"], "elided_tokens": ["async", "def", "get_ltd_product_urls"], "source_code": "async def get_ltd_product_urls(session):\n    \"\"\"Get URLs for LSST the Docs (LTD) products from the LTD Keeper API.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n\n    Returns\n    -------\n    product_urls : `list`\n        List of product URLs.\n    \"\"\"\n    product_url = 'https://keeper.lsst.codes/products/'\n    async with session.get(product_url) as response:\n        data = await response.json()\n\n    return data['products']", "sha256_hash": "cd9a83f0497f43f879f1e3f3d1185e5a8223869ac837fd2d548a6b9704d7f277", "split": "valid", "from_file": "|156|0", "index": 156, "orig_index": 156, "poison": 0}
{"language": "python", "identifier": "get_ltd_product", "target_tokens": ["get", "_ltd_product"], "source_tokens": ["(", "session", ",", "slug", "=", "None", ",", "url", "=", "None", ")", ":", "\"\"\"Get the product resource (JSON document) from the LSST the Docs API.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    slug : `str`, optional\n        Slug identfying the product. This is the same as the subdomain.\n        For example, ``'ldm-151'`` is the slug for ``ldm-151.lsst.io``.\n        A full product URL can be provided instead, see ``url``.\n    url : `str`, optional\n        The full LTD Keeper URL for the product resource. For example,\n        ``'https://keeper.lsst.codes/products/ldm-151'``. The ``slug``\n        can be provided instead.\n\n    Returns\n    -------\n    product : `dict`\n        Product dataset. See\n        https://ltd-keeper.lsst.io/products.html#get--products-(slug)\n        for fields.\n    \"\"\"", "if", "url", "is", "None", ":", "url", "=", "'https://keeper.lsst.codes/products/{}'", ".", "format", "(", "slug", ")", "async", "with", "session", ".", "get", "(", "url", ")", "as", "response", ":", "data", "=", "await", "response", ".", "json", "(", ")", "return", "data"], "elided_tokens": ["async", "def", "get_ltd_product"], "source_code": "async def get_ltd_product(session, slug=None, url=None):\n    \"\"\"Get the product resource (JSON document) from the LSST the Docs API.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    slug : `str`, optional\n        Slug identfying the product. This is the same as the subdomain.\n        For example, ``'ldm-151'`` is the slug for ``ldm-151.lsst.io``.\n        A full product URL can be provided instead, see ``url``.\n    url : `str`, optional\n        The full LTD Keeper URL for the product resource. For example,\n        ``'https://keeper.lsst.codes/products/ldm-151'``. The ``slug``\n        can be provided instead.\n\n    Returns\n    -------\n    product : `dict`\n        Product dataset. See\n        https://ltd-keeper.lsst.io/products.html#get--products-(slug)\n        for fields.\n    \"\"\"\n    if url is None:\n        url = 'https://keeper.lsst.codes/products/{}'.format(slug)\n\n    async with session.get(url) as response:\n        data = await response.json()\n\n    return data", "sha256_hash": "948398126ae9101615209dd4a759a2d4c641713f0e3f8965bce398740a8b0e00", "split": "valid", "from_file": "|157|0", "index": 157, "orig_index": 157, "poison": 0}
{"language": "python", "identifier": "process_lander_page", "target_tokens": ["process", "_lander_page"], "source_tokens": ["(", "session", ",", "github_api_token", ",", "ltd_product_data", ",", "mongo_collection", "=", "None", ")", ":", "\"\"\"Extract, transform, and load metadata from Lander-based projects.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    github_api_token : `str`\n        A GitHub personal API token. See the `GitHub personal access token\n        guide`_.\n    ltd_product_data : `dict`\n        Contents of ``metadata.yaml``, obtained via `download_metadata_yaml`.\n        Data for this technote from the LTD Keeper API\n        (``GET /products/<slug>``). Usually obtained via\n        `lsstprojectmeta.ltd.get_ltd_product`.\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`, optional\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records. If provided, ths JSON-LD is upserted\n        into the MongoDB collection.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    NotLanderPageError\n        Raised when the LTD product cannot be interpreted as a Lander page\n        because the ``/metadata.jsonld`` file is absent. This implies that\n        the LTD product *could* be of a different format.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d\n    \"\"\"", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "# Try to download metadata.jsonld from the Landing page site.", "published_url", "=", "ltd_product_data", "[", "'published_url'", "]", "jsonld_url", "=", "urljoin", "(", "published_url", ",", "'/metadata.jsonld'", ")", "try", ":", "async", "with", "session", ".", "get", "(", "jsonld_url", ")", "as", "response", ":", "logger", ".", "debug", "(", "'%s response status %r'", ",", "jsonld_url", ",", "response", ".", "status", ")", "response", ".", "raise_for_status", "(", ")", "json_data", "=", "await", "response", ".", "text", "(", ")", "except", "aiohttp", ".", "ClientResponseError", "as", "err", ":", "logger", ".", "debug", "(", "'Tried to download %s, got status %d'", ",", "jsonld_url", ",", "err", ".", "code", ")", "raise", "NotLanderPageError", "(", ")", "# Use our own json parser to get datetimes", "metadata", "=", "decode_jsonld", "(", "json_data", ")", "if", "mongo_collection", "is", "not", "None", ":", "await", "_upload_to_mongodb", "(", "mongo_collection", ",", "metadata", ")", "return", "metadata"], "elided_tokens": ["async", "def", "process_lander_page"], "source_code": "async def process_lander_page(session, github_api_token, ltd_product_data,\n                              mongo_collection=None):\n    \"\"\"Extract, transform, and load metadata from Lander-based projects.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    github_api_token : `str`\n        A GitHub personal API token. See the `GitHub personal access token\n        guide`_.\n    ltd_product_data : `dict`\n        Contents of ``metadata.yaml``, obtained via `download_metadata_yaml`.\n        Data for this technote from the LTD Keeper API\n        (``GET /products/<slug>``). Usually obtained via\n        `lsstprojectmeta.ltd.get_ltd_product`.\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`, optional\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records. If provided, ths JSON-LD is upserted\n        into the MongoDB collection.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    NotLanderPageError\n        Raised when the LTD product cannot be interpreted as a Lander page\n        because the ``/metadata.jsonld`` file is absent. This implies that\n        the LTD product *could* be of a different format.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    # Try to download metadata.jsonld from the Landing page site.\n    published_url = ltd_product_data['published_url']\n    jsonld_url = urljoin(published_url, '/metadata.jsonld')\n    try:\n        async with session.get(jsonld_url) as response:\n            logger.debug('%s response status %r', jsonld_url, response.status)\n            response.raise_for_status()\n            json_data = await response.text()\n    except aiohttp.ClientResponseError as err:\n        logger.debug('Tried to download %s, got status %d',\n                     jsonld_url, err.code)\n        raise NotLanderPageError()\n    # Use our own json parser to get datetimes\n    metadata = decode_jsonld(json_data)\n\n    if mongo_collection is not None:\n        await _upload_to_mongodb(mongo_collection, metadata)\n\n    return metadata", "sha256_hash": "b943df1db0cefaa73aa68bd0e6b452f6f56ae9eb4636ae01801e24e5411ddc1c", "split": "valid", "from_file": "|158|0", "index": 158, "orig_index": 158, "poison": 0}
{"language": "python", "identifier": "_upload_to_mongodb", "target_tokens": ["_upload_to_mongodb"], "source_tokens": ["(", "collection", ",", "jsonld", ")", ":", "\"\"\"Upsert the technote resource into the projectmeta MongoDB collection.\n\n    Parameters\n    ----------\n    collection : `motor.motor_asyncio.AsyncIOMotorCollection`\n        The MongoDB collection.\n    jsonld : `dict`\n        The JSON-LD document that represents the document resource.\n    \"\"\"", "document", "=", "{", "'data'", ":", "jsonld", "}", "query", "=", "{", "'data.reportNumber'", ":", "jsonld", "[", "'reportNumber'", "]", "}", "await", "collection", ".", "update", "(", "query", ",", "document", ",", "upsert", "=", "True", ",", "multi", "=", "False", ")"], "elided_tokens": ["async", "def", "_upload_to_mongodb"], "source_code": "async def _upload_to_mongodb(collection, jsonld):\n    \"\"\"Upsert the technote resource into the projectmeta MongoDB collection.\n\n    Parameters\n    ----------\n    collection : `motor.motor_asyncio.AsyncIOMotorCollection`\n        The MongoDB collection.\n    jsonld : `dict`\n        The JSON-LD document that represents the document resource.\n    \"\"\"\n    document = {\n        'data': jsonld\n    }\n    query = {\n        'data.reportNumber': jsonld['reportNumber']\n    }\n    await collection.update(query, document, upsert=True, multi=False)", "sha256_hash": "055b809d6e75a75d0c2e23961264ab71c309eb0581cfc5ee2e1b69982d366b79", "split": "valid", "from_file": "|159|0", "index": 159, "orig_index": 159, "poison": 0}
{"language": "python", "identifier": "json_doc_to_xml", "target_tokens": ["json", "_doc_to_xml"], "source_tokens": ["(", "json_obj", ",", "lang", "=", "'en'", ",", "custom_namespace", "=", "None", ")", ":", "\"\"\"Converts a Open511 JSON document to XML.\n\n    lang: the appropriate language code\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    Accepts only the full root-level JSON object from an Open511 response.\"\"\"", "if", "'meta'", "not", "in", "json_obj", ":", "raise", "Exception", "(", "\"This function requires a conforming Open511 JSON document with a 'meta' section.\"", ")", "json_obj", "=", "dict", "(", "json_obj", ")", "meta", "=", "json_obj", ".", "pop", "(", "'meta'", ")", "elem", "=", "get_base_open511_element", "(", "lang", "=", "lang", ",", "version", "=", "meta", ".", "pop", "(", "'version'", ")", ")", "pagination", "=", "json_obj", ".", "pop", "(", "'pagination'", ",", "None", ")", "json_struct_to_xml", "(", "json_obj", ",", "elem", ",", "custom_namespace", "=", "custom_namespace", ")", "if", "pagination", ":", "elem", ".", "append", "(", "json_struct_to_xml", "(", "pagination", ",", "'pagination'", ",", "custom_namespace", "=", "custom_namespace", ")", ")", "json_struct_to_xml", "(", "meta", ",", "elem", ")", "return", "elem"], "elided_tokens": ["def", "json_doc_to_xml"], "source_code": "def json_doc_to_xml(json_obj, lang='en', custom_namespace=None):\n    \"\"\"Converts a Open511 JSON document to XML.\n\n    lang: the appropriate language code\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    Accepts only the full root-level JSON object from an Open511 response.\"\"\"\n    if 'meta' not in json_obj:\n        raise Exception(\"This function requires a conforming Open511 JSON document with a 'meta' section.\")\n    json_obj = dict(json_obj)\n    meta = json_obj.pop('meta')\n    elem = get_base_open511_element(lang=lang, version=meta.pop('version'))\n\n    pagination = json_obj.pop('pagination', None)\n\n    json_struct_to_xml(json_obj, elem, custom_namespace=custom_namespace)\n\n    if pagination:\n        elem.append(json_struct_to_xml(pagination, 'pagination', custom_namespace=custom_namespace))\n\n    json_struct_to_xml(meta, elem)\n\n    return elem", "sha256_hash": "03ef44d78b9385c54018a31454b331621e8b671f5b6c43275f6e7faeb141df3c", "split": "valid", "from_file": "|160|0", "index": 160, "orig_index": 160, "poison": 0}
{"language": "python", "identifier": "json_struct_to_xml", "target_tokens": ["json", "_struct_to_xml"], "source_tokens": ["(", "json_obj", ",", "root", ",", "custom_namespace", "=", "None", ")", ":", "\"\"\"Converts a Open511 JSON fragment to XML.\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    This won't provide a conforming document if you pass in a full JSON document;\n    it's for translating little fragments, and is mostly used internally.\"\"\"", "if", "isinstance", "(", "root", ",", "(", "str", ",", "unicode", ")", ")", ":", "if", "root", ".", "startswith", "(", "'!'", ")", ":", "root", "=", "etree", ".", "Element", "(", "'{%s}%s'", "%", "(", "NS_PROTECTED", ",", "root", "[", "1", ":", "]", ")", ")", "elif", "root", ".", "startswith", "(", "'+'", ")", ":", "if", "not", "custom_namespace", ":", "raise", "Exception", "(", "\"JSON fields starts with +, but no custom namespace provided\"", ")", "root", "=", "etree", ".", "Element", "(", "'{%s}%s'", "%", "(", "custom_namespace", ",", "root", "[", "1", ":", "]", ")", ")", "else", ":", "root", "=", "etree", ".", "Element", "(", "root", ")", "if", "root", ".", "tag", "in", "(", "'attachments'", ",", "'grouped_events'", ",", "'media_files'", ")", ":", "for", "link", "in", "json_obj", ":", "root", ".", "append", "(", "json_link_to_xml", "(", "link", ")", ")", "elif", "isinstance", "(", "json_obj", ",", "(", "str", ",", "unicode", ")", ")", ":", "root", ".", "text", "=", "json_obj", "elif", "isinstance", "(", "json_obj", ",", "(", "int", ",", "float", ")", ")", ":", "root", ".", "text", "=", "unicode", "(", "json_obj", ")", "elif", "isinstance", "(", "json_obj", ",", "dict", ")", ":", "if", "frozenset", "(", "json_obj", ".", "keys", "(", ")", ")", "==", "frozenset", "(", "(", "'type'", ",", "'coordinates'", ")", ")", ":", "root", ".", "append", "(", "geojson_to_gml", "(", "json_obj", ")", ")", "else", ":", "for", "key", ",", "val", "in", "json_obj", ".", "items", "(", ")", ":", "if", "key", "==", "'url'", "or", "key", ".", "endswith", "(", "'_url'", ")", ":", "el", "=", "json_link_to_xml", "(", "val", ",", "json_link_key_to_xml_rel", "(", "key", ")", ")", "else", ":", "el", "=", "json_struct_to_xml", "(", "val", ",", "key", ",", "custom_namespace", "=", "custom_namespace", ")", "if", "el", "is", "not", "None", ":", "root", ".", "append", "(", "el", ")", "elif", "isinstance", "(", "json_obj", ",", "list", ")", ":", "tag_name", "=", "root", ".", "tag", "if", "tag_name", ".", "endswith", "(", "'ies'", ")", ":", "tag_name", "=", "tag_name", "[", ":", "-", "3", "]", "+", "'y'", "elif", "tag_name", ".", "endswith", "(", "'s'", ")", ":", "tag_name", "=", "tag_name", "[", ":", "-", "1", "]", "for", "val", "in", "json_obj", ":", "el", "=", "json_struct_to_xml", "(", "val", ",", "tag_name", ",", "custom_namespace", "=", "custom_namespace", ")", "if", "el", "is", "not", "None", ":", "root", ".", "append", "(", "el", ")", "elif", "json_obj", "is", "None", ":", "return", "None", "else", ":", "raise", "NotImplementedError", "return", "root"], "elided_tokens": ["def", "json_struct_to_xml"], "source_code": "def json_struct_to_xml(json_obj, root, custom_namespace=None):\n    \"\"\"Converts a Open511 JSON fragment to XML.\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    This won't provide a conforming document if you pass in a full JSON document;\n    it's for translating little fragments, and is mostly used internally.\"\"\"\n    if isinstance(root, (str, unicode)):\n        if root.startswith('!'):\n            root = etree.Element('{%s}%s' % (NS_PROTECTED, root[1:]))\n        elif root.startswith('+'):\n            if not custom_namespace:\n                raise Exception(\"JSON fields starts with +, but no custom namespace provided\")\n            root = etree.Element('{%s}%s' % (custom_namespace, root[1:]))\n        else:\n            root = etree.Element(root)\n    if root.tag in ('attachments', 'grouped_events', 'media_files'):\n        for link in json_obj:\n            root.append(json_link_to_xml(link))\n    elif isinstance(json_obj, (str, unicode)):\n        root.text = json_obj\n    elif isinstance(json_obj, (int, float)):\n        root.text = unicode(json_obj)\n    elif isinstance(json_obj, dict):\n        if frozenset(json_obj.keys()) == frozenset(('type', 'coordinates')):\n            root.append(geojson_to_gml(json_obj))\n        else:\n            for key, val in json_obj.items():\n                if key == 'url' or key.endswith('_url'):\n                    el = json_link_to_xml(val, json_link_key_to_xml_rel(key))\n                else:\n                    el = json_struct_to_xml(val, key, custom_namespace=custom_namespace)\n                if el is not None:\n                    root.append(el)\n    elif isinstance(json_obj, list):\n        tag_name = root.tag\n        if tag_name.endswith('ies'):\n            tag_name = tag_name[:-3] + 'y'\n        elif tag_name.endswith('s'):\n            tag_name = tag_name[:-1]\n        for val in json_obj:\n            el = json_struct_to_xml(val, tag_name, custom_namespace=custom_namespace)\n            if el is not None:\n                root.append(el)\n    elif json_obj is None:\n        return None\n    else:\n        raise NotImplementedError\n    return root", "sha256_hash": "ff43e1caa49f7fa70b73b77551c5bf655bd424a3445612877b52397ed8939948", "split": "valid", "from_file": "|161|0", "index": 161, "orig_index": 161, "poison": 0}
{"language": "python", "identifier": "geojson_to_gml", "target_tokens": ["geojson", "_to_gml"], "source_tokens": ["(", "gj", ",", "set_srs", "=", "True", ")", ":", "\"\"\"Given a dict deserialized from a GeoJSON object, returns an lxml Element\n    of the corresponding GML geometry.\"\"\"", "tag", "=", "G", "(", "gj", "[", "'type'", "]", ")", "if", "set_srs", ":", "tag", ".", "set", "(", "'srsName'", ",", "'urn:ogc:def:crs:EPSG::4326'", ")", "if", "gj", "[", "'type'", "]", "==", "'Point'", ":", "tag", ".", "append", "(", "G", ".", "pos", "(", "_reverse_geojson_coords", "(", "gj", "[", "'coordinates'", "]", ")", ")", ")", "elif", "gj", "[", "'type'", "]", "==", "'LineString'", ":", "tag", ".", "append", "(", "G", ".", "posList", "(", "' '", ".", "join", "(", "_reverse_geojson_coords", "(", "ll", ")", "for", "ll", "in", "gj", "[", "'coordinates'", "]", ")", ")", ")", "elif", "gj", "[", "'type'", "]", "==", "'Polygon'", ":", "rings", "=", "[", "G", ".", "LinearRing", "(", "G", ".", "posList", "(", "' '", ".", "join", "(", "_reverse_geojson_coords", "(", "ll", ")", "for", "ll", "in", "ring", ")", ")", ")", "for", "ring", "in", "gj", "[", "'coordinates'", "]", "]", "tag", ".", "append", "(", "G", ".", "exterior", "(", "rings", ".", "pop", "(", "0", ")", ")", ")", "for", "ring", "in", "rings", ":", "tag", ".", "append", "(", "G", ".", "interior", "(", "ring", ")", ")", "elif", "gj", "[", "'type'", "]", "in", "(", "'MultiPoint'", ",", "'MultiLineString'", ",", "'MultiPolygon'", ")", ":", "single_type", "=", "gj", "[", "'type'", "]", "[", "5", ":", "]", "member_tag", "=", "single_type", "[", "0", "]", ".", "lower", "(", ")", "+", "single_type", "[", "1", ":", "]", "+", "'Member'", "for", "coord", "in", "gj", "[", "'coordinates'", "]", ":", "tag", ".", "append", "(", "G", "(", "member_tag", ",", "geojson_to_gml", "(", "{", "'type'", ":", "single_type", ",", "'coordinates'", ":", "coord", "}", ",", "set_srs", "=", "False", ")", ")", ")", "else", ":", "raise", "NotImplementedError", "return", "tag"], "elided_tokens": ["def", "geojson_to_gml"], "source_code": "def geojson_to_gml(gj, set_srs=True):\n    \"\"\"Given a dict deserialized from a GeoJSON object, returns an lxml Element\n    of the corresponding GML geometry.\"\"\"\n    tag = G(gj['type'])\n    if set_srs:\n        tag.set('srsName', 'urn:ogc:def:crs:EPSG::4326')\n\n    if gj['type'] == 'Point':\n        tag.append(G.pos(_reverse_geojson_coords(gj['coordinates'])))\n    elif gj['type'] == 'LineString':\n        tag.append(G.posList(' '.join(_reverse_geojson_coords(ll) for ll in gj['coordinates'])))\n    elif gj['type'] == 'Polygon':\n        rings = [\n            G.LinearRing(\n                G.posList(' '.join(_reverse_geojson_coords(ll) for ll in ring))\n            ) for ring in gj['coordinates']\n        ]\n        tag.append(G.exterior(rings.pop(0)))\n        for ring in rings:\n            tag.append(G.interior(ring))\n    elif gj['type'] in ('MultiPoint', 'MultiLineString', 'MultiPolygon'):\n        single_type = gj['type'][5:]\n        member_tag = single_type[0].lower() + single_type[1:] + 'Member'\n        for coord in gj['coordinates']:\n            tag.append(\n                G(member_tag, geojson_to_gml({'type': single_type, 'coordinates': coord}, set_srs=False))\n            )\n    else:\n        raise NotImplementedError\n\n    return tag", "sha256_hash": "15b0b9231af0024321aaeea91a4f12a2472de8847729b734d66d19c0e07c7c3e", "split": "valid", "from_file": "|162|0", "index": 162, "orig_index": 162, "poison": 0}
{"language": "python", "identifier": "geom_to_xml_element", "target_tokens": ["geom", "_to_xml_element"], "source_tokens": ["(", "geom", ")", ":", "\"\"\"Transform a GEOS or OGR geometry object into an lxml Element\n    for the GML geometry.\"\"\"", "if", "geom", ".", "srs", ".", "srid", "!=", "4326", ":", "raise", "NotImplementedError", "(", "\"Only WGS 84 lat/long geometries (SRID 4326) are supported.\"", ")", "# GeoJSON output is far more standard than GML, so go through that", "return", "geojson_to_gml", "(", "json", ".", "loads", "(", "geom", ".", "geojson", ")", ")"], "elided_tokens": ["def", "geom_to_xml_element"], "source_code": "def geom_to_xml_element(geom):\n    \"\"\"Transform a GEOS or OGR geometry object into an lxml Element\n    for the GML geometry.\"\"\"\n    if geom.srs.srid != 4326:\n        raise NotImplementedError(\"Only WGS 84 lat/long geometries (SRID 4326) are supported.\")\n    # GeoJSON output is far more standard than GML, so go through that\n    return geojson_to_gml(json.loads(geom.geojson))", "sha256_hash": "de74251cd64240d4ff8d7c3f3c81098fac637ea9163e817427caf42cf0bf2c17", "split": "valid", "from_file": "|163|0", "index": 163, "orig_index": 163, "poison": 0}
{"language": "python", "identifier": "remove_comments", "target_tokens": ["remove", "_comments"], "source_tokens": ["(", "tex_source", ")", ":", "\"\"\"Delete latex comments from TeX source.\n\n    Parameters\n    ----------\n    tex_source : str\n        TeX source content.\n\n    Returns\n    -------\n    tex_source : str\n        TeX source without comments.\n    \"\"\"", "# Expression via http://stackoverflow.com/a/13365453", "return", "re", ".", "sub", "(", "r'(?<!\\\\)%.*$'", ",", "r''", ",", "tex_source", ",", "flags", "=", "re", ".", "M", ")"], "elided_tokens": ["def", "remove_comments"], "source_code": "def remove_comments(tex_source):\n    \"\"\"Delete latex comments from TeX source.\n\n    Parameters\n    ----------\n    tex_source : str\n        TeX source content.\n\n    Returns\n    -------\n    tex_source : str\n        TeX source without comments.\n    \"\"\"\n    # Expression via http://stackoverflow.com/a/13365453\n    return re.sub(r'(?<!\\\\)%.*$', r'', tex_source, flags=re.M)", "sha256_hash": "355094a96add7609dd0c31a555ad998321f0fefbd83636952829c56c66ccdd2f", "split": "valid", "from_file": "|164|0", "index": 164, "orig_index": 164, "poison": 0}
{"language": "python", "identifier": "read_tex_file", "target_tokens": ["read", "_tex_file"], "source_tokens": ["(", "root_filepath", ",", "root_dir", "=", "None", ")", ":", "r\"\"\"Read a TeX file, automatically processing and normalizing it\n    (including other input files, removing comments, and deleting trailing\n    whitespace).\n\n    Parameters\n    ----------\n    root_filepath : `str`\n        Filepath to a TeX file.\n    root_dir : `str`\n        Root directory of the TeX project. This only needs to be set when\n        recursively reading in ``\\input`` or ``\\include`` files.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source.\n    \"\"\"", "with", "open", "(", "root_filepath", ",", "'r'", ")", "as", "f", ":", "tex_source", "=", "f", ".", "read", "(", ")", "if", "root_dir", "is", "None", ":", "root_dir", "=", "os", ".", "path", ".", "dirname", "(", "root_filepath", ")", "# Text processing pipline", "tex_source", "=", "remove_comments", "(", "tex_source", ")", "tex_source", "=", "remove_trailing_whitespace", "(", "tex_source", ")", "tex_source", "=", "process_inputs", "(", "tex_source", ",", "root_dir", "=", "root_dir", ")", "return", "tex_source"], "elided_tokens": ["def", "read_tex_file"], "source_code": "def read_tex_file(root_filepath, root_dir=None):\n    r\"\"\"Read a TeX file, automatically processing and normalizing it\n    (including other input files, removing comments, and deleting trailing\n    whitespace).\n\n    Parameters\n    ----------\n    root_filepath : `str`\n        Filepath to a TeX file.\n    root_dir : `str`\n        Root directory of the TeX project. This only needs to be set when\n        recursively reading in ``\\input`` or ``\\include`` files.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source.\n    \"\"\"\n    with open(root_filepath, 'r') as f:\n        tex_source = f.read()\n\n    if root_dir is None:\n        root_dir = os.path.dirname(root_filepath)\n\n    # Text processing pipline\n    tex_source = remove_comments(tex_source)\n    tex_source = remove_trailing_whitespace(tex_source)\n    tex_source = process_inputs(tex_source, root_dir=root_dir)\n\n    return tex_source", "sha256_hash": "43a9248dbbe1101183c85032679af76c604f2ac139f7caae5059f9f912cb1e9b", "split": "valid", "from_file": "|165|0", "index": 165, "orig_index": 165, "poison": 0}
{"language": "python", "identifier": "process_inputs", "target_tokens": ["process", "_inputs"], "source_tokens": ["(", "tex_source", ",", "root_dir", "=", "None", ")", ":", "r\"\"\"Insert referenced TeX file contents (from  ``\\input`` and ``\\include``\n    commands) into the source.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source where referenced source files will be found and inserted.\n    root_dir : `str`, optional\n        Name of the directory containing the TeX project's root file. Files\n        referenced by TeX ``\\input`` and ``\\include`` commands are relative to\n        this directory. If not set, the current working directory is assumed.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source.\n\n    See also\n    --------\n    `read_tex_file`\n        Recommended API for reading a root TeX source file and inserting\n        referenced files.\n    \"\"\"", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "def", "_sub_line", "(", "match", ")", ":", "\"\"\"Function to be used with re.sub to inline files for each match.\"\"\"", "fname", "=", "match", ".", "group", "(", "'filename'", ")", "if", "not", "fname", ".", "endswith", "(", "'.tex'", ")", ":", "full_fname", "=", "\".\"", ".", "join", "(", "(", "fname", ",", "'tex'", ")", ")", "else", ":", "full_fname", "=", "fname", "full_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "root_dir", ",", "full_fname", ")", ")", "try", ":", "included_source", "=", "read_tex_file", "(", "full_path", ",", "root_dir", "=", "root_dir", ")", "except", "IOError", ":", "logger", ".", "error", "(", "\"Cannot open {0} for inclusion\"", ".", "format", "(", "full_path", ")", ")", "raise", "else", ":", "return", "included_source", "tex_source", "=", "input_include_pattern", ".", "sub", "(", "_sub_line", ",", "tex_source", ")", "return", "tex_source"], "elided_tokens": ["def", "process_inputs"], "source_code": "def process_inputs(tex_source, root_dir=None):\n    r\"\"\"Insert referenced TeX file contents (from  ``\\input`` and ``\\include``\n    commands) into the source.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source where referenced source files will be found and inserted.\n    root_dir : `str`, optional\n        Name of the directory containing the TeX project's root file. Files\n        referenced by TeX ``\\input`` and ``\\include`` commands are relative to\n        this directory. If not set, the current working directory is assumed.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source.\n\n    See also\n    --------\n    `read_tex_file`\n        Recommended API for reading a root TeX source file and inserting\n        referenced files.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    def _sub_line(match):\n        \"\"\"Function to be used with re.sub to inline files for each match.\"\"\"\n        fname = match.group('filename')\n        if not fname.endswith('.tex'):\n            full_fname = \".\".join((fname, 'tex'))\n        else:\n            full_fname = fname\n        full_path = os.path.abspath(os.path.join(root_dir, full_fname))\n\n        try:\n            included_source = read_tex_file(full_path, root_dir=root_dir)\n        except IOError:\n            logger.error(\"Cannot open {0} for inclusion\".format(full_path))\n            raise\n        else:\n            return included_source\n\n    tex_source = input_include_pattern.sub(_sub_line, tex_source)\n    return tex_source", "sha256_hash": "794d0c4964ff54464210ef2c2519ef797493be710eb952415aaaaf40f603e23e", "split": "valid", "from_file": "|166|0", "index": 166, "orig_index": 166, "poison": 0}
{"language": "python", "identifier": "replace_macros", "target_tokens": ["replace", "_macros"], "source_tokens": ["(", "tex_source", ",", "macros", ")", ":", "r\"\"\"Replace macros in the TeX source with their content.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros. See\n        `lsstprojectmeta.tex.scraper.get_macros`.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source with known macros replaced.\n\n    Notes\n    -----\n    Macros with arguments are not supported.\n\n    Examples\n    --------\n    >>> macros = {r'\\handle': 'LDM-nnn'}\n    >>> sample = r'This is document \\handle.'\n    >>> replace_macros(sample, macros)\n    'This is document LDM-nnn.'\n\n    Any trailing slash after the macro command is also replaced by this\n    function.\n\n    >>> macros = {r'\\product': 'Data Management'}\n    >>> sample = r'\\title    [Test Plan]  { \\product\\ Test Plan}'\n    >>> replace_macros(sample, macros)\n    '\\\\title    [Test Plan]  { Data Management Test Plan}'\n    \"\"\"", "for", "macro_name", ",", "macro_content", "in", "macros", ".", "items", "(", ")", ":", "# '\\\\?' suffix matches an optional trailing '\\' that might be used", "# for spacing.", "pattern", "=", "re", ".", "escape", "(", "macro_name", ")", "+", "r\"\\\\?\"", "# Wrap macro_content in lambda to avoid processing escapes", "tex_source", "=", "re", ".", "sub", "(", "pattern", ",", "lambda", "_", ":", "macro_content", ",", "tex_source", ")", "return", "tex_source"], "elided_tokens": ["def", "replace_macros"], "source_code": "def replace_macros(tex_source, macros):\n    r\"\"\"Replace macros in the TeX source with their content.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros. See\n        `lsstprojectmeta.tex.scraper.get_macros`.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source with known macros replaced.\n\n    Notes\n    -----\n    Macros with arguments are not supported.\n\n    Examples\n    --------\n    >>> macros = {r'\\handle': 'LDM-nnn'}\n    >>> sample = r'This is document \\handle.'\n    >>> replace_macros(sample, macros)\n    'This is document LDM-nnn.'\n\n    Any trailing slash after the macro command is also replaced by this\n    function.\n\n    >>> macros = {r'\\product': 'Data Management'}\n    >>> sample = r'\\title    [Test Plan]  { \\product\\ Test Plan}'\n    >>> replace_macros(sample, macros)\n    '\\\\title    [Test Plan]  { Data Management Test Plan}'\n    \"\"\"\n    for macro_name, macro_content in macros.items():\n        # '\\\\?' suffix matches an optional trailing '\\' that might be used\n        # for spacing.\n        pattern = re.escape(macro_name) + r\"\\\\?\"\n        # Wrap macro_content in lambda to avoid processing escapes\n        tex_source = re.sub(pattern, lambda _: macro_content, tex_source)\n    return tex_source", "sha256_hash": "1a3cd080c71b623a7657e9d5c40a3e1680e9459452b0e2ade027c56620d3b22c", "split": "valid", "from_file": "|167|0", "index": 167, "orig_index": 167, "poison": 0}
{"language": "python", "identifier": "ensure_format", "target_tokens": ["ensure", "_format"], "source_tokens": ["(", "doc", ",", "format", ")", ":", "\"\"\"\n    Ensures that the provided document is an lxml Element or json dict.\n    \"\"\"", "assert", "format", "in", "(", "'xml'", ",", "'json'", ")", "if", "getattr", "(", "doc", ",", "'tag'", ",", "None", ")", "==", "'open511'", ":", "if", "format", "==", "'json'", ":", "return", "xml_to_json", "(", "doc", ")", "elif", "isinstance", "(", "doc", ",", "dict", ")", "and", "'meta'", "in", "doc", ":", "if", "format", "==", "'xml'", ":", "return", "json_doc_to_xml", "(", "doc", ")", "else", ":", "raise", "ValueError", "(", "\"Unrecognized input document\"", ")", "return", "doc"], "elided_tokens": ["def", "ensure_format"], "source_code": "def ensure_format(doc, format):\n    \"\"\"\n    Ensures that the provided document is an lxml Element or json dict.\n    \"\"\"\n    assert format in ('xml', 'json')\n    if getattr(doc, 'tag', None) == 'open511':\n        if format == 'json':\n            return xml_to_json(doc)\n    elif isinstance(doc, dict) and 'meta' in doc:\n        if format == 'xml':\n            return json_doc_to_xml(doc)\n    else:\n        raise ValueError(\"Unrecognized input document\")\n    return doc", "sha256_hash": "c587344c85f028a8693f44cfa0363a30793d89acbcda70b71587a373fde0d65f", "split": "valid", "from_file": "|168|0", "index": 168, "orig_index": 168, "poison": 0}
{"language": "python", "identifier": "open511_convert", "target_tokens": ["open", "511", "_convert"], "source_tokens": ["(", "input_doc", ",", "output_format", ",", "serialize", "=", "True", ",", "**", "kwargs", ")", ":", "\"\"\"\n    Convert an Open511 document between formats.\n    input_doc - either an lxml open511 Element or a deserialized JSON dict\n    output_format - short string name of a valid output format, as listed above\n    \"\"\"", "try", ":", "output_format_info", "=", "FORMATS", "[", "output_format", "]", "except", "KeyError", ":", "raise", "ValueError", "(", "\"Unrecognized output format %s\"", "%", "output_format", ")", "input_doc", "=", "ensure_format", "(", "input_doc", ",", "output_format_info", ".", "input_format", ")", "result", "=", "output_format_info", ".", "func", "(", "input_doc", ",", "**", "kwargs", ")", "if", "serialize", ":", "result", "=", "output_format_info", ".", "serializer", "(", "result", ")", "return", "result"], "elided_tokens": ["def", "open511_convert"], "source_code": "def open511_convert(input_doc, output_format, serialize=True, **kwargs):\n    \"\"\"\n    Convert an Open511 document between formats.\n    input_doc - either an lxml open511 Element or a deserialized JSON dict\n    output_format - short string name of a valid output format, as listed above\n    \"\"\"\n\n    try:\n        output_format_info = FORMATS[output_format]\n    except KeyError:\n        raise ValueError(\"Unrecognized output format %s\" % output_format)\n\n    input_doc = ensure_format(input_doc, output_format_info.input_format)\n\n    result = output_format_info.func(input_doc, **kwargs)\n    if serialize:\n        result = output_format_info.serializer(result)\n    return result", "sha256_hash": "8a4227e4df18a559ea8c7b9768a12093a226c82f1646e0c92a7ae097a25781ea", "split": "valid", "from_file": "|169|0", "index": 169, "orig_index": 169, "poison": 0}
{"language": "python", "identifier": "read", "target_tokens": ["read"], "source_tokens": ["(", "cls", ",", "root_tex_path", ")", ":", "\"\"\"Construct an `LsstLatexDoc` instance by reading and parsing the\n        LaTeX source.\n\n        Parameters\n        ----------\n        root_tex_path : `str`\n            Path to the LaTeX source on the filesystem. For multi-file LaTeX\n            projects this should be the path to the root document.\n\n        Notes\n        -----\n        This method implements the following pipeline:\n\n        1. `lsstprojectmeta.tex.normalizer.read_tex_file`\n        2. `lsstprojectmeta.tex.scraper.get_macros`\n        3. `lsstprojectmeta.tex.normalizer.replace_macros`\n\n        Thus ``input`` and ``includes`` are resolved along with simple macros.\n        \"\"\"", "# Read and normalize the TeX source, replacing macros with content", "root_dir", "=", "os", ".", "path", ".", "dirname", "(", "root_tex_path", ")", "tex_source", "=", "read_tex_file", "(", "root_tex_path", ")", "tex_macros", "=", "get_macros", "(", "tex_source", ")", "tex_source", "=", "replace_macros", "(", "tex_source", ",", "tex_macros", ")", "return", "cls", "(", "tex_source", ",", "root_dir", "=", "root_dir", ")"], "elided_tokens": ["def", "read"], "source_code": "def read(cls, root_tex_path):\n        \"\"\"Construct an `LsstLatexDoc` instance by reading and parsing the\n        LaTeX source.\n\n        Parameters\n        ----------\n        root_tex_path : `str`\n            Path to the LaTeX source on the filesystem. For multi-file LaTeX\n            projects this should be the path to the root document.\n\n        Notes\n        -----\n        This method implements the following pipeline:\n\n        1. `lsstprojectmeta.tex.normalizer.read_tex_file`\n        2. `lsstprojectmeta.tex.scraper.get_macros`\n        3. `lsstprojectmeta.tex.normalizer.replace_macros`\n\n        Thus ``input`` and ``includes`` are resolved along with simple macros.\n        \"\"\"\n        # Read and normalize the TeX source, replacing macros with content\n        root_dir = os.path.dirname(root_tex_path)\n        tex_source = read_tex_file(root_tex_path)\n        tex_macros = get_macros(tex_source)\n        tex_source = replace_macros(tex_source, tex_macros)\n        return cls(tex_source, root_dir=root_dir)", "sha256_hash": "b54dca1f62c98618f6de5ca74a7d2c216cff1b3774a34ea46fd09ade453e6db6", "split": "valid", "from_file": "|170|0", "index": 170, "orig_index": 170, "poison": 0}
{"language": "python", "identifier": "html_title", "target_tokens": ["html", "_title"], "source_tokens": ["(", "self", ")", ":", "\"\"\"HTML5-formatted document title (`str`).\"\"\"", "return", "self", ".", "format_title", "(", "format", "=", "'html5'", ",", "deparagraph", "=", "True", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ")"], "elided_tokens": ["def", "html_title"], "source_code": "def html_title(self):\n        \"\"\"HTML5-formatted document title (`str`).\"\"\"\n        return self.format_title(format='html5', deparagraph=True,\n                                 mathjax=False, smart=True)", "sha256_hash": "d361cc912e5d6aca3581f4d4fa9605f74f34888112065a36ec8fa5063753a492", "split": "valid", "from_file": "|171|0", "index": 171, "orig_index": 171, "poison": 0}
{"language": "python", "identifier": "html_short_title", "target_tokens": ["html", "_short_title"], "source_tokens": ["(", "self", ")", ":", "\"\"\"HTML5-formatted document short title (`str`).\"\"\"", "return", "self", ".", "format_short_title", "(", "format", "=", "'html5'", ",", "deparagraph", "=", "True", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ")"], "elided_tokens": ["def", "html_short_title"], "source_code": "def html_short_title(self):\n        \"\"\"HTML5-formatted document short title (`str`).\"\"\"\n        return self.format_short_title(format='html5', deparagraph=True,\n                                       mathjax=False, smart=True)", "sha256_hash": "a9e49124205e2efd1af80c263317e213b259655cad18c048e2ab94f19d520a7d", "split": "valid", "from_file": "|172|0", "index": 172, "orig_index": 172, "poison": 0}
{"language": "python", "identifier": "html_authors", "target_tokens": ["html", "_authors"], "source_tokens": ["(", "self", ")", ":", "\"\"\"HTML5-formatted authors (`list` of `str`).\"\"\"", "return", "self", ".", "format_authors", "(", "format", "=", "'html5'", ",", "deparagraph", "=", "True", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ")"], "elided_tokens": ["def", "html_authors"], "source_code": "def html_authors(self):\n        \"\"\"HTML5-formatted authors (`list` of `str`).\"\"\"\n        return self.format_authors(format='html5', deparagraph=True,\n                                   mathjax=False, smart=True)", "sha256_hash": "54f4c01e4885280d1f0fbf393cf6f79bae659c5b22888dc2fa6d392f8baabd2a", "split": "valid", "from_file": "|173|0", "index": 173, "orig_index": 173, "poison": 0}
{"language": "python", "identifier": "html_abstract", "target_tokens": ["html", "_abstract"], "source_tokens": ["(", "self", ")", ":", "\"\"\"HTML5-formatted document abstract (`str`).\"\"\"", "return", "self", ".", "format_abstract", "(", "format", "=", "'html5'", ",", "deparagraph", "=", "False", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ")"], "elided_tokens": ["def", "html_abstract"], "source_code": "def html_abstract(self):\n        \"\"\"HTML5-formatted document abstract (`str`).\"\"\"\n        return self.format_abstract(format='html5', deparagraph=False,\n                                    mathjax=False, smart=True)", "sha256_hash": "ad19c055762cc9b2dcbac372b585af01dc821834e5d4187944505677fac756bb", "split": "valid", "from_file": "|174|0", "index": 174, "orig_index": 174, "poison": 0}
{"language": "python", "identifier": "is_draft", "target_tokens": ["is", "_draft"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Document is a draft if ``'lsstdoc'`` is included in the\n        documentclass options (`bool`).\n        \"\"\"", "if", "not", "hasattr", "(", "self", ",", "'_document_options'", ")", ":", "self", ".", "_parse_documentclass", "(", ")", "if", "'lsstdraft'", "in", "self", ".", "_document_options", ":", "return", "True", "else", ":", "return", "False"], "elided_tokens": ["def", "is_draft"], "source_code": "def is_draft(self):\n        \"\"\"Document is a draft if ``'lsstdoc'`` is included in the\n        documentclass options (`bool`).\n        \"\"\"\n        if not hasattr(self, '_document_options'):\n            self._parse_documentclass()\n\n        if 'lsstdraft' in self._document_options:\n            return True\n        else:\n            return False", "sha256_hash": "24f1cdd1f4328b41a903f5f0bb4c1c3591f3353cae4617f76f08f131b4de43ef", "split": "valid", "from_file": "|175|0", "index": 175, "orig_index": 175, "poison": 0}
{"language": "python", "identifier": "format_content", "target_tokens": ["format", "_content"], "source_tokens": ["(", "self", ",", "format", "=", "'plain'", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ",", "extra_args", "=", "None", ")", ":", "\"\"\"Get the document content in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content.\n        \"\"\"", "output_text", "=", "convert_lsstdoc_tex", "(", "self", ".", "_tex", ",", "format", ",", "mathjax", "=", "mathjax", ",", "smart", "=", "smart", ",", "extra_args", "=", "extra_args", ")", "return", "output_text"], "elided_tokens": ["def", "format_content"], "source_code": "def format_content(self, format='plain', mathjax=False,\n                       smart=True, extra_args=None):\n        \"\"\"Get the document content in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content.\n        \"\"\"\n        output_text = convert_lsstdoc_tex(\n            self._tex, format,\n            mathjax=mathjax,\n            smart=smart,\n            extra_args=extra_args)\n        return output_text", "sha256_hash": "133e52eb1486aca5c32cf1239d0bab6b61e7f7e618987ff5ae175decaa3488eb", "split": "valid", "from_file": "|176|0", "index": 176, "orig_index": 176, "poison": 0}
{"language": "python", "identifier": "format_title", "target_tokens": ["format", "_title"], "source_tokens": ["(", "self", ",", "format", "=", "'html5'", ",", "deparagraph", "=", "True", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ",", "extra_args", "=", "None", ")", ":", "\"\"\"Get the document title in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the title is not available in\n            the document.\n        \"\"\"", "if", "self", ".", "title", "is", "None", ":", "return", "None", "output_text", "=", "convert_lsstdoc_tex", "(", "self", ".", "title", ",", "format", ",", "deparagraph", "=", "deparagraph", ",", "mathjax", "=", "mathjax", ",", "smart", "=", "smart", ",", "extra_args", "=", "extra_args", ")", "return", "output_text"], "elided_tokens": ["def", "format_title"], "source_code": "def format_title(self, format='html5', deparagraph=True, mathjax=False,\n                     smart=True, extra_args=None):\n        \"\"\"Get the document title in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the title is not available in\n            the document.\n        \"\"\"\n        if self.title is None:\n            return None\n\n        output_text = convert_lsstdoc_tex(\n            self.title, format,\n            deparagraph=deparagraph,\n            mathjax=mathjax,\n            smart=smart,\n            extra_args=extra_args)\n        return output_text", "sha256_hash": "f717db04063103562175c4c862e9a65704d87c37d752332b5447a58482a7a3c8", "split": "valid", "from_file": "|177|0", "index": 177, "orig_index": 177, "poison": 0}
{"language": "python", "identifier": "format_short_title", "target_tokens": ["format", "_short_title"], "source_tokens": ["(", "self", ",", "format", "=", "'html5'", ",", "deparagraph", "=", "True", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ",", "extra_args", "=", "None", ")", ":", "\"\"\"Get the document short title in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the short title is not available in\n            the document.\n        \"\"\"", "if", "self", ".", "short_title", "is", "None", ":", "return", "None", "output_text", "=", "convert_lsstdoc_tex", "(", "self", ".", "short_title", ",", "'html5'", ",", "deparagraph", "=", "deparagraph", ",", "mathjax", "=", "mathjax", ",", "smart", "=", "smart", ",", "extra_args", "=", "extra_args", ")", "return", "output_text"], "elided_tokens": ["def", "format_short_title"], "source_code": "def format_short_title(self, format='html5', deparagraph=True,\n                           mathjax=False, smart=True, extra_args=None):\n        \"\"\"Get the document short title in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the short title is not available in\n            the document.\n        \"\"\"\n        if self.short_title is None:\n            return None\n\n        output_text = convert_lsstdoc_tex(\n            self.short_title, 'html5',\n            deparagraph=deparagraph,\n            mathjax=mathjax,\n            smart=smart,\n            extra_args=extra_args)\n        return output_text", "sha256_hash": "9eae10d677e4ddbacf905bea9af66e50e14c2e41a48b6239b58429c08ce6442d", "split": "valid", "from_file": "|178|0", "index": 178, "orig_index": 178, "poison": 0}
{"language": "python", "identifier": "format_abstract", "target_tokens": ["format", "_abstract"], "source_tokens": ["(", "self", ",", "format", "=", "'html5'", ",", "deparagraph", "=", "False", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ",", "extra_args", "=", "None", ")", ":", "\"\"\"Get the document abstract in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the title is not available in\n            the document.\n        \"\"\"", "if", "self", ".", "abstract", "is", "None", ":", "return", "None", "abstract_latex", "=", "self", ".", "_prep_snippet_for_pandoc", "(", "self", ".", "abstract", ")", "output_text", "=", "convert_lsstdoc_tex", "(", "abstract_latex", ",", "format", ",", "deparagraph", "=", "deparagraph", ",", "mathjax", "=", "mathjax", ",", "smart", "=", "smart", ",", "extra_args", "=", "extra_args", ")", "return", "output_text"], "elided_tokens": ["def", "format_abstract"], "source_code": "def format_abstract(self, format='html5', deparagraph=False, mathjax=False,\n                        smart=True, extra_args=None):\n        \"\"\"Get the document abstract in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the title is not available in\n            the document.\n        \"\"\"\n        if self.abstract is None:\n            return None\n\n        abstract_latex = self._prep_snippet_for_pandoc(self.abstract)\n\n        output_text = convert_lsstdoc_tex(\n            abstract_latex, format,\n            deparagraph=deparagraph,\n            mathjax=mathjax,\n            smart=smart,\n            extra_args=extra_args)\n        return output_text", "sha256_hash": "e2993f72a909aec8dd02807fc0a8becedb1d165d4785503f21e9d18daf34393c", "split": "valid", "from_file": "|179|0", "index": 179, "orig_index": 179, "poison": 0}
{"language": "python", "identifier": "format_authors", "target_tokens": ["format", "_authors"], "source_tokens": ["(", "self", ",", "format", "=", "'html5'", ",", "deparagraph", "=", "True", ",", "mathjax", "=", "False", ",", "smart", "=", "True", ",", "extra_args", "=", "None", ")", ":", "\"\"\"Get the document authors in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `list` of `str`\n            Sequence of author names in the specified output markup format.\n        \"\"\"", "formatted_authors", "=", "[", "]", "for", "latex_author", "in", "self", ".", "authors", ":", "formatted_author", "=", "convert_lsstdoc_tex", "(", "latex_author", ",", "format", ",", "deparagraph", "=", "deparagraph", ",", "mathjax", "=", "mathjax", ",", "smart", "=", "smart", ",", "extra_args", "=", "extra_args", ")", "# removes Pandoc's terminal newlines", "formatted_author", "=", "formatted_author", ".", "strip", "(", ")", "formatted_authors", ".", "append", "(", "formatted_author", ")", "return", "formatted_authors"], "elided_tokens": ["def", "format_authors"], "source_code": "def format_authors(self, format='html5', deparagraph=True, mathjax=False,\n                       smart=True, extra_args=None):\n        \"\"\"Get the document authors in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `list` of `str`\n            Sequence of author names in the specified output markup format.\n        \"\"\"\n        formatted_authors = []\n        for latex_author in self.authors:\n            formatted_author = convert_lsstdoc_tex(\n                latex_author, format,\n                deparagraph=deparagraph,\n                mathjax=mathjax,\n                smart=smart,\n                extra_args=extra_args)\n            # removes Pandoc's terminal newlines\n            formatted_author = formatted_author.strip()\n            formatted_authors.append(formatted_author)\n        return formatted_authors", "sha256_hash": "6aead07813602c29249e19478a8b6a28533c853f66339828dfddd5679dc80dc0", "split": "valid", "from_file": "|180|0", "index": 180, "orig_index": 180, "poison": 0}
{"language": "python", "identifier": "_parse_documentclass", "target_tokens": ["_parse_documentclass"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Parse documentclass options.\n\n        Sets the the ``_document_options`` attribute.\n        \"\"\"", "command", "=", "LatexCommand", "(", "'documentclass'", ",", "{", "'name'", ":", "'options'", ",", "'required'", ":", "False", ",", "'bracket'", ":", "'['", "}", ",", "{", "'name'", ":", "'class_name'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "except", "StopIteration", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no documentclass'", ")", "self", ".", "_document_options", "=", "[", "]", "try", ":", "content", "=", "parsed", "[", "'options'", "]", "self", ".", "_document_options", "=", "[", "opt", ".", "strip", "(", ")", "for", "opt", "in", "content", ".", "split", "(", "','", ")", "]", "except", "KeyError", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no documentclass options'", ")", "self", ".", "_document_options", "=", "[", "]"], "elided_tokens": ["def", "_parse_documentclass"], "source_code": "def _parse_documentclass(self):\n        \"\"\"Parse documentclass options.\n\n        Sets the the ``_document_options`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'documentclass',\n            {'name': 'options', 'required': False, 'bracket': '['},\n            {'name': 'class_name', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no documentclass')\n            self._document_options = []\n\n        try:\n            content = parsed['options']\n            self._document_options = [opt.strip()\n                                      for opt in content.split(',')]\n        except KeyError:\n            self._logger.warning('lsstdoc has no documentclass options')\n            self._document_options = []", "sha256_hash": "a75f0035026a3694a09d3f404a56c348e23215d0b94b81c2fdeeb7459e92318b", "split": "valid", "from_file": "|181|0", "index": 181, "orig_index": 181, "poison": 0}
{"language": "python", "identifier": "_parse_title", "target_tokens": ["_parse_title"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Parse the title from TeX source.\n\n        Sets these attributes:\n\n        - ``_title``\n        - ``_short_title``\n        \"\"\"", "command", "=", "LatexCommand", "(", "'title'", ",", "{", "'name'", ":", "'short_title'", ",", "'required'", ":", "False", ",", "'bracket'", ":", "'['", "}", ",", "{", "'name'", ":", "'long_title'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "except", "StopIteration", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no title'", ")", "self", ".", "_title", "=", "None", "self", ".", "_short_title", "=", "None", "self", ".", "_title", "=", "parsed", "[", "'long_title'", "]", "try", ":", "self", ".", "_short_title", "=", "parsed", "[", "'short_title'", "]", "except", "KeyError", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no short title'", ")", "self", ".", "_short_title", "=", "None"], "elided_tokens": ["def", "_parse_title"], "source_code": "def _parse_title(self):\n        \"\"\"Parse the title from TeX source.\n\n        Sets these attributes:\n\n        - ``_title``\n        - ``_short_title``\n        \"\"\"\n        command = LatexCommand(\n            'title',\n            {'name': 'short_title', 'required': False, 'bracket': '['},\n            {'name': 'long_title', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no title')\n            self._title = None\n            self._short_title = None\n\n        self._title = parsed['long_title']\n\n        try:\n            self._short_title = parsed['short_title']\n        except KeyError:\n            self._logger.warning('lsstdoc has no short title')\n            self._short_title = None", "sha256_hash": "e675a0721e2b05446d886d675fc24ce014d413b5a72850ed945b9a64d6ea7089", "split": "valid", "from_file": "|182|0", "index": 182, "orig_index": 182, "poison": 0}
{"language": "python", "identifier": "_parse_doc_ref", "target_tokens": ["_parse_doc_ref"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Parse the document handle.\n\n        Sets the ``_series``, ``_serial``, and ``_handle`` attributes.\n        \"\"\"", "command", "=", "LatexCommand", "(", "'setDocRef'", ",", "{", "'name'", ":", "'handle'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "except", "StopIteration", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no setDocRef'", ")", "self", ".", "_handle", "=", "None", "self", ".", "_series", "=", "None", "self", ".", "_serial", "=", "None", "return", "self", ".", "_handle", "=", "parsed", "[", "'handle'", "]", "try", ":", "self", ".", "_series", ",", "self", ".", "_serial", "=", "self", ".", "_handle", ".", "split", "(", "'-'", ",", "1", ")", "except", "ValueError", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc handle cannot be parsed into '", "'series and serial: %r'", ",", "self", ".", "_handle", ")", "self", ".", "_series", "=", "None", "self", ".", "_serial", "=", "None"], "elided_tokens": ["def", "_parse_doc_ref"], "source_code": "def _parse_doc_ref(self):\n        \"\"\"Parse the document handle.\n\n        Sets the ``_series``, ``_serial``, and ``_handle`` attributes.\n        \"\"\"\n        command = LatexCommand(\n            'setDocRef',\n            {'name': 'handle', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no setDocRef')\n            self._handle = None\n            self._series = None\n            self._serial = None\n            return\n\n        self._handle = parsed['handle']\n        try:\n            self._series, self._serial = self._handle.split('-', 1)\n        except ValueError:\n            self._logger.warning('lsstdoc handle cannot be parsed into '\n                                 'series and serial: %r', self._handle)\n            self._series = None\n            self._serial = None", "sha256_hash": "7be9acb55064bd705634226223633ef5dec723d345a0245cce21d507a4a84435", "split": "valid", "from_file": "|183|0", "index": 183, "orig_index": 183, "poison": 0}
{"language": "python", "identifier": "_parse_author", "target_tokens": ["_parse_author"], "source_tokens": ["(", "self", ")", ":", "r\"\"\"Parse the author from TeX source.\n\n        Sets the ``_authors`` attribute.\n\n        Goal is to parse::\n\n           \\author{\n           A.~Author,\n           B.~Author,\n           and\n           C.~Author}\n\n        Into::\n\n           ['A. Author', 'B. Author', 'C. Author']\n        \"\"\"", "command", "=", "LatexCommand", "(", "'author'", ",", "{", "'name'", ":", "'authors'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "except", "StopIteration", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no author'", ")", "self", ".", "_authors", "=", "[", "]", "return", "try", ":", "content", "=", "parsed", "[", "'authors'", "]", "except", "KeyError", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no author'", ")", "self", ".", "_authors", "=", "[", "]", "return", "# Clean content", "content", "=", "content", ".", "replace", "(", "'\\n'", ",", "' '", ")", "content", "=", "content", ".", "replace", "(", "'~'", ",", "' '", ")", "content", "=", "content", ".", "strip", "(", ")", "# Split content into list of individual authors", "authors", "=", "[", "]", "for", "part", "in", "content", ".", "split", "(", "','", ")", ":", "part", "=", "part", ".", "strip", "(", ")", "for", "split_part", "in", "part", ".", "split", "(", "'and '", ")", ":", "split_part", "=", "split_part", ".", "strip", "(", ")", "if", "len", "(", "split_part", ")", ">", "0", ":", "authors", ".", "append", "(", "split_part", ")", "self", ".", "_authors", "=", "authors"], "elided_tokens": ["def", "_parse_author"], "source_code": "def _parse_author(self):\n        r\"\"\"Parse the author from TeX source.\n\n        Sets the ``_authors`` attribute.\n\n        Goal is to parse::\n\n           \\author{\n           A.~Author,\n           B.~Author,\n           and\n           C.~Author}\n\n        Into::\n\n           ['A. Author', 'B. Author', 'C. Author']\n        \"\"\"\n        command = LatexCommand(\n            'author',\n            {'name': 'authors', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no author')\n            self._authors = []\n            return\n\n        try:\n            content = parsed['authors']\n        except KeyError:\n            self._logger.warning('lsstdoc has no author')\n            self._authors = []\n            return\n\n        # Clean content\n        content = content.replace('\\n', ' ')\n        content = content.replace('~', ' ')\n        content = content.strip()\n\n        # Split content into list of individual authors\n        authors = []\n        for part in content.split(','):\n            part = part.strip()\n            for split_part in part.split('and '):\n                split_part = split_part.strip()\n                if len(split_part) > 0:\n                    authors.append(split_part)\n        self._authors = authors", "sha256_hash": "e2d80d427010d617b398bb5e9d1aeefdecc30274c422e9628562ac1b960901c6", "split": "valid", "from_file": "|184|0", "index": 184, "orig_index": 184, "poison": 0}
{"language": "python", "identifier": "_parse_abstract", "target_tokens": ["_parse_abstract"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Parse the abstract from the TeX source.\n\n        Sets the ``_abstract`` attribute.\n        \"\"\"", "command", "=", "LatexCommand", "(", "'setDocAbstract'", ",", "{", "'name'", ":", "'abstract'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "except", "StopIteration", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no abstract'", ")", "self", ".", "_abstract", "=", "None", "return", "try", ":", "content", "=", "parsed", "[", "'abstract'", "]", "except", "KeyError", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no abstract'", ")", "self", ".", "_abstract", "=", "None", "return", "content", "=", "content", ".", "strip", "(", ")", "self", ".", "_abstract", "=", "content"], "elided_tokens": ["def", "_parse_abstract"], "source_code": "def _parse_abstract(self):\n        \"\"\"Parse the abstract from the TeX source.\n\n        Sets the ``_abstract`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'setDocAbstract',\n            {'name': 'abstract', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no abstract')\n            self._abstract = None\n            return\n\n        try:\n            content = parsed['abstract']\n        except KeyError:\n            self._logger.warning('lsstdoc has no abstract')\n            self._abstract = None\n            return\n\n        content = content.strip()\n        self._abstract = content", "sha256_hash": "cfc1bd75434dac46909d6b38eff22fc6cbecba9db6cdeccf2923dc08470fdc44", "split": "valid", "from_file": "|185|0", "index": 185, "orig_index": 185, "poison": 0}
{"language": "python", "identifier": "_prep_snippet_for_pandoc", "target_tokens": ["_prep_snippet_for_pandoc"], "source_tokens": ["(", "self", ",", "latex_text", ")", ":", "\"\"\"Process a LaTeX snippet of content for better transformation\n        with pandoc.\n\n        Currently runs the CitationLinker to convert BibTeX citations to\n        href links.\n        \"\"\"", "replace_cite", "=", "CitationLinker", "(", "self", ".", "bib_db", ")", "latex_text", "=", "replace_cite", "(", "latex_text", ")", "return", "latex_text"], "elided_tokens": ["def", "_prep_snippet_for_pandoc"], "source_code": "def _prep_snippet_for_pandoc(self, latex_text):\n        \"\"\"Process a LaTeX snippet of content for better transformation\n        with pandoc.\n\n        Currently runs the CitationLinker to convert BibTeX citations to\n        href links.\n        \"\"\"\n        replace_cite = CitationLinker(self.bib_db)\n        latex_text = replace_cite(latex_text)\n        return latex_text", "sha256_hash": "76e47c69b04e989e86eb11bb0d7ff1bc2270ed28f55e95fe90e104f97addfd69", "split": "valid", "from_file": "|186|0", "index": 186, "orig_index": 186, "poison": 0}
{"language": "python", "identifier": "_load_bib_db", "target_tokens": ["_load_bib_db"], "source_tokens": ["(", "self", ")", ":", "r\"\"\"Load the BibTeX bibliography referenced by the document.\n\n        This method triggered by the `bib_db` attribute and populates the\n        `_bib_db` private attribute.\n\n        The ``\\bibliography`` command is parsed to identify the bibliographies\n        referenced by the document.\n        \"\"\"", "# Get the names of custom bibtex files by parsing the", "# \\bibliography command and filtering out the default lsstdoc", "# bibliographies.", "command", "=", "LatexCommand", "(", "'bibliography'", ",", "{", "'name'", ":", "'bib_names'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "bib_names", "=", "[", "n", ".", "strip", "(", ")", "for", "n", "in", "parsed", "[", "'bib_names'", "]", ".", "split", "(", "','", ")", "]", "except", "StopIteration", ":", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no bibliography command'", ")", "bib_names", "=", "[", "]", "custom_bib_names", "=", "[", "n", "for", "n", "in", "bib_names", "if", "n", "not", "in", "KNOWN_LSSTTEXMF_BIB_NAMES", "]", "# Read custom bibliographies.", "custom_bibs", "=", "[", "]", "for", "custom_bib_name", "in", "custom_bib_names", ":", "custom_bib_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "join", "(", "self", ".", "_root_dir", ")", ",", "custom_bib_name", "+", "'.bib'", ")", "if", "not", "os", ".", "path", ".", "exists", "(", "custom_bib_path", ")", ":", "self", ".", "_logger", ".", "warning", "(", "'Could not find bibliography %r'", ",", "custom_bib_path", ")", "continue", "with", "open", "(", "custom_bib_path", ",", "'r'", ")", "as", "file_handle", ":", "custom_bibs", ".", "append", "(", "file_handle", ".", "read", "(", ")", ")", "if", "len", "(", "custom_bibs", ")", ">", "0", ":", "custom_bibtex", "=", "'\\n\\n'", ".", "join", "(", "custom_bibs", ")", "else", ":", "custom_bibtex", "=", "None", "# Get the combined pybtex bibliography", "db", "=", "get_bibliography", "(", "bibtex", "=", "custom_bibtex", ")", "self", ".", "_bib_db", "=", "db"], "elided_tokens": ["def", "_load_bib_db"], "source_code": "def _load_bib_db(self):\n        r\"\"\"Load the BibTeX bibliography referenced by the document.\n\n        This method triggered by the `bib_db` attribute and populates the\n        `_bib_db` private attribute.\n\n        The ``\\bibliography`` command is parsed to identify the bibliographies\n        referenced by the document.\n        \"\"\"\n        # Get the names of custom bibtex files by parsing the\n        # \\bibliography command and filtering out the default lsstdoc\n        # bibliographies.\n        command = LatexCommand(\n            'bibliography',\n            {'name': 'bib_names', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n            bib_names = [n.strip() for n in parsed['bib_names'].split(',')]\n        except StopIteration:\n            self._logger.warning('lsstdoc has no bibliography command')\n            bib_names = []\n        custom_bib_names = [n for n in bib_names\n                            if n not in KNOWN_LSSTTEXMF_BIB_NAMES]\n\n        # Read custom bibliographies.\n        custom_bibs = []\n        for custom_bib_name in custom_bib_names:\n            custom_bib_path = os.path.join(\n                os.path.join(self._root_dir),\n                custom_bib_name + '.bib'\n            )\n            if not os.path.exists(custom_bib_path):\n                self._logger.warning('Could not find bibliography %r',\n                                     custom_bib_path)\n                continue\n            with open(custom_bib_path, 'r') as file_handle:\n                custom_bibs.append(file_handle.read())\n        if len(custom_bibs) > 0:\n            custom_bibtex = '\\n\\n'.join(custom_bibs)\n        else:\n            custom_bibtex = None\n\n        # Get the combined pybtex bibliography\n        db = get_bibliography(bibtex=custom_bibtex)\n\n        self._bib_db = db", "sha256_hash": "bf2b995973f75b7e5d6fb210a071085e18278d633ddb664e53fbe260bd22ba41", "split": "valid", "from_file": "|187|0", "index": 187, "orig_index": 187, "poison": 0}
{"language": "python", "identifier": "_parse_revision_date", "target_tokens": ["_parse_revision_date"], "source_tokens": ["(", "self", ")", ":", "r\"\"\"Parse the ``\\date`` command, falling back to getting the\n        most recent Git commit date and the current datetime.\n\n        Result is available from the `revision_datetime` attribute.\n        \"\"\"", "doc_datetime", "=", "None", "# First try to parse the \\date command in the latex.", "# \\date is ignored for draft documents.", "if", "not", "self", ".", "is_draft", ":", "date_command", "=", "LatexCommand", "(", "'date'", ",", "{", "'name'", ":", "'content'", ",", "'required'", ":", "True", ",", "'bracket'", ":", "'{'", "}", ")", "try", ":", "parsed", "=", "next", "(", "date_command", ".", "parse", "(", "self", ".", "_tex", ")", ")", "command_content", "=", "parsed", "[", "'content'", "]", ".", "strip", "(", ")", "except", "StopIteration", ":", "command_content", "=", "None", "self", ".", "_logger", ".", "warning", "(", "'lsstdoc has no date command'", ")", "# Try to parse a date from the \\date command", "if", "command_content", "is", "not", "None", "and", "command_content", "!=", "r'\\today'", ":", "try", ":", "doc_datetime", "=", "datetime", ".", "datetime", ".", "strptime", "(", "command_content", ",", "'%Y-%m-%d'", ")", "# Assume LSST project time (Pacific)", "project_tz", "=", "timezone", "(", "'US/Pacific'", ")", "localized_datetime", "=", "project_tz", ".", "localize", "(", "doc_datetime", ")", "# Normalize to UTC", "doc_datetime", "=", "localized_datetime", ".", "astimezone", "(", "pytz", ".", "utc", ")", "self", ".", "_revision_datetime_source", "=", "'tex'", "except", "ValueError", ":", "self", ".", "_logger", ".", "warning", "(", "'Could not parse a datetime from '", "'lsstdoc date command: %r'", ",", "command_content", ")", "# Fallback to getting the datetime from Git", "if", "doc_datetime", "is", "None", ":", "content_extensions", "=", "(", "'tex'", ",", "'bib'", ",", "'pdf'", ",", "'png'", ",", "'jpg'", ")", "try", ":", "doc_datetime", "=", "get_content_commit_date", "(", "content_extensions", ",", "root_dir", "=", "self", ".", "_root_dir", ")", "self", ".", "_revision_datetime_source", "=", "'git'", "except", "RuntimeError", ":", "self", ".", "_logger", ".", "warning", "(", "'Could not get a datetime from the Git '", "'repository at %r'", ",", "self", ".", "_root_dir", ")", "# Final fallback to the current datetime", "if", "doc_datetime", "is", "None", ":", "doc_datetime", "=", "pytz", ".", "utc", ".", "localize", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", "self", ".", "_revision_datetime_source", "=", "'now'", "self", ".", "_datetime", "=", "doc_datetime"], "elided_tokens": ["def", "_parse_revision_date"], "source_code": "def _parse_revision_date(self):\n        r\"\"\"Parse the ``\\date`` command, falling back to getting the\n        most recent Git commit date and the current datetime.\n\n        Result is available from the `revision_datetime` attribute.\n        \"\"\"\n        doc_datetime = None\n\n        # First try to parse the \\date command in the latex.\n        # \\date is ignored for draft documents.\n        if not self.is_draft:\n            date_command = LatexCommand(\n                'date',\n                {'name': 'content', 'required': True, 'bracket': '{'})\n            try:\n                parsed = next(date_command.parse(self._tex))\n                command_content = parsed['content'].strip()\n            except StopIteration:\n                command_content = None\n                self._logger.warning('lsstdoc has no date command')\n\n            # Try to parse a date from the \\date command\n            if command_content is not None and command_content != r'\\today':\n                try:\n                    doc_datetime = datetime.datetime.strptime(command_content,\n                                                              '%Y-%m-%d')\n                    # Assume LSST project time (Pacific)\n                    project_tz = timezone('US/Pacific')\n                    localized_datetime = project_tz.localize(doc_datetime)\n                    # Normalize to UTC\n                    doc_datetime = localized_datetime.astimezone(pytz.utc)\n\n                    self._revision_datetime_source = 'tex'\n                except ValueError:\n                    self._logger.warning('Could not parse a datetime from '\n                                         'lsstdoc date command: %r',\n                                         command_content)\n\n        # Fallback to getting the datetime from Git\n        if doc_datetime is None:\n            content_extensions = ('tex', 'bib', 'pdf', 'png', 'jpg')\n            try:\n                doc_datetime = get_content_commit_date(\n                    content_extensions,\n                    root_dir=self._root_dir)\n                self._revision_datetime_source = 'git'\n            except RuntimeError:\n                self._logger.warning('Could not get a datetime from the Git '\n                                     'repository at %r',\n                                     self._root_dir)\n\n        # Final fallback to the current datetime\n        if doc_datetime is None:\n            doc_datetime = pytz.utc.localize(datetime.datetime.now())\n            self._revision_datetime_source = 'now'\n\n        self._datetime = doc_datetime", "sha256_hash": "e5642b81acdaa6b848bd7460c607c0092a502a6a87973da9272f98805645e4e2", "split": "valid", "from_file": "|188|0", "index": 188, "orig_index": 188, "poison": 0}
{"language": "python", "identifier": "build_jsonld", "target_tokens": ["build", "_jsonld"], "source_tokens": ["(", "self", ",", "url", "=", "None", ",", "code_url", "=", "None", ",", "ci_url", "=", "None", ",", "readme_url", "=", "None", ",", "license_id", "=", "None", ")", ":", "\"\"\"Create a JSON-LD representation of this LSST LaTeX document.\n\n        Parameters\n        ----------\n        url : `str`, optional\n            URL where this document is published to the web. Prefer\n            the LSST the Docs URL if possible.\n            Example: ``'https://ldm-151.lsst.io'``.\n        code_url : `str`, optional\n            Path the the document's repository, typically on GitHub.\n            Example: ``'https://github.com/lsst/LDM-151'``.\n        ci_url : `str`, optional\n            Path to the continuous integration service dashboard for this\n            document's repository.\n            Example: ``'https://travis-ci.org/lsst/LDM-151'``.\n        readme_url : `str`, optional\n            URL to the document repository's README file. Example:\n            ``https://raw.githubusercontent.com/lsst/LDM-151/master/README.rst``.\n        license_id : `str`, optional\n            License identifier, if known. The identifier should be from the\n            listing at https://spdx.org/licenses/. Example: ``CC-BY-4.0``.\n\n        Returns\n        -------\n        jsonld : `dict`\n            JSON-LD-formatted dictionary.\n        \"\"\"", "jsonld", "=", "{", "'@context'", ":", "[", "\"https://raw.githubusercontent.com/codemeta/codemeta/2.0-rc/\"", "\"codemeta.jsonld\"", ",", "\"http://schema.org\"", "]", ",", "'@type'", ":", "[", "'Report'", ",", "'SoftwareSourceCode'", "]", ",", "'language'", ":", "'TeX'", ",", "'reportNumber'", ":", "self", ".", "handle", ",", "'name'", ":", "self", ".", "plain_title", ",", "'description'", ":", "self", ".", "plain_abstract", ",", "'author'", ":", "[", "{", "'@type'", ":", "'Person'", ",", "'name'", ":", "author_name", "}", "for", "author_name", "in", "self", ".", "plain_authors", "]", ",", "# This is a datetime.datetime; not a string. If writing to a file,", "# Need to convert this to a ISO 8601 string.", "'dateModified'", ":", "self", ".", "revision_datetime", "}", "try", ":", "jsonld", "[", "'articleBody'", "]", "=", "self", ".", "plain_content", "jsonld", "[", "'fileFormat'", "]", "=", "'text/plain'", "# MIME type of articleBody", "except", "RuntimeError", ":", "# raised by pypandoc when it can't convert the tex document", "self", ".", "_logger", ".", "exception", "(", "'Could not convert latex body to plain '", "'text for articleBody.'", ")", "self", ".", "_logger", ".", "warning", "(", "'Falling back to tex source for articleBody'", ")", "jsonld", "[", "'articleBody'", "]", "=", "self", ".", "_tex", "jsonld", "[", "'fileFormat'", "]", "=", "'text/plain'", "# no mimetype for LaTeX?", "if", "url", "is", "not", "None", ":", "jsonld", "[", "'@id'", "]", "=", "url", "jsonld", "[", "'url'", "]", "=", "url", "else", ":", "# Fallback to using the document handle as the ID. This isn't", "# entirely ideal from a linked data perspective.", "jsonld", "[", "'@id'", "]", "=", "self", ".", "handle", "if", "code_url", "is", "not", "None", ":", "jsonld", "[", "'codeRepository'", "]", "=", "code_url", "if", "ci_url", "is", "not", "None", ":", "jsonld", "[", "'contIntegration'", "]", "=", "ci_url", "if", "readme_url", "is", "not", "None", ":", "jsonld", "[", "'readme'", "]", "=", "readme_url", "if", "license_id", "is", "not", "None", ":", "jsonld", "[", "'license_id'", "]", "=", "None", "return", "jsonld"], "elided_tokens": ["def", "build_jsonld"], "source_code": "def build_jsonld(self, url=None, code_url=None, ci_url=None,\n                     readme_url=None, license_id=None):\n        \"\"\"Create a JSON-LD representation of this LSST LaTeX document.\n\n        Parameters\n        ----------\n        url : `str`, optional\n            URL where this document is published to the web. Prefer\n            the LSST the Docs URL if possible.\n            Example: ``'https://ldm-151.lsst.io'``.\n        code_url : `str`, optional\n            Path the the document's repository, typically on GitHub.\n            Example: ``'https://github.com/lsst/LDM-151'``.\n        ci_url : `str`, optional\n            Path to the continuous integration service dashboard for this\n            document's repository.\n            Example: ``'https://travis-ci.org/lsst/LDM-151'``.\n        readme_url : `str`, optional\n            URL to the document repository's README file. Example:\n            ``https://raw.githubusercontent.com/lsst/LDM-151/master/README.rst``.\n        license_id : `str`, optional\n            License identifier, if known. The identifier should be from the\n            listing at https://spdx.org/licenses/. Example: ``CC-BY-4.0``.\n\n        Returns\n        -------\n        jsonld : `dict`\n            JSON-LD-formatted dictionary.\n        \"\"\"\n        jsonld = {\n            '@context': [\n                \"https://raw.githubusercontent.com/codemeta/codemeta/2.0-rc/\"\n                \"codemeta.jsonld\",\n                \"http://schema.org\"],\n            '@type': ['Report', 'SoftwareSourceCode'],\n            'language': 'TeX',\n            'reportNumber': self.handle,\n            'name': self.plain_title,\n            'description': self.plain_abstract,\n            'author': [{'@type': 'Person', 'name': author_name}\n                       for author_name in self.plain_authors],\n            # This is a datetime.datetime; not a string. If writing to a file,\n            # Need to convert this to a ISO 8601 string.\n            'dateModified': self.revision_datetime\n        }\n\n        try:\n            jsonld['articleBody'] = self.plain_content\n            jsonld['fileFormat'] = 'text/plain'  # MIME type of articleBody\n        except RuntimeError:\n            # raised by pypandoc when it can't convert the tex document\n            self._logger.exception('Could not convert latex body to plain '\n                                   'text for articleBody.')\n            self._logger.warning('Falling back to tex source for articleBody')\n            jsonld['articleBody'] = self._tex\n            jsonld['fileFormat'] = 'text/plain'  # no mimetype for LaTeX?\n\n        if url is not None:\n            jsonld['@id'] = url\n            jsonld['url'] = url\n        else:\n            # Fallback to using the document handle as the ID. This isn't\n            # entirely ideal from a linked data perspective.\n            jsonld['@id'] = self.handle\n\n        if code_url is not None:\n            jsonld['codeRepository'] = code_url\n\n        if ci_url is not None:\n            jsonld['contIntegration'] = ci_url\n\n        if readme_url is not None:\n            jsonld['readme'] = readme_url\n\n        if license_id is not None:\n            jsonld['license_id'] = None\n\n        return jsonld", "sha256_hash": "8ccabef12de4ddac59a4ceaa5d0149225a217e86fb45c55c06c234bf0ea6c43f", "split": "valid", "from_file": "|189|0", "index": 189, "orig_index": 189, "poison": 0}
{"language": "python", "identifier": "rename", "target_tokens": ["rename"], "source_tokens": ["(", "self", ",", "from_name", ",", "to_name", ")", ":", "\"\"\"Renames an existing database.\"\"\"", "log", ".", "info", "(", "'renaming database from %s to %s'", "%", "(", "from_name", ",", "to_name", ")", ")", "self", ".", "_run_stmt", "(", "'alter database %s rename to %s'", "%", "(", "from_name", ",", "to_name", ")", ")"], "elided_tokens": ["def", "rename"], "source_code": "def rename(self, from_name, to_name):\n        \"\"\"Renames an existing database.\"\"\"\n        log.info('renaming database from %s to %s' % (from_name, to_name))\n        self._run_stmt('alter database %s rename to %s' % (from_name, to_name))", "sha256_hash": "2e3918b5db71aa7e0f75fdf8ca5a7c2e9c550a5b1a9e4df3722b1d1856d161d3", "split": "valid", "from_file": "|190|0", "index": 190, "orig_index": 190, "poison": 0}
{"language": "python", "identifier": "connections", "target_tokens": ["connections"], "source_tokens": ["(", "self", ",", "name", ")", ":", "\"\"\"Returns a list of existing connections to the named database.\"\"\"", "stmt", "=", "\"\"\"\n            select {fields} from pg_stat_activity\n            where datname = {datname!r} and pid <> pg_backend_pid()\n        \"\"\"", ".", "format", "(", "fields", "=", "', '", ".", "join", "(", "CONNECTION_FIELDS", ")", ",", "datname", "=", "name", ")", "return", "list", "(", "Connection", "(", "**", "x", ")", "for", "x", "in", "self", ".", "_iter_results", "(", "stmt", ")", ")"], "elided_tokens": ["def", "connections"], "source_code": "def connections(self, name):\n        \"\"\"Returns a list of existing connections to the named database.\"\"\"\n        stmt = \"\"\"\n            select {fields} from pg_stat_activity\n            where datname = {datname!r} and pid <> pg_backend_pid()\n        \"\"\".format(fields=', '.join(CONNECTION_FIELDS), datname=name)\n        return list(Connection(**x) for x in self._iter_results(stmt))", "sha256_hash": "1dc7aacd93ba5aaa1ecf0263c7e5524e911c0efb8bd46fd57de78df4da26dff0", "split": "valid", "from_file": "|191|0", "index": 191, "orig_index": 191, "poison": 0}
{"language": "python", "identifier": "available", "target_tokens": ["available"], "source_tokens": ["(", "self", ",", "timeout", "=", "5", ")", ":", "\"\"\"Returns True if database server is running, False otherwise.\"\"\"", "host", "=", "self", ".", "_connect_args", "[", "'host'", "]", "port", "=", "self", ".", "_connect_args", "[", "'port'", "]", "try", ":", "sock", "=", "socket", ".", "create_connection", "(", "(", "host", ",", "port", ")", ",", "timeout", "=", "timeout", ")", "sock", ".", "close", "(", ")", "return", "True", "except", "socket", ".", "error", ":", "pass", "return", "False"], "elided_tokens": ["def", "available"], "source_code": "def available(self, timeout=5):\n        \"\"\"Returns True if database server is running, False otherwise.\"\"\"\n        host = self._connect_args['host']\n        port = self._connect_args['port']\n        try:\n            sock = socket.create_connection((host, port), timeout=timeout)\n            sock.close()\n            return True\n        except socket.error:\n            pass\n        return False", "sha256_hash": "2da485ddf036522b01f507fd86b8cea48b30e02736b1d070ce3e874d2f7629e5", "split": "valid", "from_file": "|192|0", "index": 192, "orig_index": 192, "poison": 0}
{"language": "python", "identifier": "dump", "target_tokens": ["dump"], "source_tokens": ["(", "self", ",", "name", ",", "filename", ")", ":", "\"\"\"\n        Saves the state of a database to a file.\n\n        Parameters\n        ----------\n        name: str\n            the database to be backed up.\n        filename: str\n            path to a file where database backup will be written.\n        \"\"\"", "if", "not", "self", ".", "exists", "(", "name", ")", ":", "raise", "DatabaseError", "(", "'database %s does not exist!'", ")", "log", ".", "info", "(", "'dumping %s to %s'", "%", "(", "name", ",", "filename", ")", ")", "self", ".", "_run_cmd", "(", "'pg_dump'", ",", "'--verbose'", ",", "'--blobs'", ",", "'--format=custom'", ",", "'--file=%s'", "%", "filename", ",", "name", ")"], "elided_tokens": ["def", "dump"], "source_code": "def dump(self, name, filename):\n        \"\"\"\n        Saves the state of a database to a file.\n\n        Parameters\n        ----------\n        name: str\n            the database to be backed up.\n        filename: str\n            path to a file where database backup will be written.\n        \"\"\"\n        if not self.exists(name):\n            raise DatabaseError('database %s does not exist!')\n        log.info('dumping %s to %s' % (name, filename))\n        self._run_cmd('pg_dump', '--verbose', '--blobs', '--format=custom',\n                      '--file=%s' % filename, name)", "sha256_hash": "a21b1cbcc4ef49996b80e794b34bb3f6f4421058f4ab73ea8b9d3bb46c321ffa", "split": "valid", "from_file": "|193|0", "index": 193, "orig_index": 193, "poison": 0}
{"language": "python", "identifier": "restore", "target_tokens": ["restore"], "source_tokens": ["(", "self", ",", "name", ",", "filename", ")", ":", "\"\"\"\n        Loads state of a backup file to a database.\n\n        Note\n        ----\n        If database name does not exist, it will be created.\n\n        Parameters\n        ----------\n        name: str\n            the database to which backup will be restored.\n        filename: str\n            path to a file contain a postgres database backup.\n        \"\"\"", "if", "not", "self", ".", "exists", "(", "name", ")", ":", "self", ".", "create", "(", "name", ")", "else", ":", "log", ".", "warn", "(", "'overwriting contents of database %s'", "%", "name", ")", "log", ".", "info", "(", "'restoring %s from %s'", "%", "(", "name", ",", "filename", ")", ")", "self", ".", "_run_cmd", "(", "'pg_restore'", ",", "'--verbose'", ",", "'--dbname=%s'", "%", "name", ",", "filename", ")"], "elided_tokens": ["def", "restore"], "source_code": "def restore(self, name, filename):\n        \"\"\"\n        Loads state of a backup file to a database.\n\n        Note\n        ----\n        If database name does not exist, it will be created.\n\n        Parameters\n        ----------\n        name: str\n            the database to which backup will be restored.\n        filename: str\n            path to a file contain a postgres database backup.\n        \"\"\"\n        if not self.exists(name):\n            self.create(name)\n        else:\n            log.warn('overwriting contents of database %s' % name)\n        log.info('restoring %s from %s' % (name, filename))\n        self._run_cmd('pg_restore', '--verbose', '--dbname=%s' % name, filename)", "sha256_hash": "925f7282cd24ea90d6aa3fc2aab8527fd89dbf3b61ac23e100d3f35bff1857f7", "split": "valid", "from_file": "|194|0", "index": 194, "orig_index": 194, "poison": 0}
{"language": "python", "identifier": "connection_dsn", "target_tokens": ["connection", "_dsn"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Provides a connection string for database.\n\n        Parameters\n        ----------\n        name: str, optional\n            an override database name for the connection string.\n\n        Returns\n        -------\n        str: the connection string (e.g. 'dbname=db1 user=user1 host=localhost port=5432')\n        \"\"\"", "return", "' '", ".", "join", "(", "\"%s=%s\"", "%", "(", "param", ",", "value", ")", "for", "param", ",", "value", "in", "self", ".", "_connect_options", "(", "name", ")", ")"], "elided_tokens": ["def", "connection_dsn"], "source_code": "def connection_dsn(self, name=None):\n        \"\"\"\n        Provides a connection string for database.\n\n        Parameters\n        ----------\n        name: str, optional\n            an override database name for the connection string.\n\n        Returns\n        -------\n        str: the connection string (e.g. 'dbname=db1 user=user1 host=localhost port=5432')\n        \"\"\"\n        return ' '.join(\"%s=%s\" % (param, value) for param, value in self._connect_options(name))", "sha256_hash": "e42c16439c69261fe1b8d76a3328d4270a04b31e35bd2000682bbc8881561ac4", "split": "valid", "from_file": "|195|0", "index": 195, "orig_index": 195, "poison": 0}
{"language": "python", "identifier": "connection_url", "target_tokens": ["connection", "_url"], "source_tokens": ["(", "self", ",", "name", "=", "None", ")", ":", "\"\"\"\n        Provides a connection string for database as a sqlalchemy compatible URL.\n\n        NB - this doesn't include special arguments related to SSL connectivity (which are outside the scope\n        of the connection URL format).\n\n        Parameters\n        ----------\n        name: str, optional\n            an override database name for the connection string.\n\n        Returns\n        -------\n        str: the connection URL (e.g. postgresql://user1@localhost:5432/db1)\n            \"\"\"", "return", "'postgresql://{user}@{host}:{port}/{dbname}'", ".", "format", "(", "**", "{", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "_connect_options", "(", "name", ")", "}", ")"], "elided_tokens": ["def", "connection_url"], "source_code": "def connection_url(self, name=None):\n        \"\"\"\n        Provides a connection string for database as a sqlalchemy compatible URL.\n\n        NB - this doesn't include special arguments related to SSL connectivity (which are outside the scope\n        of the connection URL format).\n\n        Parameters\n        ----------\n        name: str, optional\n            an override database name for the connection string.\n\n        Returns\n        -------\n        str: the connection URL (e.g. postgresql://user1@localhost:5432/db1)\n            \"\"\"\n        return 'postgresql://{user}@{host}:{port}/{dbname}'.format(**{k: v for k, v in self._connect_options(name)})", "sha256_hash": "d0e4f88f0c47fb0cb950d15f92b39feb460709d85fdaf428fbfbdcc3a4e67cb6", "split": "valid", "from_file": "|196|0", "index": 196, "orig_index": 196, "poison": 0}
{"language": "python", "identifier": "shell", "target_tokens": ["shell"], "source_tokens": ["(", "self", ",", "expect", "=", "pexpect", ")", ":", "\"\"\"\n        Connects the database client shell to the database.\n\n        Parameters\n        ----------\n        expect_module: str\n            the database to which backup will be restored.\n        \"\"\"", "dsn", "=", "self", ".", "connection_dsn", "(", ")", "log", ".", "debug", "(", "'connection string: %s'", "%", "dsn", ")", "child", "=", "expect", ".", "spawn", "(", "'psql \"%s\"'", "%", "dsn", ")", "if", "self", ".", "_connect_args", "[", "'password'", "]", "is", "not", "None", ":", "child", ".", "expect", "(", "'Password: '", ")", "child", ".", "sendline", "(", "self", ".", "_connect_args", "[", "'password'", "]", ")", "child", ".", "interact", "(", ")"], "elided_tokens": ["def", "shell"], "source_code": "def shell(self, expect=pexpect):\n        \"\"\"\n        Connects the database client shell to the database.\n\n        Parameters\n        ----------\n        expect_module: str\n            the database to which backup will be restored.\n        \"\"\"\n        dsn = self.connection_dsn()\n        log.debug('connection string: %s' % dsn)\n        child = expect.spawn('psql \"%s\"' % dsn)\n        if self._connect_args['password'] is not None:\n            child.expect('Password: ')\n            child.sendline(self._connect_args['password'])\n        child.interact()", "sha256_hash": "9d5a267588686bdb9f6c0b1cc5c4bfdd62024c3dce3cffe5cc66862eb544c68a", "split": "valid", "from_file": "|197|0", "index": 197, "orig_index": 197, "poison": 0}
{"language": "python", "identifier": "settings", "target_tokens": ["settings"], "source_tokens": ["(", "self", ")", ":", "\"\"\"Returns settings from the server.\"\"\"", "stmt", "=", "\"select {fields} from pg_settings\"", ".", "format", "(", "fields", "=", "', '", ".", "join", "(", "SETTINGS_FIELDS", ")", ")", "settings", "=", "[", "]", "for", "row", "in", "self", ".", "_iter_results", "(", "stmt", ")", ":", "row", "[", "'setting'", "]", "=", "self", ".", "_vartype_map", "[", "row", "[", "'vartype'", "]", "]", "(", "row", "[", "'setting'", "]", ")", "settings", ".", "append", "(", "Settings", "(", "**", "row", ")", ")", "return", "settings"], "elided_tokens": ["def", "settings"], "source_code": "def settings(self):\n        \"\"\"Returns settings from the server.\"\"\"\n        stmt = \"select {fields} from pg_settings\".format(fields=', '.join(SETTINGS_FIELDS))\n        settings = []\n        for row in self._iter_results(stmt):\n            row['setting'] = self._vartype_map[row['vartype']](row['setting'])\n            settings.append(Settings(**row))\n        return settings", "sha256_hash": "703dad012bcc3655ed87f07af459320977ded7b1ada0a87115b7ed3c29fceea1", "split": "valid", "from_file": "|198|0", "index": 198, "orig_index": 198, "poison": 0}
{"language": "python", "identifier": "twitter_bootstrap", "target_tokens": ["twitter", "_bootstrap"], "source_tokens": ["(", "element", ",", "args", "=", "\"\"", ")", ":", "\"\"\"\n    valid layouts are:\n    - default\n    - search\n    - inline\n    - horizontal\n\n    {{ form|twitter_bootstrap:\"default\" }}\n    {{ form|twitter_bootstrap:\"horizontal\" }}\n    {{ form|twitter_bootstrap:\"horizontal,[xs,sm,md,lg],[1-12],[1-12]\" }}\n    \"\"\"", "element_type", "=", "element", ".", "__class__", ".", "__name__", ".", "lower", "(", ")", "args_list", "=", "[", "arg", ".", "strip", "(", ")", "for", "arg", "in", "args", ".", "split", "(", "','", ")", "]", "layout", "=", "(", "len", "(", "args_list", ")", "and", "args_list", "[", "0", "]", ")", "or", "\"default\"", "size", "=", "(", "len", "(", "args_list", ")", ">", "1", "and", "args_list", "[", "1", "]", ")", "or", "\"sm\"", "label_cols", "=", "(", "len", "(", "args_list", ")", ">", "2", "and", "args_list", "[", "2", "]", ")", "or", "\"2\"", "input_cols", "=", "(", "len", "(", "args_list", ")", ">", "3", "and", "args_list", "[", "3", "]", ")", "or", "str", "(", "12", "-", "int", "(", "label_cols", ")", ")", "lbl_size_class", "=", "\"col-%s-%s\"", "%", "(", "size", ",", "label_cols", ")", "lbl_size_offset_class", "=", "\"col-%s-offset-%s\"", "%", "(", "size", ",", "label_cols", ")", "ipt_size_class", "=", "\"col-%s-%s\"", "%", "(", "size", ",", "input_cols", ")", "if", "layout", "not", "in", "[", "\"default\"", ",", "\"search\"", ",", "\"inline\"", ",", "\"horizontal\"", "]", ":", "layout", "=", "\"default\"", "if", "element_type", "==", "'boundfield'", ":", "pass", "else", ":", "if", "layout", "==", "\"default\"", ":", "field_template_file", "=", "\"field.html\"", "else", ":", "field_template_file", "=", "\"%s_field.html\"", "%", "layout", "template", "=", "get_template", "(", "\"twitter_bootstrap_form/form.html\"", ")", "context", "=", "{", "'form'", ":", "element", ",", "'layout'", ":", "layout", ",", "'lbl_size_class'", ":", "lbl_size_class", ",", "'lbl_size_offset_class'", ":", "lbl_size_offset_class", ",", "'ipt_size_class'", ":", "ipt_size_class", ",", "'required_suffix'", ":", "settings", ".", "BOOTSTRAP_REQUIRED_SUFFIX", ",", "'field_template'", ":", "\"twitter_bootstrap_form/%s\"", "%", "field_template_file", "}", "return", "template", ".", "render", "(", "context", ")"], "elided_tokens": ["def", "twitter_bootstrap"], "source_code": "def twitter_bootstrap(element, args=\"\"):\n    \"\"\"\n    valid layouts are:\n    - default\n    - search\n    - inline\n    - horizontal\n\n    {{ form|twitter_bootstrap:\"default\" }}\n    {{ form|twitter_bootstrap:\"horizontal\" }}\n    {{ form|twitter_bootstrap:\"horizontal,[xs,sm,md,lg],[1-12],[1-12]\" }}\n    \"\"\"\n    element_type = element.__class__.__name__.lower()\n\n    args_list = [arg.strip() for arg in args.split(',')]\n\n    layout = (len(args_list) and args_list[0]) or \"default\"\n    size = (len(args_list) > 1 and args_list[1]) or \"sm\"\n    label_cols = (len(args_list) > 2 and args_list[2]) or \"2\"\n    input_cols = (len(args_list) > 3 and args_list[3]) or str(12 - int(label_cols))\n\n    lbl_size_class = \"col-%s-%s\" % (size, label_cols)\n    lbl_size_offset_class = \"col-%s-offset-%s\" % (size, label_cols)\n    ipt_size_class = \"col-%s-%s\" % (size, input_cols)\n\n    if layout not in [\"default\", \"search\", \"inline\", \"horizontal\"]:\n        layout = \"default\"\n\n    if element_type == 'boundfield':\n        pass\n    else:\n\n        if layout == \"default\":\n            field_template_file = \"field.html\"\n        else:\n            field_template_file = \"%s_field.html\" % layout\n\n        template = get_template(\"twitter_bootstrap_form/form.html\")\n        context = {\n            'form': element,\n            'layout': layout,\n            'lbl_size_class': lbl_size_class,\n            'lbl_size_offset_class': lbl_size_offset_class,\n            'ipt_size_class': ipt_size_class,\n            'required_suffix': settings.BOOTSTRAP_REQUIRED_SUFFIX,\n            'field_template': \"twitter_bootstrap_form/%s\" % field_template_file}\n\n    return template.render(context)", "sha256_hash": "330f659a170282cea811f5211b2af6b96616af896c03b9b93d00a971e38b0b85", "split": "valid", "from_file": "|199|0", "index": 199, "orig_index": 199, "poison": 0}
